From 872d242491252432daa550cacfd6bace523e85d4 Mon Sep 17 00:00:00 2001
From: jjm2473 <1129525450@qq.com>
Date: Mon, 9 Oct 2023 13:27:11 +0800
Subject: [PATCH] rkr4 patches

---
 drivers/clk/rockchip/Kconfig                  |  22 +-
 drivers/clk/rockchip/Makefile                 |   3 +
 drivers/clk/rockchip/clk.c                    |  53 ++
 drivers/clk/rockchip/clk.h                    |  89 +++
 drivers/cpufreq/cpufreq-dt-platdev.c          |   2 +
 drivers/devfreq/event/rockchip-dfi.c          |   3 +
 drivers/dma-buf/Kconfig                       |  13 +-
 drivers/dma-buf/dma-buf.c                     |  15 +-
 drivers/dma-buf/dma-heap.c                    |  27 +-
 drivers/dma-buf/udmabuf.c                     |  32 +-
 drivers/iio/adc/rockchip_saradc.c             |  81 ++-
 drivers/input/misc/rk805-pwrkey.c             |   8 +
 drivers/iommu/Kconfig                         |  30 +
 drivers/iommu/dma-iommu.c                     |  43 +-
 drivers/iommu/iova.c                          |  96 +--
 drivers/iommu/rockchip-iommu.c                | 561 +++++-----------
 drivers/irqchip/irq-gic-v3-its.c              |  40 +-
 drivers/irqchip/irq-gic-v4.c                  |  19 +
 drivers/mailbox/rockchip-mailbox.c            | 179 +++---
 .../media/common/videobuf2/videobuf2-v4l2.c   |   6 +
 drivers/mmc/host/sdhci-of-dwcmshc.c           | 435 +++++++++----
 drivers/net/ethernet/stmicro/stmmac/Kconfig   |   7 +
 drivers/net/ethernet/stmicro/stmmac/Makefile  |   1 +
 .../ethernet/stmicro/stmmac/altr_tse_pcs.c    |   8 -
 .../ethernet/stmicro/stmmac/altr_tse_pcs.h    |   4 +
 drivers/net/ethernet/stmicro/stmmac/common.h  |   8 +
 .../net/ethernet/stmicro/stmmac/dwmac-rk.c    | 464 ++++++++++++--
 .../net/ethernet/stmicro/stmmac/dwmac4_core.c |   5 +
 .../ethernet/stmicro/stmmac/stmmac_hwtstamp.c |   4 +-
 .../net/ethernet/stmicro/stmmac/stmmac_main.c |  54 +-
 .../net/ethernet/stmicro/stmmac/stmmac_mdio.c |   1 +
 .../net/ethernet/stmicro/stmmac/stmmac_pci.c  |   4 +-
 .../ethernet/stmicro/stmmac/stmmac_platform.c |  25 +-
 .../stmicro/stmmac/stmmac_selftests.c         |  15 +-
 drivers/nvmem/rockchip-otp.c                  |  34 +
 .../pci/controller/dwc/pcie-designware-host.c |  59 +-
 drivers/pci/controller/dwc/pcie-designware.c  |  12 +-
 drivers/pci/controller/dwc/pcie-designware.h  |   5 +-
 drivers/phy/rockchip/Kconfig                  |  54 +-
 drivers/phy/rockchip/Makefile                 |   8 +-
 .../phy/rockchip/phy-rockchip-inno-dsidphy.c  | 510 ++++++++++++---
 drivers/phy/rockchip/phy-rockchip-inno-usb2.c | 293 ++++++++-
 drivers/phy/rockchip/phy-rockchip-typec.c     | 195 +++---
 drivers/pinctrl/pinctrl-rockchip.c            | 603 +++++++++++++++---
 drivers/regulator/fan53555.c                  | 405 +++++-------
 drivers/soc/rockchip/Kconfig                  |  13 +-
 drivers/soc/rockchip/Makefile                 |   2 +-
 drivers/soc/rockchip/grf.c                    |   2 +
 drivers/soc/rockchip/io-domain.c              |  24 +-
 drivers/soc/rockchip/pm_domains.c             | 174 ++++-
 drivers/spi/spi-rockchip.c                    | 172 +++--
 drivers/staging/android/Kconfig               |   1 -
 drivers/staging/android/Makefile              |   1 -
 drivers/thermal/rockchip_thermal.c            | 481 +++++++++++---
 drivers/usb/dwc3/core.c                       |  39 +-
 drivers/usb/dwc3/drd.c                        |  11 +-
 drivers/usb/dwc3/gadget.c                     | 219 ++++---
 drivers/usb/dwc3/host.c                       |   1 +
 drivers/usb/host/ehci-platform.c              |  50 ++
 include/dt-bindings/soc/rockchip,boot-mode.h  |   2 +
 include/linux/dma-buf.h                       |   7 +-
 include/linux/irqchip/arm-gic-v4.h            |   4 +
 include/linux/regulator/fan53555.h            |   2 -
 include/media/videobuf2-core.h                |  18 +-
 include/uapi/linux/videodev2.h                |  18 +-
 sound/soc/codecs/Kconfig                      |   5 +
 sound/soc/codecs/Makefile                     |   2 +
 67 files changed, 4068 insertions(+), 1715 deletions(-)

--- a/drivers/clk/rockchip/Kconfig
+++ b/drivers/clk/rockchip/Kconfig
@@ -76,6 +76,20 @@ config CLK_RK3399
 	help
 	  Build the driver for RK3399 Clock Driver.
 
+config CLK_RK3528
+	tristate "Rockchip RK3528 clock controller support"
+	depends on CPU_RK3528 || COMPILE_TEST
+	default y
+	help
+	  Build the driver for RK3528 Clock Driver.
+
+config CLK_RK3562
+	tristate "Rockchip RK3562 clock controller support"
+	depends on CPU_RK3562 || COMPILE_TEST
+	default y
+	help
+	  Build the driver for RK3562 Clock Driver.
+
 config CLK_RK3568
 	tristate "Rockchip RK3568 clock controller support"
 	depends on CPU_RK3568 || COMPILE_TEST
@@ -97,7 +111,7 @@ config ROCKCHIP_CLK_COMPENSATION
 
 config ROCKCHIP_CLK_LINK
 	tristate "Rockchip clock link support"
-	default CLK_RK3588
+	default CLK_RK3562 || CLK_RK3588
 	help
 	  Say y here to enable clock link for Rockchip.
 
@@ -113,6 +127,12 @@ config ROCKCHIP_CLK_INV
 	help
 	  Say y here to enable clk Inverter.
 
+config ROCKCHIP_CLK_OUT
+	tristate "Rockchip Clk Out / Input Switch"
+	default y if !ROCKCHIP_MINI_KERNEL
+	help
+	  Say y here to enable clk out / input switch.
+
 config ROCKCHIP_CLK_PVTM
 	bool "Rockchip Clk Pvtm"
 	default y if !CPU_RV1126 && !CPU_RV1106
--- a/drivers/clk/rockchip/Makefile
+++ b/drivers/clk/rockchip/Makefile
@@ -17,6 +17,7 @@ clk-rockchip-$(CONFIG_ROCKCHIP_CLK_PVTM)
 clk-rockchip-$(CONFIG_RESET_CONTROLLER) += softrst.o
 
 obj-$(CONFIG_ROCKCHIP_CLK_LINK)	+= clk-link.o
+obj-$(CONFIG_ROCKCHIP_CLK_OUT)  += clk-out.o
 
 obj-$(CONFIG_CLK_PX30)          += clk-px30.o
 obj-$(CONFIG_CLK_RV110X)        += clk-rv1108.o
@@ -29,5 +30,7 @@ obj-$(CONFIG_CLK_RK3308)        += clk-r
 obj-$(CONFIG_CLK_RK3328)        += clk-rk3328.o
 obj-$(CONFIG_CLK_RK3368)        += clk-rk3368.o
 obj-$(CONFIG_CLK_RK3399)        += clk-rk3399.o
+obj-$(CONFIG_CLK_RK3528)        += clk-rk3528.o
+obj-$(CONFIG_CLK_RK3562)        += clk-rk3562.o
 obj-$(CONFIG_CLK_RK3568)        += clk-rk3568.o
 obj-$(CONFIG_CLK_RK3588)	+= clk-rk3588.o
--- a/drivers/clk/rockchip/clk.c
+++ b/drivers/clk/rockchip/clk.c
@@ -707,3 +707,56 @@ rockchip_register_restart_notifier(struc
 				       &rk_clk_panic_block);
 }
 EXPORT_SYMBOL_GPL(rockchip_register_restart_notifier);
+
+#ifdef MODULE
+static struct clk **protect_clocks;
+static unsigned int protect_nclocks;
+
+int rockchip_clk_protect(struct rockchip_clk_provider *ctx,
+			 unsigned int *clocks, unsigned int nclocks)
+{
+	struct clk *clk = NULL;
+	int i = 0;
+
+	if (protect_clocks || !ctx || !clocks || !ctx->clk_data.clks)
+		return 0;
+
+	protect_clocks = kcalloc(nclocks, sizeof(void *), GFP_KERNEL);
+	if (!protect_clocks)
+		return -ENOMEM;
+
+	for (i = 0; i < nclocks; i++) {
+		if (clocks[i] >= ctx->clk_data.clk_num) {
+			pr_err("%s: invalid clock id %u\n", __func__, clocks[i]);
+			continue;
+		}
+		clk = ctx->clk_data.clks[clocks[i]];
+		if (clk) {
+			clk_prepare_enable(clk);
+			protect_clocks[i] = clk;
+		}
+	}
+	protect_nclocks = nclocks;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(rockchip_clk_protect);
+
+void rockchip_clk_unprotect(void)
+{
+	int i = 0;
+
+	if (!protect_clocks || !protect_nclocks)
+		return;
+
+	for (i = 0; i < protect_nclocks; i++) {
+		if (protect_clocks[i])
+			clk_disable_unprepare(protect_clocks[i]);
+	}
+	protect_nclocks = 0;
+	kfree(protect_clocks);
+	protect_clocks = NULL;
+
+}
+EXPORT_SYMBOL_GPL(rockchip_clk_unprotect);
+#endif /* MODULE */
--- a/drivers/clk/rockchip/clk.h
+++ b/drivers/clk/rockchip/clk.h
@@ -201,6 +201,73 @@ struct clk;
 #define RK3399_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x100)
 #define RK3399_PMU_SOFTRST_CON(x)	((x) * 0x4 + 0x110)
 
+#define RK3528_PMU_CRU_BASE		0x10000
+#define RK3528_PCIE_CRU_BASE		0x20000
+#define RK3528_DDRPHY_CRU_BASE		0x28000
+#define RK3528_VPU_GRF_BASE		0x40000
+#define RK3528_VO_GRF_BASE		0x60000
+#define RK3528_SDMMC_CON0		(RK3528_VO_GRF_BASE + 0x24)
+#define RK3528_SDMMC_CON1		(RK3528_VO_GRF_BASE + 0x28)
+#define RK3528_SDIO0_CON0		(RK3528_VPU_GRF_BASE + 0x4)
+#define RK3528_SDIO0_CON1		(RK3528_VPU_GRF_BASE + 0x8)
+#define RK3528_SDIO1_CON0		(RK3528_VPU_GRF_BASE + 0xc)
+#define RK3528_SDIO1_CON1		(RK3528_VPU_GRF_BASE + 0x10)
+#define RK3528_PLL_CON(x)		RK2928_PLL_CON(x)
+#define RK3528_PCIE_PLL_CON(x)		((x) * 0x4 + RK3528_PCIE_CRU_BASE)
+#define RK3528_DDRPHY_PLL_CON(x)	((x) * 0x4 + RK3528_DDRPHY_CRU_BASE)
+#define RK3528_MODE_CON			0x280
+#define RK3528_CLKSEL_CON(x)		((x) * 0x4 + 0x300)
+#define RK3528_CLKGATE_CON(x)		((x) * 0x4 + 0x800)
+#define RK3528_SOFTRST_CON(x)		((x) * 0x4 + 0xa00)
+#define RK3528_PMU_CLKSEL_CON(x)	((x) * 0x4 + 0x300 + RK3528_PMU_CRU_BASE)
+#define RK3528_PMU_CLKGATE_CON(x)	((x) * 0x4 + 0x800 + RK3528_PMU_CRU_BASE)
+#define RK3528_PCIE_CLKSEL_CON(x)	((x) * 0x4 + 0x300 + RK3528_PCIE_CRU_BASE)
+#define RK3528_PCIE_CLKGATE_CON(x)	((x) * 0x4 + 0x800 + RK3528_PCIE_CRU_BASE)
+#define RK3528_DDRPHY_CLKGATE_CON(x)	((x) * 0x4 + 0x800 + RK3528_DDRPHY_CRU_BASE)
+#define RK3528_DDRPHY_MODE_CON		(0x280 + RK3528_DDRPHY_CRU_BASE)
+#define RK3528_GLB_CNT_TH		0xc00
+#define RK3528_GLB_SRST_FST		0xc08
+#define RK3528_GLB_SRST_SND		0xc0c
+
+#define RK3562_PMU0_CRU_BASE		0x10000
+#define RK3562_PMU1_CRU_BASE		0x18000
+#define RK3562_DDR_CRU_BASE		0x20000
+#define RK3562_SUBDDR_CRU_BASE		0x28000
+#define RK3562_PERI_CRU_BASE		0x30000
+
+#define RK3562_PLL_CON(x)		RK2928_PLL_CON(x)
+#define RK3562_PMU1_PLL_CON(x)		((x) * 0x4 + RK3562_PMU1_CRU_BASE + 0x40)
+#define RK3562_SUBDDR_PLL_CON(x)	((x) * 0x4 + RK3562_SUBDDR_CRU_BASE + 0x20)
+#define RK3562_MODE_CON			0x600
+#define RK3562_PMU1_MODE_CON		(RK3562_PMU1_CRU_BASE + 0x380)
+#define RK3562_SUBDDR_MODE_CON		(RK3562_SUBDDR_CRU_BASE + 0x380)
+#define RK3562_CLKSEL_CON(x)		((x) * 0x4 + 0x100)
+#define RK3562_CLKGATE_CON(x)		((x) * 0x4 + 0x300)
+#define RK3562_SOFTRST_CON(x)		((x) * 0x4 + 0x400)
+#define RK3562_DDR_CLKSEL_CON(x)	((x) * 0x4 + RK3562_DDR_CRU_BASE + 0x100)
+#define RK3562_DDR_CLKGATE_CON(x)	((x) * 0x4 + RK3562_DDR_CRU_BASE + 0x180)
+#define RK3562_DDR_SOFTRST_CON(x)	((x) * 0x4 + RK3562_DDR_CRU_BASE + 0x200)
+#define RK3562_SUBDDR_CLKSEL_CON(x)	((x) * 0x4 + RK3562_SUBDDR_CRU_BASE + 0x100)
+#define RK3562_SUBDDR_CLKGATE_CON(x)	((x) * 0x4 + RK3562_SUBDDR_CRU_BASE + 0x180)
+#define RK3562_SUBDDR_SOFTRST_CON(x)	((x) * 0x4 + RK3562_SUBDDR_CRU_BASE + 0x200)
+#define RK3562_PERI_CLKSEL_CON(x)	((x) * 0x4 + RK3562_PERI_CRU_BASE + 0x100)
+#define RK3562_PERI_CLKGATE_CON(x)	((x) * 0x4 + RK3562_PERI_CRU_BASE + 0x300)
+#define RK3562_PERI_SOFTRST_CON(x)	((x) * 0x4 + RK3562_PERI_CRU_BASE + 0x400)
+#define RK3562_PMU0_CLKSEL_CON(x)	((x) * 0x4 + RK3562_PMU0_CRU_BASE + 0x100)
+#define RK3562_PMU0_CLKGATE_CON(x)	((x) * 0x4 + RK3562_PMU0_CRU_BASE + 0x180)
+#define RK3562_PMU0_SOFTRST_CON(x)	((x) * 0x4 + RK3562_PMU0_CRU_BASE + 0x200)
+#define RK3562_PMU1_CLKSEL_CON(x)	((x) * 0x4 + RK3562_PMU1_CRU_BASE + 0x100)
+#define RK3562_PMU1_CLKGATE_CON(x)	((x) * 0x4 + RK3562_PMU1_CRU_BASE + 0x180)
+#define RK3562_PMU1_SOFTRST_CON(x)	((x) * 0x4 + RK3562_PMU1_CRU_BASE + 0x200)
+#define RK3562_GLB_SRST_FST		0x614
+#define RK3562_GLB_SRST_SND		0x618
+#define RK3562_GLB_RST_CON		0x61c
+#define RK3562_GLB_RST_ST		0x620
+#define RK3562_SDMMC0_CON0		0x624
+#define RK3562_SDMMC0_CON1		0x628
+#define RK3562_SDMMC1_CON0		0x62c
+#define RK3562_SDMMC1_CON1		0x630
+
 #define RK3568_PLL_CON(x)		RK2928_PLL_CON(x)
 #define RK3568_MODE_CON0		0xc0
 #define RK3568_MISC_CON0		0xc4
@@ -402,7 +469,13 @@ struct rockchip_pll_clock {
 	struct rockchip_pll_rate_table *rate_table;
 };
 
+/*
+ * PLL flags
+ */
 #define ROCKCHIP_PLL_SYNC_RATE		BIT(0)
+/* normal mode only. now only for pll_rk3036, pll_rk3328 type */
+#define ROCKCHIP_PLL_FIXED_MODE		BIT(1)
+#define ROCKCHIP_PLL_ALLOW_POWER_DOWN	BIT(2)
 
 #define PLL(_type, _id, _name, _pnames, _flags, _con, _mode, _mshift,	\
 		_lshift, _pflags, _rtable)				\
@@ -1120,4 +1193,20 @@ static inline void rockchip_register_sof
 #endif
 extern void (*rk_dump_cru)(void);
 
+#if IS_MODULE(CONFIG_COMMON_CLK_ROCKCHIP)
+int rockchip_clk_protect(struct rockchip_clk_provider *ctx,
+			 unsigned int *clocks, unsigned int nclocks);
+void rockchip_clk_unprotect(void);
+#else
+static inline int rockchip_clk_protect(struct rockchip_clk_provider *ctx,
+				       unsigned int *clocks,
+				       unsigned int nclocks)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void rockchip_clk_unprotect(void)
+{
+}
+#endif
 #endif
--- a/drivers/cpufreq/cpufreq-dt-platdev.c
+++ b/drivers/cpufreq/cpufreq-dt-platdev.c
@@ -143,6 +143,8 @@ static const struct of_device_id blackli
 	{ .compatible = "rockchip,rk3368", },
 	{ .compatible = "rockchip,rk3399", },
 	{ .compatible = "rockchip,rk3399pro", },
+	{ .compatible = "rockchip,rk3528", },
+	{ .compatible = "rockchip,rk3562", },
 	{ .compatible = "rockchip,rk3566", },
 	{ .compatible = "rockchip,rk3568", },
 	{ .compatible = "rockchip,rk3588", },
--- a/drivers/devfreq/event/rockchip-dfi.c
+++ b/drivers/devfreq/event/rockchip-dfi.c
@@ -745,6 +745,9 @@ static const struct of_device_id rockchi
 #ifdef CONFIG_CPU_RK3399
 	{ .compatible = "rockchip,rk3399-dfi", .data = rockchip_dfi_init },
 #endif
+#ifdef CONFIG_CPU_RK3562
+	{ .compatible = "rockchip,rk3562-dfi", .data = px30_dfi_init },
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{ .compatible = "rockchip,rk3568-dfi", .data = px30_dfi_init },
 #endif
--- a/drivers/dma-buf/Kconfig
+++ b/drivers/dma-buf/Kconfig
@@ -24,6 +24,17 @@ config DMABUF_DEBUG_ADVANCED
 	  This option support to debug all the dmabuf on db_list, allows to attach
 	  and map a dmabuf who has no attachment. If not sure, say N
 
+config DMABUF_PARTIAL
+	bool "Support for partial cache maintenance"
+	default y
+	help
+	  In order to improve performance, allow dma-buf clients to
+	  apply cache maintenance to only a subset of a dma-buf.
+
+	  Kernel clients will be able to use the dma_buf_begin_cpu_access_partial
+	  and dma_buf_end_cpu_access_partial functions to only apply cache
+	  maintenance to a range within the dma-buf.
+
 config SYNC_FILE
 	bool "Explicit Synchronization Framework"
 	default n
@@ -96,7 +107,7 @@ menuconfig DMABUF_HEAPS
 
 menuconfig DMABUF_SYSFS_STATS
 	bool "DMA-BUF sysfs statistics"
-	select DMA_SHARED_BUFFER
+	depends on DMA_SHARED_BUFFER
 	help
 	   Choose this option to enable DMA-BUF sysfs statistics
 	   in location /sys/kernel/dmabuf/buffers.
--- a/drivers/dma-buf/dma-buf.c
+++ b/drivers/dma-buf/dma-buf.c
@@ -119,7 +119,7 @@ static char *dmabuffs_dname(struct dentr
 static void dma_buf_release(struct dentry *dentry)
 {
 	struct dma_buf *dmabuf;
-#ifdef CONFIG_NO_GKI
+#ifdef CONFIG_DMABUF_CACHE
 	int dtor_ret = 0;
 #endif
 
@@ -140,7 +140,7 @@ static void dma_buf_release(struct dentr
 	BUG_ON(dmabuf->cb_shared.active || dmabuf->cb_excl.active);
 
 	dma_buf_stats_teardown(dmabuf);
-#ifdef CONFIG_NO_GKI
+#ifdef CONFIG_DMABUF_CACHE
 	if (dmabuf->dtor)
 		dtor_ret = dmabuf->dtor(dmabuf, dmabuf->dtor_data);
 
@@ -575,6 +575,7 @@ EXPORT_SYMBOL_GPL(is_dma_buf_file);
 
 static struct file *dma_buf_getfile(struct dma_buf *dmabuf, int flags)
 {
+	static atomic64_t dmabuf_inode = ATOMIC64_INIT(0);
 	struct file *file;
 	struct inode *inode = alloc_anon_inode(dma_buf_mnt->mnt_sb);
 
@@ -584,6 +585,13 @@ static struct file *dma_buf_getfile(stru
 	inode->i_size = dmabuf->size;
 	inode_set_bytes(inode, dmabuf->size);
 
+	/*
+	 * The ->i_ino acquired from get_next_ino() is not unique thus
+	 * not suitable for using it as dentry name by dmabuf stats.
+	 * Override ->i_ino with the unique and dmabuffs specific
+	 * value.
+	 */
+	inode->i_ino = atomic64_add_return(1, &dmabuf_inode);
 	file = alloc_file_pseudo(inode, dma_buf_mnt, "dmabuf",
 				 flags, &dma_buf_fops);
 	if (IS_ERR(file))
@@ -702,6 +710,9 @@ struct dma_buf *dma_buf_export(const str
 	dmabuf->exp_name = exp_info->exp_name;
 	dmabuf->owner = exp_info->owner;
 	spin_lock_init(&dmabuf->name_lock);
+#ifdef CONFIG_DMABUF_CACHE
+	mutex_init(&dmabuf->cache_lock);
+#endif
 	init_waitqueue_head(&dmabuf->poll);
 	dmabuf->cb_excl.poll = dmabuf->cb_shared.poll = &dmabuf->poll;
 	dmabuf->cb_excl.active = dmabuf->cb_shared.active = 0;
--- a/drivers/dma-buf/dma-heap.c
+++ b/drivers/dma-buf/dma-heap.c
@@ -314,7 +314,7 @@ EXPORT_SYMBOL_GPL(dma_heap_get_name);
 
 struct dma_heap *dma_heap_add(const struct dma_heap_export_info *exp_info)
 {
-	struct dma_heap *heap, *err_ret;
+	struct dma_heap *heap, *h, *err_ret;
 	unsigned int minor;
 	int ret;
 
@@ -328,15 +328,6 @@ struct dma_heap *dma_heap_add(const stru
 		return ERR_PTR(-EINVAL);
 	}
 
-	/* check the name is unique */
-	heap = dma_heap_find(exp_info->name);
-	if (heap) {
-		pr_err("dma_heap: Already registered heap named %s\n",
-		       exp_info->name);
-		dma_heap_put(heap);
-		return ERR_PTR(-EINVAL);
-	}
-
 	heap = kzalloc(sizeof(*heap), GFP_KERNEL);
 	if (!heap)
 		return ERR_PTR(-ENOMEM);
@@ -380,13 +371,27 @@ struct dma_heap *dma_heap_add(const stru
 	/* Make sure it doesn't disappear on us */
 	heap->heap_dev = get_device(heap->heap_dev);
 
-	/* Add heap to the list */
 	mutex_lock(&heap_list_lock);
+	/* check the name is unique */
+	list_for_each_entry(h, &heap_list, list) {
+		if (!strcmp(h->name, exp_info->name)) {
+			mutex_unlock(&heap_list_lock);
+			pr_err("dma_heap: Already registered heap named %s\n",
+			       exp_info->name);
+			err_ret = ERR_PTR(-EINVAL);
+			put_device(heap->heap_dev);
+			goto err3;
+		}
+	}
+
+	/* Add heap to the list */
 	list_add(&heap->list, &heap_list);
 	mutex_unlock(&heap_list_lock);
 
 	return heap;
 
+err3:
+	device_destroy(dma_heap_class, heap->heap_devt);
 err2:
 	cdev_del(&heap->heap_cdev);
 err1:
--- a/drivers/dma-buf/udmabuf.c
+++ b/drivers/dma-buf/udmabuf.c
@@ -26,8 +26,11 @@ static vm_fault_t udmabuf_vm_fault(struc
 {
 	struct vm_area_struct *vma = vmf->vma;
 	struct udmabuf *ubuf = vma->vm_private_data;
+	pgoff_t pgoff = vmf->pgoff;
 
-	vmf->page = ubuf->pages[vmf->pgoff];
+	if (pgoff >= ubuf->pagecount)
+		return VM_FAULT_SIGBUS;
+	vmf->page = ubuf->pages[pgoff];
 	get_page(vmf->page);
 	return 0;
 }
@@ -115,17 +118,20 @@ static int begin_cpu_udmabuf(struct dma_
 {
 	struct udmabuf *ubuf = buf->priv;
 	struct device *dev = ubuf->device->this_device;
+	int ret = 0;
 
 	if (!ubuf->sg) {
 		ubuf->sg = get_sg_table(dev, buf, direction);
-		if (IS_ERR(ubuf->sg))
-			return PTR_ERR(ubuf->sg);
+		if (IS_ERR(ubuf->sg)) {
+			ret = PTR_ERR(ubuf->sg);
+			ubuf->sg = NULL;
+		}
 	} else {
 		dma_sync_sg_for_cpu(dev, ubuf->sg->sgl, ubuf->sg->nents,
 				    direction);
 	}
 
-	return 0;
+	return ret;
 }
 
 static int end_cpu_udmabuf(struct dma_buf *buf,
@@ -324,7 +330,23 @@ static struct miscdevice udmabuf_misc =
 
 static int __init udmabuf_dev_init(void)
 {
-	return misc_register(&udmabuf_misc);
+	int ret;
+
+	ret = misc_register(&udmabuf_misc);
+	if (ret < 0) {
+		pr_err("Could not initialize udmabuf device\n");
+		return ret;
+	}
+
+	ret = dma_coerce_mask_and_coherent(udmabuf_misc.this_device,
+					   DMA_BIT_MASK(64));
+	if (ret < 0) {
+		pr_err("Could not setup DMA mask for udmabuf device\n");
+		misc_deregister(&udmabuf_misc);
+		return ret;
+	}
+
+	return 0;
 }
 
 static void __exit udmabuf_dev_exit(void)
--- a/drivers/iio/adc/rockchip_saradc.c
+++ b/drivers/iio/adc/rockchip_saradc.c
@@ -73,6 +73,7 @@ struct rockchip_saradc {
 	const struct rockchip_saradc_data *data;
 	u16			last_val;
 	const struct iio_chan_spec *last_chan;
+	struct notifier_block nb;
 	bool			suspended;
 #ifdef CONFIG_ROCKCHIP_SARADC_TEST_CHN
 	bool			test;
@@ -312,6 +313,40 @@ static const struct rockchip_saradc_data
 	.power_down = rockchip_saradc_power_down_v1,
 };
 
+static const struct iio_chan_spec rockchip_rk3528_saradc_iio_channels[] = {
+	SARADC_CHANNEL(0, "adc0", 10),
+	SARADC_CHANNEL(1, "adc1", 10),
+	SARADC_CHANNEL(2, "adc2", 10),
+	SARADC_CHANNEL(3, "adc3", 10),
+};
+
+static const struct rockchip_saradc_data rk3528_saradc_data = {
+	.channels = rockchip_rk3528_saradc_iio_channels,
+	.num_channels = ARRAY_SIZE(rockchip_rk3528_saradc_iio_channels),
+	.clk_rate = 1000000,
+	.start = rockchip_saradc_start_v2,
+	.read = rockchip_saradc_read_v2,
+};
+
+static const struct iio_chan_spec rockchip_rk3562_saradc_iio_channels[] = {
+	SARADC_CHANNEL(0, "adc0", 10),
+	SARADC_CHANNEL(1, "adc1", 10),
+	SARADC_CHANNEL(2, "adc2", 10),
+	SARADC_CHANNEL(3, "adc3", 10),
+	SARADC_CHANNEL(4, "adc4", 10),
+	SARADC_CHANNEL(5, "adc5", 10),
+	SARADC_CHANNEL(6, "adc6", 10),
+	SARADC_CHANNEL(7, "adc7", 10),
+};
+
+static const struct rockchip_saradc_data rk3562_saradc_data = {
+	.channels = rockchip_rk3562_saradc_iio_channels,
+	.num_channels = ARRAY_SIZE(rockchip_rk3562_saradc_iio_channels),
+	.clk_rate = 1000000,
+	.start = rockchip_saradc_start_v2,
+	.read = rockchip_saradc_read_v2,
+};
+
 static const struct iio_chan_spec rockchip_rk3568_saradc_iio_channels[] = {
 	SARADC_CHANNEL(0, "adc0", 10),
 	SARADC_CHANNEL(1, "adc1", 10),
@@ -375,6 +410,12 @@ static const struct of_device_id rockchi
 		.compatible = "rockchip,rk3399-saradc",
 		.data = &rk3399_saradc_data,
 	}, {
+		.compatible = "rockchip,rk3528-saradc",
+		.data = &rk3528_saradc_data,
+	}, {
+		.compatible = "rockchip,rk3562-saradc",
+		.data = &rk3562_saradc_data,
+	}, {
 		.compatible = "rockchip,rk3568-saradc",
 		.data = &rk3568_saradc_data,
 	}, {
@@ -459,6 +500,26 @@ out:
 	return IRQ_HANDLED;
 }
 
+static int rockchip_saradc_volt_notify(struct notifier_block *nb,
+						   unsigned long event,
+						   void *data)
+{
+	struct rockchip_saradc *info =
+			container_of(nb, struct rockchip_saradc, nb);
+
+	if (event & REGULATOR_EVENT_VOLTAGE_CHANGE)
+		info->uv_vref = (unsigned long)data;
+
+	return NOTIFY_OK;
+}
+
+static void rockchip_saradc_regulator_unreg_notifier(void *data)
+{
+	struct rockchip_saradc *info = data;
+
+	regulator_unregister_notifier(info->vref, &info->nb);
+}
+
 #ifdef CONFIG_ROCKCHIP_SARADC_TEST_CHN
 static ssize_t saradc_test_chn_store(struct device *dev,
 			struct device_attribute *attr,
@@ -483,7 +544,7 @@ static ssize_t saradc_test_chn_store(str
 		return size;
 	}
 
-	if (!info->test && val < SARADC_CTRL_CHN_MASK) {
+	if (!info->test && val <= SARADC_CTRL_CHN_MASK) {
 		info->test = true;
 		info->chn = val;
 		mod_delayed_work(info->wq, &info->work, msecs_to_jiffies(100));
@@ -640,13 +701,14 @@ static int rockchip_saradc_probe(struct
 		return ret;
 	}
 
-	info->uv_vref = regulator_get_voltage(info->vref);
-	if (info->uv_vref < 0) {
+	ret = regulator_get_voltage(info->vref);
+	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to get voltage\n");
-		ret = info->uv_vref;
 		return ret;
 	}
 
+	info->uv_vref = ret;
+
 	ret = clk_prepare_enable(info->pclk);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "failed to enable pclk\n");
@@ -687,6 +749,17 @@ static int rockchip_saradc_probe(struct
 	if (ret)
 		return ret;
 
+	info->nb.notifier_call = rockchip_saradc_volt_notify;
+	ret = regulator_register_notifier(info->vref, &info->nb);
+	if (ret)
+		return ret;
+
+	ret = devm_add_action_or_reset(&pdev->dev,
+				       rockchip_saradc_regulator_unreg_notifier,
+				       info);
+	if (ret)
+		return ret;
+
 #ifdef CONFIG_ROCKCHIP_SARADC_TEST_CHN
 	info->wq = create_singlethread_workqueue("adc_wq");
 	INIT_DELAYED_WORK(&info->work, rockchip_saradc_test_work);
--- a/drivers/input/misc/rk805-pwrkey.c
+++ b/drivers/input/misc/rk805-pwrkey.c
@@ -13,6 +13,7 @@
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#include <linux/of.h>
 #include <linux/platform_device.h>
 
 static irqreturn_t pwrkey_fall_irq(int irq, void *_pwr)
@@ -39,8 +40,15 @@ static int rk805_pwrkey_probe(struct pla
 {
 	struct input_dev *pwr;
 	int fall_irq, rise_irq;
+	struct device_node *np;
 	int err;
 
+	np = of_get_child_by_name(pdev->dev.parent->of_node, "pwrkey");
+	if (np && !of_device_is_available(np)) {
+		dev_info(&pdev->dev, "device is disabled\n");
+		return -EINVAL;
+	}
+
 	pwr = devm_input_allocate_device(&pdev->dev);
 	if (!pwr) {
 		dev_err(&pdev->dev, "Can't allocate power button\n");
--- a/drivers/iommu/Kconfig
+++ b/drivers/iommu/Kconfig
@@ -11,6 +11,36 @@ config IOASID
 config IOMMU_API
 	bool
 
+if IOMMU_IOVA
+
+config IOMMU_LIMIT_IOVA_ALIGNMENT
+	bool "Limit IOVA alignment"
+	help
+	  When the IOVA framework applies IOVA alignment it aligns all
+	  IOVAs to the smallest PAGE_SIZE order which is greater than or
+	  equal to the requested IOVA size. This works fine for sizes up
+	  to several MiB, but for larger sizes it results in address
+	  space wastage and fragmentation. For example drivers with a 4
+	  GiB IOVA space might run out of IOVA space when allocating
+	  buffers great than 64 MiB.
+
+	  Enable this option to impose a limit on the alignment of IOVAs.
+
+	  If unsure, say N.
+
+config IOMMU_IOVA_ALIGNMENT
+	int "Maximum PAGE_SIZE order of alignment for IOVAs"
+	depends on IOMMU_LIMIT_IOVA_ALIGNMENT
+	range 4 9
+	default 9
+	help
+	  With this parameter you can specify the maximum PAGE_SIZE order for
+	  IOVAs. Larger IOVAs will be aligned only to this specified order.
+	  The order is expressed a power of two multiplied by the PAGE_SIZE.
+
+	  If unsure, leave the default value "9".
+endif
+
 menuconfig IOMMU_SUPPORT
 	bool "IOMMU Hardware Support"
 	depends on MMU
--- a/drivers/iommu/dma-iommu.c
+++ b/drivers/iommu/dma-iommu.c
@@ -49,6 +49,11 @@ struct iommu_dma_cookie {
 	struct iommu_domain		*fq_domain;
 };
 
+struct iommu_dma_cookie_ext {
+	struct iommu_dma_cookie		cookie;
+	struct mutex			mutex;
+};
+
 static inline size_t cookie_msi_granule(struct iommu_dma_cookie *cookie)
 {
 	if (cookie->type == IOMMU_DMA_IOVA_COOKIE)
@@ -58,14 +63,15 @@ static inline size_t cookie_msi_granule(
 
 static struct iommu_dma_cookie *cookie_alloc(enum iommu_dma_cookie_type type)
 {
-	struct iommu_dma_cookie *cookie;
+	struct iommu_dma_cookie_ext *cookie;
 
 	cookie = kzalloc(sizeof(*cookie), GFP_KERNEL);
 	if (cookie) {
-		INIT_LIST_HEAD(&cookie->msi_page_list);
-		cookie->type = type;
+		INIT_LIST_HEAD(&cookie->cookie.msi_page_list);
+		cookie->cookie.type = type;
+		mutex_init(&cookie->mutex);
 	}
-	return cookie;
+	return &cookie->cookie;
 }
 
 /**
@@ -304,9 +310,11 @@ static int iommu_dma_init_domain(struct
 		u64 size, struct device *dev)
 {
 	struct iommu_dma_cookie *cookie = domain->iova_cookie;
+	struct iommu_dma_cookie_ext *cookie_ext;
 	unsigned long order, base_pfn;
 	struct iova_domain *iovad;
 	int attr;
+	int ret;
 
 	if (!cookie || cookie->type != IOMMU_DMA_IOVA_COOKIE)
 		return -EINVAL;
@@ -330,14 +338,18 @@ static int iommu_dma_init_domain(struct
 	}
 
 	/* start_pfn is always nonzero for an already-initialised domain */
+	cookie_ext = container_of(cookie, struct iommu_dma_cookie_ext, cookie);
+	mutex_lock(&cookie_ext->mutex);
 	if (iovad->start_pfn) {
 		if (1UL << order != iovad->granule ||
 		    base_pfn != iovad->start_pfn) {
 			pr_warn("Incompatible range for DMA domain\n");
-			return -EFAULT;
+			ret = -EFAULT;
+			goto done_unlock;
 		}
 
-		return 0;
+		ret = 0;
+		goto done_unlock;
 	}
 
 	init_iova_domain(iovad, 1UL << order, base_pfn);
@@ -351,10 +363,16 @@ static int iommu_dma_init_domain(struct
 			cookie->fq_domain = domain;
 	}
 
-	if (!dev)
-		return 0;
+	if (!dev) {
+		ret = 0;
+		goto done_unlock;
+	}
+
+	ret = iova_reserve_iommu_regions(dev, domain);
 
-	return iova_reserve_iommu_regions(dev, domain);
+done_unlock:
+	mutex_unlock(&cookie_ext->mutex);
+	return ret;
 }
 
 static int iommu_dma_deferred_attach(struct device *dev,
@@ -1242,13 +1260,6 @@ void iommu_setup_dma_ops(struct device *
 		dev->dma_ops = &iommu_dma_ops;
 	}
 
-	if (domain->type == IOMMU_DOMAIN_DMA) {
-		struct iommu_dma_cookie *cookie = domain->iova_cookie;
-		struct iova_domain *iovad = &cookie->iovad;
-
-		init_iova_domain_procfs(iovad, dev_name(dev));
-	}
-
 	return;
 out_err:
 	 pr_warn("Failed to set up IOMMU for device %s; retaining platform DMA ops\n",
--- a/drivers/iommu/iova.c
+++ b/drivers/iommu/iova.c
@@ -11,8 +11,6 @@
 #include <linux/smp.h>
 #include <linux/bitops.h>
 #include <linux/cpu.h>
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
 
 /* The anchor node sits above the top of the usable address space */
 #define IOVA_ANCHOR	~0UL
@@ -27,66 +25,6 @@ static void init_iova_rcaches(struct iov
 static void free_iova_rcaches(struct iova_domain *iovad);
 static void fq_destroy_all_entries(struct iova_domain *iovad);
 static void fq_flush_timeout(struct timer_list *t);
-static void iova_dump(struct iova_domain *iovad);
-
-static int iova_used_show(struct seq_file *s, void *v)
-{
-	struct iova_domain *iovad = s->private;
-	struct iova *iova, *t;
-	unsigned long flags;
-	unsigned long used_pfn = 0;
-	unsigned int cpu;
-	int i = 0;
-
-	for_each_online_cpu(cpu)
-		free_cpu_cached_iovas(cpu, iovad);
-	free_global_cached_iovas(iovad);
-
-	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
-	rbtree_postorder_for_each_entry_safe(iova, t, &iovad->rbroot, node) {
-		dma_addr_t start = iova->pfn_lo << iova_shift(iovad);
-		dma_addr_t end = iova->pfn_hi << iova_shift(iovad);
-		unsigned long pfn = iova->pfn_hi + 1 - iova->pfn_lo;
-
-		if ((iova->pfn_hi == IOVA_ANCHOR) || (iova->pfn_lo == IOVA_ANCHOR))
-			continue;
-
-		seq_printf(s, "%4d: [%pad..%pad] %6luKiB (%4lu - %4lu)MiB\n",
-			   i++, &start, &end,
-			   pfn << (PAGE_SHIFT - 10),
-			   iova->pfn_lo >> (20 - PAGE_SHIFT),
-			   (iova->pfn_hi + 1) >> (20 - PAGE_SHIFT));
-		used_pfn += pfn;
-	}
-	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
-	seq_printf(s, "used: %lu MiB\n", used_pfn >> (20 - PAGE_SHIFT));
-
-	return 0;
-}
-
-static struct proc_dir_entry *iova_dir;
-
-void init_iova_domain_procfs(struct iova_domain *iovad, const char *name)
-{
-	struct proc_dir_entry *root;
-
-	remove_proc_subtree(name, iova_dir);
-	root = proc_mkdir(name, iova_dir);
-	if (!root)
-		return;
-
-	proc_create_single_data("used", 0, root, iova_used_show, iovad);
-}
-EXPORT_SYMBOL_GPL(init_iova_domain_procfs);
-
-static int __init iova_procfs_create(void)
-{
-	if (!iova_dir)
-		iova_dir = proc_mkdir("iova", NULL);
-
-	return 0;
-}
-subsys_initcall(iova_procfs_create);
 
 void
 init_iova_domain(struct iova_domain *iovad, unsigned long granule,
@@ -280,7 +218,7 @@ static int __alloc_and_insert_iova_range
 
 	curr = __get_cached_rbnode(iovad, limit_pfn);
 	curr_iova = rb_entry(curr, struct iova, node);
-	low_pfn_new = curr_iova->pfn_hi + 1;
+	low_pfn_new = curr_iova->pfn_hi;
 
 retry:
 	do {
@@ -294,7 +232,7 @@ retry:
 	if (high_pfn < size || new_pfn < low_pfn) {
 		if (low_pfn == iovad->start_pfn && low_pfn_new < limit_pfn) {
 			high_pfn = limit_pfn;
-			low_pfn = low_pfn_new;
+			low_pfn = low_pfn_new + 1;
 			curr = &iovad->anchor.node;
 			curr_iova = rb_entry(curr, struct iova, node);
 			goto retry;
@@ -585,10 +523,8 @@ retry:
 	if (!new_iova) {
 		unsigned int cpu;
 
-		if (!flush_rcache) {
-			iova_dump(iovad);
+		if (!flush_rcache)
 			return 0;
-		}
 
 		/* Try replenishing IOVAs by flushing rcache. */
 		flush_rcache = false;
@@ -951,32 +887,6 @@ struct iova_cpu_rcache {
 	struct iova_magazine *prev;
 };
 
-static void iova_dump(struct iova_domain *iovad)
-{
-	struct iova *iova, *t;
-	unsigned long flags;
-	unsigned long used_pfn = 0;
-	int i = 0;
-
-	spin_lock_irqsave(&iovad->iova_rbtree_lock, flags);
-	rbtree_postorder_for_each_entry_safe(iova, t, &iovad->rbroot, node) {
-		dma_addr_t start = iova->pfn_lo << iova_shift(iovad);
-		dma_addr_t end = iova->pfn_hi << iova_shift(iovad);
-		unsigned long pfn = iova->pfn_hi + 1 - iova->pfn_lo;
-
-		if (iova->pfn_lo == IOVA_ANCHOR)
-			continue;
-
-		pr_info("%4d: [%pad..%pad] (%4lu - %4lu)MiB\n",
-			i++, &start, &end,
-			iova->pfn_lo >> (20 - PAGE_SHIFT),
-			iova->pfn_hi >> (20 - PAGE_SHIFT));
-		used_pfn += pfn;
-	}
-	spin_unlock_irqrestore(&iovad->iova_rbtree_lock, flags);
-	pr_info("used: %lu MiB\n", used_pfn >> (20 - PAGE_SHIFT));
-}
-
 static struct iova_magazine *iova_magazine_alloc(gfp_t flags)
 {
 	return kzalloc(sizeof(struct iova_magazine), flags);
--- a/drivers/iommu/rockchip-iommu.c
+++ b/drivers/iommu/rockchip-iommu.c
@@ -87,30 +87,6 @@
   */
 #define RK_IOMMU_PGSIZE_BITMAP 0x007ff000
 
-#define DT_LO_MASK 0xfffff000
-#define DT_HI_MASK GENMASK_ULL(39, 32)
-#define DT_SHIFT   28
-
-#define DTE_BASE_HI_MASK GENMASK(11, 4)
-
-#define PAGE_DESC_LO_MASK   0xfffff000
-#define PAGE_DESC_HI1_LOWER 32
-#define PAGE_DESC_HI1_UPPER 35
-#define PAGE_DESC_HI2_LOWER 36
-#define PAGE_DESC_HI2_UPPER 39
-#define PAGE_DESC_HI_MASK1  GENMASK_ULL(PAGE_DESC_HI1_UPPER, PAGE_DESC_HI1_LOWER)
-#define PAGE_DESC_HI_MASK2  GENMASK_ULL(PAGE_DESC_HI2_UPPER, PAGE_DESC_HI2_LOWER)
-
-#define DTE_HI1_LOWER 8
-#define DTE_HI1_UPPER 11
-#define DTE_HI2_LOWER 4
-#define DTE_HI2_UPPER 7
-#define DTE_HI_MASK1  GENMASK(DTE_HI1_UPPER, DTE_HI1_LOWER)
-#define DTE_HI_MASK2  GENMASK(DTE_HI2_UPPER, DTE_HI2_LOWER)
-
-#define PAGE_DESC_HI_SHIFT1 (PAGE_DESC_HI1_LOWER - DTE_HI1_LOWER)
-#define PAGE_DESC_HI_SHIFT2 (PAGE_DESC_HI2_LOWER - DTE_HI2_LOWER)
-
 struct rk_iommu_domain {
 	struct list_head iommus;
 	u32 *dt; /* page directory table */
@@ -122,8 +98,13 @@ struct rk_iommu_domain {
 	struct iommu_domain domain;
 };
 
-struct rockchip_iommu_data {
-	u32 version;
+struct rk_iommu_ops {
+	phys_addr_t (*pt_address)(u32 dte);
+	u32 (*mk_dtentries)(dma_addr_t pt_dma);
+	u32 (*mk_ptentries)(phys_addr_t page, int prot);
+	phys_addr_t (*dte_addr_phys)(u32 addr);
+	u32 (*dma_addr_dte)(dma_addr_t dt_dma);
+	u64 dma_bit_mask;
 };
 
 struct rk_iommu {
@@ -142,7 +123,6 @@ struct rk_iommu {
 	struct list_head node; /* entry in rk_iommu_domain.iommus */
 	struct iommu_domain *domain; /* domain to which iommu is attached */
 	struct iommu_group *group;
-	u32 version;
 	bool shootdown_entire;
 	bool iommu_enabled;
 	bool need_res_map;
@@ -155,6 +135,7 @@ struct rk_iommudata {
 };
 
 static struct device *dma_dev;
+static const struct rk_iommu_ops *rk_ops;
 static struct rk_iommu *rk_iommu_from_dev(struct device *dev);
 static char reserve_range[PAGE_SIZE] __aligned(PAGE_SIZE);
 static phys_addr_t res_page;
@@ -216,6 +197,11 @@ static struct rk_iommu_domain *to_rk_dom
 #define RK_DTE_PT_ADDRESS_MASK    0xfffff000
 #define RK_DTE_PT_VALID           BIT(0)
 
+static inline phys_addr_t rk_dte_pt_address(u32 dte)
+{
+	return (phys_addr_t)dte & RK_DTE_PT_ADDRESS_MASK;
+}
+
 /*
  * In v2:
  * 31:12 - PT address bit 31:0
@@ -224,20 +210,21 @@ static struct rk_iommu_domain *to_rk_dom
  *  3: 1 - Reserved
  *     0 - 1 if PT @ PT address is valid
  */
-#define RK_DTE_PT_ADDRESS_MASK_V2 0xfffffff0
-
-static inline phys_addr_t rk_dte_pt_address(u32 dte)
-{
-	return (phys_addr_t)dte & RK_DTE_PT_ADDRESS_MASK;
-}
+#define RK_DTE_PT_ADDRESS_MASK_V2 GENMASK_ULL(31, 4)
+#define DTE_HI_MASK1	GENMASK(11, 8)
+#define DTE_HI_MASK2	GENMASK(7, 4)
+#define DTE_HI_SHIFT1	24 /* shift bit 8 to bit 32 */
+#define DTE_HI_SHIFT2	32 /* shift bit 4 to bit 36 */
+#define PAGE_DESC_HI_MASK1	GENMASK_ULL(35, 32)
+#define PAGE_DESC_HI_MASK2	GENMASK_ULL(39, 36)
 
 static inline phys_addr_t rk_dte_pt_address_v2(u32 dte)
 {
 	u64 dte_v2 = dte;
 
-	dte_v2 = ((dte_v2 & DTE_HI_MASK2) << PAGE_DESC_HI_SHIFT2) |
-		 ((dte_v2 & DTE_HI_MASK1) << PAGE_DESC_HI_SHIFT1) |
-		 (dte_v2 & PAGE_DESC_LO_MASK);
+	dte_v2 = ((dte_v2 & DTE_HI_MASK2) << DTE_HI_SHIFT2) |
+		 ((dte_v2 & DTE_HI_MASK1) << DTE_HI_SHIFT1) |
+		 (dte_v2 & RK_DTE_PT_ADDRESS_MASK);
 
 	return (phys_addr_t)dte_v2;
 }
@@ -254,9 +241,9 @@ static inline u32 rk_mk_dte(dma_addr_t p
 
 static inline u32 rk_mk_dte_v2(dma_addr_t pt_dma)
 {
-	pt_dma = (pt_dma & PAGE_DESC_LO_MASK) |
-		 ((pt_dma & PAGE_DESC_HI_MASK1) >> PAGE_DESC_HI_SHIFT1) |
-		 (pt_dma & PAGE_DESC_HI_MASK2) >> PAGE_DESC_HI_SHIFT2;
+	pt_dma = (pt_dma & RK_DTE_PT_ADDRESS_MASK) |
+		 ((pt_dma & PAGE_DESC_HI_MASK1) >> DTE_HI_SHIFT1) |
+		 (pt_dma & PAGE_DESC_HI_MASK2) >> DTE_HI_SHIFT2;
 
 	return (pt_dma & RK_DTE_PT_ADDRESS_MASK_V2) | RK_DTE_PT_VALID;
 }
@@ -287,44 +274,13 @@ static inline u32 rk_mk_dte_v2(dma_addr_
 #define RK_PTE_PAGE_READABLE      BIT(1)
 #define RK_PTE_PAGE_VALID         BIT(0)
 
-/*
- * In v2:
- * 31:12 - Page address bit 31:0
- *  11:9 - Page address bit 34:32
- *   8:4 - Page address bit 39:35
- *     3 - Security
- *     2 - Writable
- *     1 - Readable
- *     0 - 1 if Page @ Page address is valid
- */
-#define RK_PTE_PAGE_ADDRESS_MASK_V2  0xfffffff0
-#define RK_PTE_PAGE_FLAGS_MASK_V2    0x0000000e
-#define RK_PTE_PAGE_READABLE_V2      BIT(1)
-#define RK_PTE_PAGE_WRITABLE_V2      BIT(2)
-
-#define RK_PTE_PAGE_REPRESENT	BIT(3)
-
-static inline phys_addr_t rk_pte_page_address(u32 pte)
-{
-	return (phys_addr_t)pte & RK_PTE_PAGE_ADDRESS_MASK;
-}
-
-static inline phys_addr_t rk_pte_page_address_v2(u32 pte)
-{
-	u64 pte_v2 = pte;
-
-	pte_v2 = ((pte_v2 & DTE_HI_MASK2) << PAGE_DESC_HI_SHIFT2) |
-		 ((pte_v2 & DTE_HI_MASK1) << PAGE_DESC_HI_SHIFT1) |
-		 (pte_v2 & PAGE_DESC_LO_MASK);
-
-	return (phys_addr_t)pte_v2;
-}
-
 static inline bool rk_pte_is_page_valid(u32 pte)
 {
 	return pte & RK_PTE_PAGE_VALID;
 }
 
+#define RK_PTE_PAGE_REPRESENT	BIT(3)
+
 static inline bool rk_pte_is_page_represent(u32 pte)
 {
 	return pte & RK_PTE_PAGE_REPRESENT;
@@ -337,7 +293,6 @@ static u32 rk_mk_pte(phys_addr_t page, i
 	flags |= (prot & IOMMU_READ) ? RK_PTE_PAGE_READABLE : 0;
 	flags |= (prot & IOMMU_WRITE) ? RK_PTE_PAGE_WRITABLE : 0;
 	flags |= (prot & IOMMU_PRIV) ? RK_PTE_PAGE_REPRESENT : 0;
-
 	page &= RK_PTE_PAGE_ADDRESS_MASK;
 	return page | flags | RK_PTE_PAGE_VALID;
 }
@@ -346,20 +301,16 @@ static u32 rk_mk_pte_v2(phys_addr_t page
 {
 	u32 flags = 0;
 
-	flags |= (prot & IOMMU_READ) ? RK_PTE_PAGE_READABLE_V2 : 0;
-	flags |= (prot & IOMMU_WRITE) ? RK_PTE_PAGE_WRITABLE_V2 : 0;
 	/* If BIT(3) set, don't break iommu_map if BIT(0) set.
 	 * Means we can reupdate a page that already presented. We can use
 	 * this bit to reupdate a pre-mapped 4G range.
 	 */
 	flags |= (prot & IOMMU_PRIV) ? RK_PTE_PAGE_REPRESENT : 0;
 
-	page = (page & PAGE_DESC_LO_MASK) |
-	       ((page & PAGE_DESC_HI_MASK1) >> PAGE_DESC_HI_SHIFT1) |
-	       (page & PAGE_DESC_HI_MASK2) >> PAGE_DESC_HI_SHIFT2;
-	page &= RK_PTE_PAGE_ADDRESS_MASK_V2;
+	flags |= (prot & IOMMU_READ) ? RK_PTE_PAGE_READABLE : 0;
+	flags |= (prot & IOMMU_WRITE) ? RK_PTE_PAGE_WRITABLE : 0;
 
-	return page | flags | RK_PTE_PAGE_VALID;
+	return rk_mk_dte_v2(page) | flags;
 }
 
 static u32 rk_mk_pte_invalid(u32 pte)
@@ -615,7 +566,7 @@ static int rk_iommu_force_reset(struct r
 	int ret, i;
 	u32 dte_addr;
 	bool val;
-	u32 address_mask;
+	u32 dte_address_mask;
 
 	if (iommu->reset_disabled)
 		return 0;
@@ -632,14 +583,11 @@ static int rk_iommu_force_reset(struct r
 	 * In v2: upper 7 nybbles are read back.
 	 */
 	for (i = 0; i < iommu->num_mmu; i++) {
-		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR, DTE_ADDR_DUMMY);
+		dte_address_mask = rk_ops->pt_address(DTE_ADDR_DUMMY);
+		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR, dte_address_mask);
 
-		if (iommu->version >= 0x2)
-			address_mask = RK_DTE_PT_ADDRESS_MASK_V2;
-		else
-			address_mask = RK_DTE_PT_ADDRESS_MASK;
 		ret = readx_poll_timeout(rk_iommu_read_dte_addr, iommu->bases[i], dte_addr,
-					 dte_addr == (DTE_ADDR_DUMMY & address_mask),
+					 dte_addr == dte_address_mask,
 					 RK_MMU_POLL_PERIOD_US, RK_MMU_POLL_TIMEOUT_US);
 		if (ret) {
 			dev_err(iommu->dev, "Error during raw reset. MMU_DTE_ADDR is not functioning\n");
@@ -663,6 +611,33 @@ read_wa:
 	return 0;
 }
 
+static inline phys_addr_t rk_dte_addr_phys(u32 addr)
+{
+	return (phys_addr_t)addr;
+}
+
+static inline u32 rk_dma_addr_dte(dma_addr_t dt_dma)
+{
+	return dt_dma;
+}
+
+#define DT_HI_MASK GENMASK_ULL(39, 32)
+#define DTE_BASE_HI_MASK GENMASK(11, 4)
+#define DT_SHIFT   28
+
+static inline phys_addr_t rk_dte_addr_phys_v2(u32 addr)
+{
+	u64 addr64 = addr;
+	return (phys_addr_t)(addr64 & RK_DTE_PT_ADDRESS_MASK) |
+	       ((addr64 & DTE_BASE_HI_MASK) << DT_SHIFT);
+}
+
+static inline u32 rk_dma_addr_dte_v2(dma_addr_t dt_dma)
+{
+	return (dt_dma & RK_DTE_PT_ADDRESS_MASK) |
+	       ((dt_dma & DT_HI_MASK) >> DT_SHIFT);
+}
+
 static void log_iova(struct rk_iommu *iommu, int index, dma_addr_t iova)
 {
 	void __iomem *base = iommu->bases[index];
@@ -682,11 +657,7 @@ static void log_iova(struct rk_iommu *io
 	page_offset = rk_iova_page_offset(iova);
 
 	mmu_dte_addr = rk_iommu_read(base, RK_MMU_DTE_ADDR);
-	mmu_dte_addr_phys = (phys_addr_t)mmu_dte_addr;
-	if (iommu->version >= 0x2) {
-		mmu_dte_addr_phys = (mmu_dte_addr_phys & DT_LO_MASK) |
-				    ((mmu_dte_addr_phys & DTE_BASE_HI_MASK) << DT_SHIFT);
-	}
+	mmu_dte_addr_phys = rk_ops->dte_addr_phys(mmu_dte_addr);
 
 	dte_addr_phys = mmu_dte_addr_phys + (4 * dte_index);
 	dte_addr = phys_to_virt(dte_addr_phys);
@@ -695,20 +666,14 @@ static void log_iova(struct rk_iommu *io
 	if (!rk_dte_is_pt_valid(dte))
 		goto print_it;
 
-	if (iommu->version >= 0x2)
-		pte_addr_phys = rk_dte_pt_address_v2(dte) + (pte_index * 4);
-	else
-		pte_addr_phys = rk_dte_pt_address(dte) + (pte_index * 4);
+	pte_addr_phys = rk_ops->pt_address(dte) + (pte_index * 4);
 	pte_addr = phys_to_virt(pte_addr_phys);
 	pte = *pte_addr;
 
 	if (!rk_pte_is_page_valid(pte))
 		goto print_it;
 
-	if (iommu->version >= 0x2)
-		page_addr_phys = rk_pte_page_address_v2(pte) + page_offset;
-	else
-		page_addr_phys = rk_pte_page_address(pte) + page_offset;
+	page_addr_phys = rk_ops->pt_address(pte) + page_offset;
 	page_flags = pte & RK_PTE_PAGE_FLAGS_MASK;
 
 print_it:
@@ -847,41 +812,13 @@ static phys_addr_t rk_iommu_iova_to_phys
 	if (!rk_dte_is_pt_valid(dte))
 		goto out;
 
-	pt_phys = rk_dte_pt_address(dte);
-	page_table = (u32 *)phys_to_virt(pt_phys);
-	pte = page_table[rk_iova_pte_index(iova)];
-	if (!rk_pte_is_page_valid(pte))
-		goto out;
-
-	phys = rk_pte_page_address(pte) + rk_iova_page_offset(iova);
-out:
-	spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
-
-	return phys;
-}
-
-static phys_addr_t rk_iommu_iova_to_phys_v2(struct iommu_domain *domain,
-					    dma_addr_t iova)
-{
-	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
-	unsigned long flags;
-	phys_addr_t pt_phys, phys = 0;
-	u32 dte, pte;
-	u32 *page_table;
-
-	spin_lock_irqsave(&rk_domain->dt_lock, flags);
-
-	dte = rk_domain->dt[rk_iova_dte_index(iova)];
-	if (!rk_dte_is_pt_valid(dte))
-		goto out;
-
-	pt_phys = rk_dte_pt_address_v2(dte);
+	pt_phys = rk_ops->pt_address(dte);
 	page_table = (u32 *)phys_to_virt(pt_phys);
 	pte = page_table[rk_iova_pte_index(iova)];
 	if (!rk_pte_is_page_valid(pte))
 		goto out;
 
-	phys = rk_pte_page_address_v2(pte) + rk_iova_page_offset(iova);
+	phys = rk_ops->pt_address(pte) + rk_iova_page_offset(iova);
 out:
 	spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
 
@@ -957,52 +894,13 @@ static u32 *rk_dte_get_page_table(struct
 		return ERR_PTR(-ENOMEM);
 	}
 
-	dte = rk_mk_dte(pt_dma);
+	dte = rk_ops->mk_dtentries(pt_dma);
 	*dte_addr = dte;
 
-	rk_table_flush(rk_domain, pt_dma, NUM_PT_ENTRIES);
 	rk_table_flush(rk_domain,
 		       rk_domain->dt_dma + dte_index * sizeof(u32), 1);
 done:
-	pt_phys = rk_dte_pt_address(dte);
-	return (u32 *)phys_to_virt(pt_phys);
-}
-
-static u32 *rk_dte_get_page_table_v2(struct rk_iommu_domain *rk_domain,
-				     dma_addr_t iova)
-{
-	u32 *page_table, *dte_addr;
-	u32 dte_index, dte;
-	phys_addr_t pt_phys;
-	dma_addr_t pt_dma;
-
-	assert_spin_locked(&rk_domain->dt_lock);
-
-	dte_index = rk_iova_dte_index(iova);
-	dte_addr = &rk_domain->dt[dte_index];
-	dte = *dte_addr;
-	if (rk_dte_is_pt_valid(dte))
-		goto done;
-
-	page_table = (u32 *)get_zeroed_page(GFP_ATOMIC | GFP_DMA32);
-	if (!page_table)
-		return ERR_PTR(-ENOMEM);
-
-	pt_dma = dma_map_single(dma_dev, page_table, SPAGE_SIZE, DMA_TO_DEVICE);
-	if (dma_mapping_error(dma_dev, pt_dma)) {
-		dev_err(dma_dev, "DMA mapping error while allocating page table\n");
-		free_page((unsigned long)page_table);
-		return ERR_PTR(-ENOMEM);
-	}
-
-	dte = rk_mk_dte_v2(pt_dma);
-	*dte_addr = dte;
-
-	rk_table_flush(rk_domain, pt_dma, NUM_PT_ENTRIES);
-	rk_table_flush(rk_domain,
-		       rk_domain->dt_dma + dte_index * sizeof(u32), 1);
-done:
-	pt_phys = rk_dte_pt_address_v2(dte);
+	pt_phys = rk_ops->pt_address(dte);
 	return (u32 *)phys_to_virt(pt_phys);
 }
 
@@ -1021,15 +919,11 @@ static size_t rk_iommu_unmap_iova(struct
 		if (!rk_pte_is_page_valid(pte))
 			break;
 
-		if (iommu && iommu->need_res_map) {
-			if (iommu->version >= 0x2)
-				pte_addr[pte_count] = rk_mk_pte_v2(res_page,
+		if (iommu && iommu->need_res_map)
+			pte_addr[pte_count] = rk_ops->mk_ptentries(res_page,
 								   prot);
-			else
-				pte_addr[pte_count] = rk_mk_pte(res_page, prot);
-		} else {
+		else
 			pte_addr[pte_count] = rk_mk_pte_invalid(pte);
-		}
 	}
 
 	rk_table_flush(rk_domain, pte_dma, pte_count);
@@ -1071,57 +965,10 @@ static int rk_iommu_map_iova(struct rk_i
 			goto unwind;
 
 		if (prot & IOMMU_PRIV) {
-			pte_addr[pte_count] = rk_mk_pte(res_page, prot);
+			pte_addr[pte_count] = rk_ops->mk_ptentries(res_page, prot);
 		} else {
-			pte_addr[pte_count] = rk_mk_pte(paddr, prot);
-			paddr += SPAGE_SIZE;
-		}
-	}
-
-	rk_table_flush(rk_domain, pte_dma, pte_total);
+			pte_addr[pte_count] = rk_ops->mk_ptentries(paddr, prot);
 
-	/*
-	 * Zap the first and last iova to evict from iotlb any previously
-	 * mapped cachelines holding stale values for its dte and pte.
-	 * We only zap the first and last iova, since only they could have
-	 * dte or pte shared with an existing mapping.
-	 */
-	rk_iommu_zap_iova_first_last(rk_domain, iova, size);
-
-	return 0;
-unwind:
-	/* Unmap the range of iovas that we just mapped */
-	rk_iommu_unmap_iova(rk_domain, pte_addr, pte_dma,
-			    pte_count * SPAGE_SIZE, NULL);
-
-	iova += pte_count * SPAGE_SIZE;
-	page_phys = rk_pte_page_address(pte_addr[pte_count]);
-	pr_err("iova: %pad already mapped to %pa cannot remap to phys: %pa prot: %#x\n",
-	       &iova, &page_phys, &paddr, prot);
-
-	return -EADDRINUSE;
-}
-
-static int rk_iommu_map_iova_v2(struct rk_iommu_domain *rk_domain, u32 *pte_addr,
-				dma_addr_t pte_dma, dma_addr_t iova,
-				phys_addr_t paddr, size_t size, int prot)
-{
-	unsigned int pte_count;
-	unsigned int pte_total = size / SPAGE_SIZE;
-	phys_addr_t page_phys;
-
-	assert_spin_locked(&rk_domain->dt_lock);
-
-	for (pte_count = 0; pte_count < pte_total; pte_count++) {
-		u32 pte = pte_addr[pte_count];
-
-		if (rk_pte_is_page_valid(pte) && !rk_pte_is_page_represent(pte))
-			goto unwind;
-
-		if (prot & IOMMU_PRIV) {
-			pte_addr[pte_count] = rk_mk_pte_v2(res_page, prot);
-		} else {
-			pte_addr[pte_count] = rk_mk_pte_v2(paddr, prot);
 			paddr += SPAGE_SIZE;
 		}
 	}
@@ -1143,7 +990,7 @@ unwind:
 			    pte_count * SPAGE_SIZE, NULL);
 
 	iova += pte_count * SPAGE_SIZE;
-	page_phys = rk_pte_page_address_v2(pte_addr[pte_count]);
+	page_phys = rk_ops->pt_address(pte_addr[pte_count]);
 	pr_err("iova: %pad already mapped to %pa cannot remap to phys: %pa prot: %#x\n",
 	       &iova, &page_phys, &paddr, prot);
 
@@ -1178,7 +1025,7 @@ static int rk_iommu_map(struct iommu_dom
 	dte = rk_domain->dt[rk_iova_dte_index(iova)];
 	pte_index = rk_iova_pte_index(iova);
 	pte_addr = &page_table[pte_index];
-	pte_dma = rk_dte_pt_address(dte) + pte_index * sizeof(u32);
+	pte_dma = rk_ops->pt_address(dte) + pte_index * sizeof(u32);
 	ret = rk_iommu_map_iova(rk_domain, pte_addr, pte_dma, iova,
 				paddr, size, prot);
 
@@ -1187,43 +1034,6 @@ static int rk_iommu_map(struct iommu_dom
 	return ret;
 }
 
-static int rk_iommu_map_v2(struct iommu_domain *domain, unsigned long _iova,
-			phys_addr_t paddr, size_t size, int prot, gfp_t gfp)
-{
-	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
-	unsigned long flags;
-	dma_addr_t pte_dma, iova = (dma_addr_t)_iova;
-	u32 *page_table, *pte_addr;
-	u32 dte, pte_index;
-	int ret;
-
-	spin_lock_irqsave(&rk_domain->dt_lock, flags);
-
-	/*
-	 * pgsize_bitmap specifies iova sizes that fit in one page table
-	 * (1024 4-KiB pages = 4 MiB).
-	 * So, size will always be 4096 <= size <= 4194304.
-	 * Since iommu_map() guarantees that both iova and size will be
-	 * aligned, we will always only be mapping from a single dte here.
-	 */
-	page_table = rk_dte_get_page_table_v2(rk_domain, iova);
-	if (IS_ERR(page_table)) {
-		spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
-		return PTR_ERR(page_table);
-	}
-
-	dte = rk_domain->dt[rk_iova_dte_index(iova)];
-	pte_index = rk_iova_pte_index(iova);
-	pte_addr = &page_table[pte_index];
-	pte_dma = rk_dte_pt_address_v2(dte) + pte_index * sizeof(u32);
-	ret = rk_iommu_map_iova_v2(rk_domain, pte_addr, pte_dma, iova,
-				   paddr, size, prot);
-
-	spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
-
-	return ret;
-}
-
 static size_t rk_iommu_unmap(struct iommu_domain *domain, unsigned long _iova,
 			     size_t size, struct iommu_iotlb_gather *gather)
 {
@@ -1252,49 +1062,7 @@ static size_t rk_iommu_unmap(struct iomm
 		return 0;
 	}
 
-	pt_phys = rk_dte_pt_address(dte);
-	pte_addr = (u32 *)phys_to_virt(pt_phys) + rk_iova_pte_index(iova);
-	pte_dma = pt_phys + rk_iova_pte_index(iova) * sizeof(u32);
-	unmap_size = rk_iommu_unmap_iova(rk_domain, pte_addr, pte_dma, size,
-					 iommu);
-
-	spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
-
-	/* Shootdown iotlb entries for iova range that was just unmapped */
-	rk_iommu_zap_iova(rk_domain, iova, unmap_size);
-
-	return unmap_size;
-}
-
-static size_t rk_iommu_unmap_v2(struct iommu_domain *domain, unsigned long _iova,
-				size_t size, struct iommu_iotlb_gather *gather)
-{
-	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
-	unsigned long flags;
-	dma_addr_t pte_dma, iova = (dma_addr_t)_iova;
-	phys_addr_t pt_phys;
-	u32 dte;
-	u32 *pte_addr;
-	size_t unmap_size;
-	struct rk_iommu *iommu = rk_iommu_get(rk_domain);
-
-	spin_lock_irqsave(&rk_domain->dt_lock, flags);
-
-	/*
-	 * pgsize_bitmap specifies iova sizes that fit in one page table
-	 * (1024 4-KiB pages = 4 MiB).
-	 * So, size will always be 4096 <= size <= 4194304.
-	 * Since iommu_unmap() guarantees that both iova and size will be
-	 * aligned, we will always only be unmapping from a single dte here.
-	 */
-	dte = rk_domain->dt[rk_iova_dte_index(iova)];
-	/* Just return 0 if iova is unmapped */
-	if (!rk_dte_is_pt_valid(dte)) {
-		spin_unlock_irqrestore(&rk_domain->dt_lock, flags);
-		return 0;
-	}
-
-	pt_phys = rk_dte_pt_address_v2(dte);
+	pt_phys = rk_ops->pt_address(dte);
 	pte_addr = (u32 *)phys_to_virt(pt_phys) + rk_iova_pte_index(iova);
 	pte_dma = pt_phys + rk_iova_pte_index(iova) * sizeof(u32);
 	unmap_size = rk_iommu_unmap_iova(rk_domain, pte_addr, pte_dma, size,
@@ -1383,7 +1151,6 @@ static int rk_iommu_enable(struct rk_iom
 	struct iommu_domain *domain = iommu->domain;
 	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
 	int ret, i;
-	u32 dt_v2;
 	u32 auto_gate;
 
 	ret = clk_bulk_enable(iommu->num_clocks, iommu->clocks);
@@ -1399,14 +1166,8 @@ static int rk_iommu_enable(struct rk_iom
 		goto out_disable_stall;
 
 	for (i = 0; i < iommu->num_mmu; i++) {
-		if (iommu->version >= 0x2) {
-			dt_v2 = (rk_domain->dt_dma & DT_LO_MASK) |
-				((rk_domain->dt_dma & DT_HI_MASK) >> DT_SHIFT);
-			rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR, dt_v2);
-		} else {
-			rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR,
-				       rk_domain->dt_dma);
-		}
+		rk_iommu_write(iommu->bases[i], RK_MMU_DTE_ADDR,
+			       rk_ops->dma_addr_dte(rk_domain->dt_dma));
 		rk_iommu_base_command(iommu->bases[i], RK_MMU_CMD_ZAP_CACHE);
 		rk_iommu_write(iommu->bases[i], RK_MMU_INT_MASK, RK_MMU_IRQ_MASK);
 
@@ -1453,6 +1214,28 @@ bool rockchip_iommu_is_enabled(struct de
 }
 EXPORT_SYMBOL(rockchip_iommu_is_enabled);
 
+int rockchip_iommu_force_reset(struct device *dev)
+{
+	struct rk_iommu *iommu;
+	int ret;
+
+	iommu = rk_iommu_from_dev(dev);
+	if (!iommu)
+		return -ENODEV;
+
+	ret = rk_iommu_enable_stall(iommu);
+	if (ret)
+		return ret;
+
+	ret = rk_iommu_force_reset(iommu);
+
+	rk_iommu_disable_stall(iommu);
+
+	return ret;
+
+}
+EXPORT_SYMBOL(rockchip_iommu_force_reset);
+
 static void rk_iommu_detach_device(struct iommu_domain *domain,
 				   struct device *dev)
 {
@@ -1564,8 +1347,6 @@ static struct iommu_domain *rk_iommu_dom
 		goto err_free_dt;
 	}
 
-	rk_table_flush(rk_domain, rk_domain->dt_dma, NUM_DT_ENTRIES);
-
 	spin_lock_init(&rk_domain->iommus_lock);
 	spin_lock_init(&rk_domain->dt_lock);
 	INIT_LIST_HEAD(&rk_domain->iommus);
@@ -1597,37 +1378,8 @@ static void rk_iommu_domain_free(struct
 	for (i = 0; i < NUM_DT_ENTRIES; i++) {
 		u32 dte = rk_domain->dt[i];
 		if (rk_dte_is_pt_valid(dte)) {
-			phys_addr_t pt_phys = rk_dte_pt_address(dte);
-			u32 *page_table = phys_to_virt(pt_phys);
-			dma_unmap_single(dma_dev, pt_phys,
-					 SPAGE_SIZE, DMA_TO_DEVICE);
-			free_page((unsigned long)page_table);
-		}
-	}
-
-	dma_unmap_single(dma_dev, rk_domain->dt_dma,
-			 SPAGE_SIZE, DMA_TO_DEVICE);
-	free_page((unsigned long)rk_domain->dt);
-
-	if (domain->type == IOMMU_DOMAIN_DMA)
-		iommu_put_dma_cookie(&rk_domain->domain);
-	kfree(rk_domain);
-}
-
-static void rk_iommu_domain_free_v2(struct iommu_domain *domain)
-{
-	struct rk_iommu_domain *rk_domain = to_rk_domain(domain);
-	int i;
-
-	WARN_ON(!list_empty(&rk_domain->iommus));
-
-	for (i = 0; i < NUM_DT_ENTRIES; i++) {
-		u32 dte = rk_domain->dt[i];
-
-		if (rk_dte_is_pt_valid(dte)) {
-			phys_addr_t pt_phys = rk_dte_pt_address_v2(dte);
+			phys_addr_t pt_phys = rk_ops->pt_address(dte);
 			u32 *page_table = phys_to_virt(pt_phys);
-
 			dma_unmap_single(dma_dev, pt_phys,
 					 SPAGE_SIZE, DMA_TO_DEVICE);
 			free_page((unsigned long)page_table);
@@ -1638,8 +1390,6 @@ static void rk_iommu_domain_free_v2(stru
 			 SPAGE_SIZE, DMA_TO_DEVICE);
 	free_page((unsigned long)rk_domain->dt);
 
-	if (domain->type == IOMMU_DOMAIN_DMA)
-		iommu_put_dma_cookie(&rk_domain->domain);
 	kfree(rk_domain);
 }
 
@@ -1749,7 +1499,7 @@ void rockchip_iommu_unmask_irq(struct de
 }
 EXPORT_SYMBOL(rockchip_iommu_unmask_irq);
 
-static struct iommu_ops rk_iommu_ops = {
+static const struct iommu_ops rk_iommu_ops = {
 	.domain_alloc = rk_iommu_domain_alloc,
 	.domain_free = rk_iommu_domain_free,
 	.attach_dev = rk_iommu_attach_device,
@@ -1766,68 +1516,34 @@ static struct iommu_ops rk_iommu_ops = {
 	.of_xlate = rk_iommu_of_xlate,
 };
 
-static struct iommu_ops rk_iommu_ops_v2 = {
-	.domain_alloc = rk_iommu_domain_alloc,
-	.domain_free = rk_iommu_domain_free_v2,
-	.attach_dev = rk_iommu_attach_device,
-	.detach_dev = rk_iommu_detach_device,
-	.map = rk_iommu_map_v2,
-	.unmap = rk_iommu_unmap_v2,
-	.flush_iotlb_all = rk_iommu_flush_tlb_all,
-	.probe_device = rk_iommu_probe_device,
-	.release_device = rk_iommu_release_device,
-	.iova_to_phys = rk_iommu_iova_to_phys_v2,
-	.is_attach_deferred = rk_iommu_is_attach_deferred,
-	.device_group = rk_iommu_device_group,
-	.pgsize_bitmap = RK_IOMMU_PGSIZE_BITMAP,
-	.of_xlate = rk_iommu_of_xlate,
-};
-
-static const struct rockchip_iommu_data iommu_data_v1 = {
-	.version = 0x1,
-};
-
-static const struct rockchip_iommu_data iommu_data_v2 = {
-	.version = 0x2,
-};
-
-static const struct of_device_id rk_iommu_dt_ids[] = {
-	{
-		.compatible = "rockchip,iommu",
-		.data = &iommu_data_v1,
-	}, {
-		.compatible = "rockchip,iommu-v2",
-		.data = &iommu_data_v2,
-	},
-	{ /* sentinel */ }
-};
-
 static int rk_iommu_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct rk_iommu *iommu;
 	struct resource *res;
+	const struct rk_iommu_ops *ops;
 	int num_res = pdev->num_resources;
 	int err, i;
-	const struct of_device_id *match;
-	struct rockchip_iommu_data *data;
 
 	iommu = devm_kzalloc(dev, sizeof(*iommu), GFP_KERNEL);
 	if (!iommu)
 		return -ENOMEM;
 
-	match = of_match_device(rk_iommu_dt_ids, dev);
-	if (!match)
-		return -EINVAL;
-
-	data = (struct rockchip_iommu_data *)match->data;
-	iommu->version = data->version;
-	dev_info(dev, "version = %x\n", iommu->version);
-
 	platform_set_drvdata(pdev, iommu);
 	iommu->dev = dev;
 	iommu->num_mmu = 0;
 
+	ops = of_device_get_match_data(dev);
+	if (!rk_ops)
+		rk_ops = ops;
+
+	/*
+	 * That should not happen unless different versions of the
+	 * hardware block are embedded the same SoC
+	 */
+	if (WARN_ON(rk_ops != ops))
+		return -EINVAL;
+
 	iommu->bases = devm_kcalloc(dev, num_res, sizeof(*iommu->bases),
 				    GFP_KERNEL);
 	if (!iommu->bases)
@@ -1894,10 +1610,8 @@ static int rk_iommu_probe(struct platfor
 	if (err)
 		goto err_put_group;
 
-	if (iommu->version >= 0x2)
-		iommu_device_set_ops(&iommu->iommu, &rk_iommu_ops_v2);
-	else
-		iommu_device_set_ops(&iommu->iommu, &rk_iommu_ops);
+	iommu_device_set_ops(&iommu->iommu, &rk_iommu_ops);
+
 	iommu_device_set_fwnode(&iommu->iommu, &dev->of_node->fwnode);
 
 	err = iommu_device_register(&iommu->iommu);
@@ -1912,10 +1626,7 @@ static int rk_iommu_probe(struct platfor
 	if (!dma_dev)
 		dma_dev = &pdev->dev;
 
-	if (iommu->version >= 0x2)
-		bus_set_iommu(&platform_bus_type, &rk_iommu_ops_v2);
-	else
-		bus_set_iommu(&platform_bus_type, &rk_iommu_ops);
+	bus_set_iommu(&platform_bus_type, &rk_iommu_ops);
 
 	pm_runtime_enable(dev);
 
@@ -1943,6 +1654,8 @@ skip_request_irq:
 		pr_info("%s,%d, res_page = 0x%pa\n", __func__, __LINE__, &res_page);
 	}
 
+	dma_set_mask_and_coherent(dev, rk_ops->dma_bit_mask);
+
 	return 0;
 err_pm_disable:
 	pm_runtime_disable(dev);
@@ -1970,7 +1683,8 @@ static void rk_iommu_shutdown(struct pla
 	}
 
 skip_free_irq:
-	pm_runtime_force_suspend(&pdev->dev);
+	if (!iommu->dlr_disable)
+		pm_runtime_force_suspend(&pdev->dev);
 }
 
 static int __maybe_unused rk_iommu_suspend(struct device *dev)
@@ -2006,6 +1720,37 @@ static const struct dev_pm_ops rk_iommu_
 				pm_runtime_force_resume)
 };
 
+static struct rk_iommu_ops iommu_data_ops_v1 = {
+	.pt_address = &rk_dte_pt_address,
+	.mk_dtentries = &rk_mk_dte,
+	.mk_ptentries = &rk_mk_pte,
+	.dte_addr_phys = &rk_dte_addr_phys,
+	.dma_addr_dte = &rk_dma_addr_dte,
+	.dma_bit_mask = DMA_BIT_MASK(32),
+};
+
+static struct rk_iommu_ops iommu_data_ops_v2 = {
+	.pt_address = &rk_dte_pt_address_v2,
+	.mk_dtentries = &rk_mk_dte_v2,
+	.mk_ptentries = &rk_mk_pte_v2,
+	.dte_addr_phys = &rk_dte_addr_phys_v2,
+	.dma_addr_dte = &rk_dma_addr_dte_v2,
+	.dma_bit_mask = DMA_BIT_MASK(40),
+};
+
+static const struct of_device_id rk_iommu_dt_ids[] = {
+	{	.compatible = "rockchip,iommu",
+		.data = &iommu_data_ops_v1,
+	},
+	{	.compatible = "rockchip,iommu-v2",
+		.data = &iommu_data_ops_v2,
+	},
+	{	.compatible = "rockchip,rk3568-iommu",
+		.data = &iommu_data_ops_v2,
+	},
+	{ /* sentinel */ }
+};
+
 static struct platform_driver rk_iommu_driver = {
 	.probe = rk_iommu_probe,
 	.shutdown = rk_iommu_shutdown,
--- a/drivers/irqchip/irq-gic-v3-its.c
+++ b/drivers/irqchip/irq-gic-v3-its.c
@@ -3046,18 +3046,12 @@ static int __init allocate_lpi_tables(vo
 	return 0;
 }
 
-static u64 its_clear_vpend_valid(void __iomem *vlpi_base, u64 clr, u64 set)
+static u64 read_vpend_dirty_clear(void __iomem *vlpi_base)
 {
 	u32 count = 1000000;	/* 1s! */
 	bool clean;
 	u64 val;
 
-	val = gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
-	val &= ~GICR_VPENDBASER_Valid;
-	val &= ~clr;
-	val |= set;
-	gicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
-
 	do {
 		val = gicr_read_vpendbaser(vlpi_base + GICR_VPENDBASER);
 		clean = !(val & GICR_VPENDBASER_Dirty);
@@ -3068,10 +3062,26 @@ static u64 its_clear_vpend_valid(void __
 		}
 	} while (!clean && count);
 
-	if (unlikely(val & GICR_VPENDBASER_Dirty)) {
+	if (unlikely(!clean))
 		pr_err_ratelimited("ITS virtual pending table not cleaning\n");
+
+	return val;
+}
+
+static u64 its_clear_vpend_valid(void __iomem *vlpi_base, u64 clr, u64 set)
+{
+	u64 val;
+
+	/* Make sure we wait until the RD is done with the initial scan */
+	val = read_vpend_dirty_clear(vlpi_base);
+	val &= ~GICR_VPENDBASER_Valid;
+	val &= ~clr;
+	val |= set;
+	gicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
+
+	val = read_vpend_dirty_clear(vlpi_base);
+	if (unlikely(val & GICR_VPENDBASER_Dirty))
 		val |= GICR_VPENDBASER_PendingLast;
-	}
 
 	return val;
 }
@@ -3922,8 +3932,6 @@ static void its_vpe_schedule(struct its_
 	val |= vpe->idai ? GICR_VPENDBASER_IDAI : 0;
 	val |= GICR_VPENDBASER_Valid;
 	gicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
-
-	its_wait_vpt_parse_complete();
 }
 
 static void its_vpe_deschedule(struct its_vpe *vpe)
@@ -3971,6 +3979,10 @@ static int its_vpe_set_vcpu_affinity(str
 		its_vpe_deschedule(vpe);
 		return 0;
 
+	case COMMIT_VPE:
+		its_wait_vpt_parse_complete();
+		return 0;
+
 	case INVALL_VPE:
 		its_vpe_invall(vpe);
 		return 0;
@@ -4124,8 +4136,6 @@ static void its_vpe_4_1_schedule(struct
 	val |= FIELD_PREP(GICR_VPENDBASER_4_1_VPEID, vpe->vpe_id);
 
 	gicr_write_vpendbaser(val, vlpi_base + GICR_VPENDBASER);
-
-	its_wait_vpt_parse_complete();
 }
 
 static void its_vpe_4_1_deschedule(struct its_vpe *vpe,
@@ -4200,6 +4210,10 @@ static int its_vpe_4_1_set_vcpu_affinity
 		its_vpe_4_1_deschedule(vpe, info);
 		return 0;
 
+	case COMMIT_VPE:
+		its_wait_vpt_parse_complete();
+		return 0;
+
 	case INVALL_VPE:
 		its_vpe_4_1_invall(vpe);
 		return 0;
--- a/drivers/irqchip/irq-gic-v4.c
+++ b/drivers/irqchip/irq-gic-v4.c
@@ -232,6 +232,8 @@ int its_make_vpe_non_resident(struct its
 	if (!ret)
 		vpe->resident = false;
 
+	vpe->ready = false;
+
 	return ret;
 }
 
@@ -258,6 +260,23 @@ int its_make_vpe_resident(struct its_vpe
 	return ret;
 }
 
+int its_commit_vpe(struct its_vpe *vpe)
+{
+	struct its_cmd_info info = {
+		.cmd_type = COMMIT_VPE,
+	};
+	int ret;
+
+	WARN_ON(preemptible());
+
+	ret = its_send_vpe_cmd(vpe, &info);
+	if (!ret)
+		vpe->ready = true;
+
+	return ret;
+}
+
+
 int its_invall_vpe(struct its_vpe *vpe)
 {
 	struct its_cmd_info info = {
--- a/drivers/mailbox/rockchip-mailbox.c
+++ b/drivers/mailbox/rockchip-mailbox.c
@@ -11,6 +11,8 @@
 #include <linux/module.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
+#include <linux/spinlock.h>
+#include <soc/rockchip/rockchip-mailbox.h>
 
 #define MAILBOX_A2B_INTEN		0x00
 #define MAILBOX_A2B_STATUS		0x04
@@ -22,11 +24,6 @@
 #define MAILBOX_B2A_CMD(x)		(0x30 + (x) * 8)
 #define MAILBOX_B2A_DAT(x)		(0x34 + (x) * 8)
 
-struct rockchip_mbox_msg {
-	u32 cmd;
-	int rx_size;
-};
-
 struct rockchip_mbox_data {
 	int num_chans;
 };
@@ -34,17 +31,14 @@ struct rockchip_mbox_data {
 struct rockchip_mbox_chan {
 	int idx;
 	int irq;
-	struct rockchip_mbox_msg *msg;
-	struct rockchip_mbox *mb;
 };
 
 struct rockchip_mbox {
 	struct mbox_controller mbox;
 	struct clk *pclk;
 	void __iomem *mbox_base;
-
-	/* The maximum size of buf for each channel */
-	u32 buf_size;
+	spinlock_t cfg_lock; /* Serialise access to the register */
+	struct rockchip_mbox_msg *msg;
 
 	struct rockchip_mbox_chan *chans;
 };
@@ -53,24 +47,23 @@ static int rockchip_mbox_send_data(struc
 {
 	struct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);
 	struct rockchip_mbox_msg *msg = data;
-	struct rockchip_mbox_chan *chans = mb->chans;
+	struct rockchip_mbox_chan *chans = chan->con_priv;
+	u32 status;
 
 	if (!msg)
 		return -EINVAL;
 
-	if (msg->rx_size > mb->buf_size) {
-		dev_err(mb->mbox.dev, "Transmit size over buf size(%d)\n",
-			mb->buf_size);
-		return -EINVAL;
+	status = readl_relaxed(mb->mbox_base + MAILBOX_A2B_STATUS);
+	if (status & (1U << chans->idx)) {
+		dev_err(mb->mbox.dev, "The mailbox channel is busy\n");
+		return -EBUSY;
 	}
 
-	dev_dbg(mb->mbox.dev, "Chan[%d]: A2B message, cmd 0x%08x\n",
-		chans->idx, msg->cmd);
-
-	mb->chans[chans->idx].msg = msg;
+	dev_dbg(mb->mbox.dev, "Chan[%d]: A2B message, cmd 0x%08x, data 0x%08x\n",
+		chans->idx, msg->cmd, msg->data);
 
 	writel_relaxed(msg->cmd, mb->mbox_base + MAILBOX_A2B_CMD(chans->idx));
-	writel_relaxed(msg->rx_size, mb->mbox_base +
+	writel_relaxed(msg->data, mb->mbox_base +
 		       MAILBOX_A2B_DAT(chans->idx));
 
 	return 0;
@@ -79,10 +72,15 @@ static int rockchip_mbox_send_data(struc
 static int rockchip_mbox_startup(struct mbox_chan *chan)
 {
 	struct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);
+	struct rockchip_mbox_chan *chans = chan->con_priv;
+	u32 val = 0U;
 
-	/* Enable all B2A interrupts */
-	writel_relaxed((1 << mb->mbox.num_chans) - 1,
-		       mb->mbox_base + MAILBOX_B2A_INTEN);
+	/* Enable the corresponding B2A interrupt */
+	spin_lock(&mb->cfg_lock);
+	val = readl_relaxed(mb->mbox_base + MAILBOX_B2A_INTEN) |
+		(1U << chans->idx);
+	writel_relaxed(val, mb->mbox_base + MAILBOX_B2A_INTEN);
+	spin_unlock(&mb->cfg_lock);
 
 	return 0;
 }
@@ -90,12 +88,15 @@ static int rockchip_mbox_startup(struct
 static void rockchip_mbox_shutdown(struct mbox_chan *chan)
 {
 	struct rockchip_mbox *mb = dev_get_drvdata(chan->mbox->dev);
-	struct rockchip_mbox_chan *chans = mb->chans;
-
-	/* Disable all B2A interrupts */
-	writel_relaxed(0, mb->mbox_base + MAILBOX_B2A_INTEN);
+	struct rockchip_mbox_chan *chans = chan->con_priv;
+	u32 val = 0U;
 
-	mb->chans[chans->idx].msg = NULL;
+	/* Disable the corresponding B2A interrupt */
+	spin_lock(&mb->cfg_lock);
+	val = readl_relaxed(mb->mbox_base + MAILBOX_B2A_INTEN) &
+		~(1U << chans->idx);
+	writel_relaxed(val, mb->mbox_base + MAILBOX_B2A_INTEN);
+	spin_unlock(&mb->cfg_lock);
 }
 
 static const struct mbox_chan_ops rockchip_mbox_chan_ops = {
@@ -104,48 +105,51 @@ static const struct mbox_chan_ops rockch
 	.shutdown	= rockchip_mbox_shutdown,
 };
 
-static irqreturn_t rockchip_mbox_irq(int irq, void *dev_id)
+int rockchip_mbox_read_msg(struct mbox_chan *chan,
+			   struct rockchip_mbox_msg *msg)
 {
-	int idx;
-	struct rockchip_mbox *mb = (struct rockchip_mbox *)dev_id;
-	u32 status = readl_relaxed(mb->mbox_base + MAILBOX_B2A_STATUS);
+	struct rockchip_mbox *mb;
+	struct rockchip_mbox_chan *chans;
 
-	for (idx = 0; idx < mb->mbox.num_chans; idx++) {
-		if ((status & (1 << idx)) && (irq == mb->chans[idx].irq)) {
-			/* Clear mbox interrupt */
-			writel_relaxed(1 << idx,
-				       mb->mbox_base + MAILBOX_B2A_STATUS);
-			return IRQ_WAKE_THREAD;
-		}
-	}
+	if (!chan || !msg)
+		return -EINVAL;
+
+	mb = dev_get_drvdata(chan->mbox->dev);
+	chans = chan->con_priv;
 
-	return IRQ_NONE;
+	msg->cmd  = mb->msg[chans->idx].cmd;
+	msg->data = mb->msg[chans->idx].data;
+
+	return 0;
 }
+EXPORT_SYMBOL_GPL(rockchip_mbox_read_msg);
 
-static irqreturn_t rockchip_mbox_isr(int irq, void *dev_id)
+static irqreturn_t rockchip_mbox_irq(int irq, void *dev_id)
 {
 	int idx;
-	struct rockchip_mbox_msg *msg = NULL;
+	struct rockchip_mbox_msg *msg;
 	struct rockchip_mbox *mb = (struct rockchip_mbox *)dev_id;
+	u32 status = readl_relaxed(mb->mbox_base + MAILBOX_B2A_STATUS);
 
 	for (idx = 0; idx < mb->mbox.num_chans; idx++) {
-		if (irq != mb->chans[idx].irq)
-			continue;
-
-		msg = mb->chans[idx].msg;
-		if (!msg) {
-			dev_err(mb->mbox.dev,
-				"Chan[%d]: B2A message is NULL\n", idx);
-			break; /* spurious */
-		}
+		if ((status & (1U << idx)) && irq == mb->chans[idx].irq) {
+			/* Get cmd/data from the channel of B2A */
+			msg = &mb->msg[idx];
+			msg->cmd = readl_relaxed(mb->mbox_base +
+						 MAILBOX_B2A_CMD(idx));
+			msg->data = readl_relaxed(mb->mbox_base +
+						  MAILBOX_B2A_DAT(idx));
 
-		mbox_chan_received_data(&mb->mbox.chans[idx], msg);
-		mb->chans[idx].msg = NULL;
+			dev_dbg(mb->mbox.dev, "Chan[%d]: B2A message, cmd 0x%08x, data 0x%08x\n",
+				idx, msg->cmd, msg->data);
 
-		dev_dbg(mb->mbox.dev, "Chan[%d]: B2A message, cmd 0x%08x\n",
-			idx, msg->cmd);
+			if (mb->mbox.chans[idx].cl)
+				mbox_chan_received_data(&mb->mbox.chans[idx], msg);
 
-		break;
+			/* Clear mbox interrupt */
+			writel_relaxed(1U << idx,
+				       mb->mbox_base + MAILBOX_B2A_STATUS);
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -179,6 +183,11 @@ static int rockchip_mbox_probe(struct pl
 	if (!mb)
 		return -ENOMEM;
 
+	mb->msg = devm_kcalloc(&pdev->dev, drv_data->num_chans,
+			       sizeof(*mb->msg), GFP_KERNEL);
+	if (!mb->msg)
+		return -ENOMEM;
+
 	mb->chans = devm_kcalloc(&pdev->dev, drv_data->num_chans,
 				 sizeof(*mb->chans), GFP_KERNEL);
 	if (!mb->chans)
@@ -195,6 +204,7 @@ static int rockchip_mbox_probe(struct pl
 	mb->mbox.num_chans = drv_data->num_chans;
 	mb->mbox.ops = &rockchip_mbox_chan_ops;
 	mb->mbox.txdone_irq = true;
+	spin_lock_init(&mb->cfg_lock);
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	if (!res)
@@ -204,9 +214,6 @@ static int rockchip_mbox_probe(struct pl
 	if (IS_ERR(mb->mbox_base))
 		return PTR_ERR(mb->mbox_base);
 
-	/* Each channel has two buffers for A2B and B2A */
-	mb->buf_size = (size_t)resource_size(res) / (drv_data->num_chans * 2);
-
 	mb->pclk = devm_clk_get(&pdev->dev, "pclk_mailbox");
 	if (IS_ERR(mb->pclk)) {
 		ret = PTR_ERR(mb->pclk);
@@ -223,26 +230,50 @@ static int rockchip_mbox_probe(struct pl
 
 	for (i = 0; i < mb->mbox.num_chans; i++) {
 		irq = platform_get_irq(pdev, i);
-		if (irq < 0)
-			return irq;
-
-		ret = devm_request_threaded_irq(&pdev->dev, irq,
-						rockchip_mbox_irq,
-						rockchip_mbox_isr, IRQF_ONESHOT,
-						dev_name(&pdev->dev), mb);
-		if (ret < 0)
-			return ret;
+		if (irq < 0) {
+			/* For shared irq case, only could be got one time */
+			if (i > 0 && irq == -ENXIO) {
+				mb->chans[i].irq = mb->chans[0].irq;
+			} else {
+				ret = irq;
+				goto disable_clk;
+			}
+		} else {
+			mb->chans[i].irq = irq;
+		}
 
 		mb->chans[i].idx = i;
-		mb->chans[i].irq = irq;
-		mb->chans[i].mb = mb;
-		mb->chans[i].msg = NULL;
+		mb->mbox.chans[i].con_priv = &mb->chans[i];
 	}
 
 	ret = devm_mbox_controller_register(&pdev->dev, &mb->mbox);
-	if (ret < 0)
+	if (ret < 0) {
 		dev_err(&pdev->dev, "Failed to register mailbox: %d\n", ret);
+		goto disable_clk;
+	}
+
+	for (i = 0; i < mb->mbox.num_chans; i++) {
+		/* For shared irq case, only request irq thread one time */
+		if (i > 0 && mb->chans[i].irq == mb->chans[0].irq)
+			break;
+
+		ret = devm_request_threaded_irq(&pdev->dev, mb->chans[i].irq,
+						NULL,
+						rockchip_mbox_irq,
+						IRQF_ONESHOT,
+						dev_name(&pdev->dev),
+						mb);
+		if (ret < 0)
+			goto disable_clk;
+
+		if (device_property_present(&pdev->dev, "wakeup-source"))
+			enable_irq_wake(mb->chans[i].irq);
+	}
+
+	return 0;
 
+disable_clk:
+	clk_disable_unprepare(mb->pclk);
 	return ret;
 }
 
--- a/drivers/media/common/videobuf2/videobuf2-v4l2.c
+++ b/drivers/media/common/videobuf2/videobuf2-v4l2.c
@@ -295,6 +295,12 @@ static int vb2_fill_vb2_v4l2_buffer(stru
 		}
 
 		planes[0].data_offset = 0;
+#if defined(CONFIG_ARCH_ROCKCHIP) && defined(CONFIG_COMPAT_32BIT_TIME) && \
+	IS_ENABLED(CONFIG_USB_F_UVC)
+		if (b->memory == VB2_MEMORY_DMABUF)
+			planes[0].data_offset = b->reserved2;
+#endif
+
 		if (V4L2_TYPE_IS_OUTPUT(b->type)) {
 			if (b->bytesused == 0)
 				vb2_warn_zero_bytesused(vb);
--- a/drivers/mmc/host/sdhci-of-dwcmshc.c
+++ b/drivers/mmc/host/sdhci-of-dwcmshc.c
@@ -27,11 +27,15 @@
 /* DWCMSHC specific Mode Select value */
 #define DWCMSHC_CTRL_HS400		0x7
 
-#define DWCMSHC_VER_ID			0x500
-#define DWCMSHC_VER_TYPE		0x504
-#define DWCMSHC_HOST_CTRL3		0x508
-#define DWCMSHC_EMMC_CONTROL		0x52c
-#define DWCMSHC_EMMC_ATCTRL		0x540
+/* DWC IP vendor area 1 pointer */
+#define DWCMSHC_P_VENDOR_AREA1		0xe8
+#define DWCMSHC_AREA1_MASK		GENMASK(11, 0)
+/* Offset inside the  vendor area 1 */
+#define DWCMSHC_HOST_CTRL3		0x8
+#define DWCMSHC_EMMC_CONTROL		0x2c
+#define DWCMSHC_CARD_IS_EMMC		BIT(0)
+#define DWCMSHC_ENHANCED_STROBE		BIT(8)
+#define DWCMSHC_EMMC_ATCTRL		0x40
 
 /* Rockchip specific Registers */
 #define DWCMSHC_EMMC_DLL_CTRL		0x800
@@ -40,55 +44,47 @@
 #define DWCMSHC_EMMC_DLL_STRBIN		0x80c
 #define DECMSHC_EMMC_DLL_CMDOUT		0x810
 #define DWCMSHC_EMMC_DLL_STATUS0	0x840
-
+#define DWCMSHC_EMMC_DLL_STATUS1	0x844
 #define DWCMSHC_EMMC_DLL_START		BIT(0)
 #define DWCMSHC_EMMC_DLL_LOCKED		BIT(8)
 #define DWCMSHC_EMMC_DLL_TIMEOUT	BIT(9)
+#define DWCMSHC_EMMC_DLL_RXCLK_SRCSEL	29
 #define DWCMSHC_EMMC_DLL_START_POINT	16
 #define DWCMSHC_EMMC_DLL_INC		8
 #define DWCMSHC_EMMC_DLL_BYPASS		BIT(24)
 #define DWCMSHC_EMMC_DLL_DLYENA		BIT(27)
-
+#define DLL_TAP_VALUE_SEL		BIT(25)
+#define DLL_TAP_VALUE_OFFSET		8
 #define DLL_TXCLK_TAPNUM_DEFAULT	0x10
-#define DLL_TXCLK_TAPNUM_90_DEGREES	0x9
+#define DLL_TXCLK_TAPNUM_90_DEGREES	0xA
 #define DLL_TXCLK_TAPNUM_FROM_SW	BIT(24)
-#define DLL_TXCLK_NO_INVERTER		BIT(29)
-
-#define DLL_STRBIN_TAPNUM_DEFAULT	0x4
+#define DLL_STRBIN_TAPNUM_DEFAULT	0x8
 #define DLL_STRBIN_TAPNUM_FROM_SW	BIT(24)
 #define DLL_STRBIN_DELAY_NUM_SEL	BIT(26)
 #define DLL_STRBIN_DELAY_NUM_OFFSET	16
-#define DLL_STRBIN_DELAY_NUM_DEFAULT	0x10
-
-#define DLL_RXCLK_NO_INVERTER		BIT(29)
-
-#define DWCMSHC_CARD_IS_EMMC		BIT(0)
-#define DWCMSHC_ENHANCED_STROBE		BIT(8)
-
+#define DLL_STRBIN_DELAY_NUM_DEFAULT	0x16
+#define DLL_RXCLK_NO_INVERTER		1
+#define DLL_RXCLK_INVERTER		0
 #define DLL_CMDOUT_TAPNUM_90_DEGREES	0x8
+#define DLL_RXCLK_TAPNUM_FROM_SW	BIT(24)
+#define DLL_RXCLK_ORI_GATE		BIT(31)
+#define DLL_RXCLK_MAX_TAP		32
 #define DLL_CMDOUT_TAPNUM_FROM_SW	BIT(24)
 #define DLL_CMDOUT_SRC_CLK_NEG		BIT(28)
 #define DLL_CMDOUT_EN_SRC_CLK_NEG	BIT(29)
+#define DLL_CMDOUT_BOTH_CLK_EDGE	BIT(30)
 
 #define DLL_LOCK_WO_TMOUT(x) \
 	((((x) & DWCMSHC_EMMC_DLL_LOCKED) == DWCMSHC_EMMC_DLL_LOCKED) && \
 	(((x) & DWCMSHC_EMMC_DLL_TIMEOUT) == 0))
-#define ROCKCHIP_MAX_CLKS		3
+#define RK35xx_MAX_CLKS 3
 
 #define BOUNDARY_OK(addr, len) \
 	((addr | (SZ_128M - 1)) == ((addr + len - 1) | (SZ_128M - 1)))
 
-struct dwcmshc_priv {
-	struct clk	*bus_clk;
-	u32 cclk_rate;
-
-	/* Rockchip specified optional clocks */
-	struct clk_bulk_data rockchip_clks[ROCKCHIP_MAX_CLKS];
-	struct reset_control *reset;
-	int txclk_tapnum;
-	unsigned int actual_clk;
-	u32 flags;
-	u32 acpi_en;
+enum dwcmshc_rk_type {
+	DWCMSHC_RK3568,
+	DWCMSHC_RK3588,
 };
 
 struct dwcmshc_driver_data {
@@ -97,6 +93,31 @@ struct dwcmshc_driver_data {
 #define RK_PLATFROM		BIT(0)
 #define RK_DLL_CMD_OUT		BIT(1)
 #define RK_RXCLK_NO_INVERTER	BIT(2)
+#define RK_TAP_VALUE_SEL	BIT(3)
+
+	u8 hs200_tx_tap;
+	u8 hs400_tx_tap;
+	u8 hs400_cmd_tap;
+	u8 ddr50_strbin_delay_num;
+	u8 hs400_strbin_tap;
+};
+
+struct rk35xx_priv {
+	/* Rockchip specified optional clocks */
+	struct clk_bulk_data rockchip_clks[RK35xx_MAX_CLKS];
+	struct reset_control *reset;
+	enum dwcmshc_rk_type devtype;
+	u8 txclk_tapnum;
+	u32 cclk_rate;
+	unsigned int actual_clk;
+	const struct dwcmshc_driver_data *drv_data;
+	u32 acpi_en;
+};
+
+struct dwcmshc_priv {
+	struct clk	*bus_clk;
+	int vendor_specific_area1; /* P_VENDOR_SPECIFIC_AREA reg */
+	void *priv; /* pointer to SoC private stuff */
 };
 
 /*
@@ -122,6 +143,16 @@ static void dwcmshc_adma_write_desc(stru
 	sdhci_adma_write_desc(host, desc, addr, len, cmd);
 }
 
+static unsigned int dwcmshc_get_max_clock(struct sdhci_host *host)
+{
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+
+	if (pltfm_host->clk)
+		return sdhci_pltfm_clk_get_max_clock(host);
+	else
+		return pltfm_host->clock;
+}
+
 static void dwcmshc_check_auto_cmd23(struct mmc_host *mmc,
 				     struct mmc_request *mrq)
 {
@@ -148,7 +179,9 @@ static void dwcmshc_request(struct mmc_h
 static void dwcmshc_set_uhs_signaling(struct sdhci_host *host,
 				      unsigned int timing)
 {
-	u16 ctrl_2, ctrl;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	u16 ctrl, ctrl_2;
 
 	ctrl_2 = sdhci_readw(host, SDHCI_HOST_CONTROL2);
 	/* Select Bus Speed Mode for host */
@@ -168,9 +201,9 @@ static void dwcmshc_set_uhs_signaling(st
 		ctrl_2 |= SDHCI_CTRL_UHS_DDR50;
 	else if (timing == MMC_TIMING_MMC_HS400) {
 		/* set CARD_IS_EMMC bit to enable Data Strobe for HS400 */
-		ctrl = sdhci_readw(host, DWCMSHC_EMMC_CONTROL);
+		ctrl = sdhci_readw(host, priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL);
 		ctrl |= DWCMSHC_CARD_IS_EMMC;
-		sdhci_writew(host, ctrl, DWCMSHC_EMMC_CONTROL);
+		sdhci_writew(host, ctrl, priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL);
 
 		ctrl_2 |= DWCMSHC_CTRL_HS400;
 	}
@@ -183,21 +216,27 @@ static void dwcmshc_hs400_enhanced_strob
 {
 	u32 vendor;
 	struct sdhci_host *host = mmc_priv(mmc);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	int reg = priv->vendor_specific_area1 + DWCMSHC_EMMC_CONTROL;
 
-	vendor = sdhci_readl(host, DWCMSHC_EMMC_CONTROL);
+	vendor = sdhci_readl(host, reg);
 	if (ios->enhanced_strobe)
 		vendor |= DWCMSHC_ENHANCED_STROBE;
 	else
 		vendor &= ~DWCMSHC_ENHANCED_STROBE;
 
-	sdhci_writel(host, vendor, DWCMSHC_EMMC_CONTROL);
+	sdhci_writel(host, vendor, reg);
 }
 
-static void dwcmshc_rk_set_clock(struct sdhci_host *host, unsigned int clock)
+static void dwcmshc_rk3568_set_clock(struct sdhci_host *host, unsigned int clock)
 {
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
-	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
-	u32 txclk_tapnum, extra;
+	struct dwcmshc_priv *dwc_priv = sdhci_pltfm_priv(pltfm_host);
+	struct rk35xx_priv *priv = dwc_priv->priv;
+	const struct dwcmshc_driver_data *drv_data = priv->drv_data;
+	u8 txclk_tapnum = DLL_TXCLK_TAPNUM_DEFAULT;
+	u32 extra, reg, dll_lock_value;
 	int err;
 
 	host->mmc->actual_clock = 0;
@@ -230,17 +269,23 @@ static void dwcmshc_rk_set_clock(struct
 	sdhci_set_clock(host, clock);
 
 	/* Disable cmd conflict check */
-	extra = sdhci_readl(host, DWCMSHC_HOST_CTRL3);
+	reg = dwc_priv->vendor_specific_area1 + DWCMSHC_HOST_CTRL3;
+	extra = sdhci_readl(host, reg);
 	extra &= ~BIT(0);
-	sdhci_writel(host, extra, DWCMSHC_HOST_CTRL3);
+	sdhci_writel(host, extra, reg);
+
+	/* Disable output clock while config DLL */
+	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);
 
 	if (clock <= 52000000) {
+		/* Disable DLL */
+		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_CTRL);
 		/*
-		 * Disable DLL and reset both of sample and drive clock.
+		 * Config DLL BYPASS and Reset both of sample and drive clock.
 		 * The bypass bit and start bit need to set if DLL is not locked.
 		 */
 		sdhci_writel(host, DWCMSHC_EMMC_DLL_BYPASS | DWCMSHC_EMMC_DLL_START, DWCMSHC_EMMC_DLL_CTRL);
-		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_RXCLK);
+		sdhci_writel(host, DLL_RXCLK_ORI_GATE, DWCMSHC_EMMC_DLL_RXCLK);
 		sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_TXCLK);
 		sdhci_writel(host, 0, DECMSHC_EMMC_DLL_CMDOUT);
 		/*
@@ -250,9 +295,9 @@ static void dwcmshc_rk_set_clock(struct
 		 */
 		extra = DWCMSHC_EMMC_DLL_DLYENA |
 			DLL_STRBIN_DELAY_NUM_SEL |
-			DLL_STRBIN_DELAY_NUM_DEFAULT << DLL_STRBIN_DELAY_NUM_OFFSET;
+			drv_data->ddr50_strbin_delay_num << DLL_STRBIN_DELAY_NUM_OFFSET;
 		sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_STRBIN);
-		return;
+		goto exit;
 	}
 
 	/* Reset DLL */
@@ -260,17 +305,9 @@ static void dwcmshc_rk_set_clock(struct
 	udelay(1);
 	sdhci_writel(host, 0x0, DWCMSHC_EMMC_DLL_CTRL);
 
-	/*
-	 * We shouldn't set DLL_RXCLK_NO_INVERTER for identify mode but
-	 * we must set it in higher speed mode.
-	 */
-	extra = DWCMSHC_EMMC_DLL_DLYENA;
-	if (priv->flags & RK_RXCLK_NO_INVERTER)
-		extra |= DLL_RXCLK_NO_INVERTER;
-	sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_RXCLK);
-
 	/* Init DLL settings, clean start bit before resetting */
 	sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_CTRL);
+	/* Init DLL settings */
 	extra = 0x5 << DWCMSHC_EMMC_DLL_START_POINT |
 		0x2 << DWCMSHC_EMMC_DLL_INC |
 		DWCMSHC_EMMC_DLL_START;
@@ -280,53 +317,66 @@ static void dwcmshc_rk_set_clock(struct
 				 500 * USEC_PER_MSEC);
 	if (err) {
 		dev_err(mmc_dev(host->mmc), "DLL lock timeout!\n");
-		return;
+		goto exit;
 	}
 
+	dll_lock_value = ((sdhci_readl(host, DWCMSHC_EMMC_DLL_STATUS0) & 0xFF) * 2) & 0xFF;
+
 	extra = 0x1 << 16 | /* tune clock stop en */
-		0x2 << 17 | /* pre-change delay */
+		0x3 << 17 | /* pre-change delay */
 		0x3 << 19;  /* post-change delay */
-	sdhci_writel(host, extra, DWCMSHC_EMMC_ATCTRL);
+	sdhci_writel(host, extra, dwc_priv->vendor_specific_area1 + DWCMSHC_EMMC_ATCTRL);
 
-	txclk_tapnum = priv->txclk_tapnum;
+	extra = DWCMSHC_EMMC_DLL_DLYENA | DLL_RXCLK_ORI_GATE;
+	if (drv_data->flags & RK_RXCLK_NO_INVERTER)
+		extra |= DLL_RXCLK_NO_INVERTER << DWCMSHC_EMMC_DLL_RXCLK_SRCSEL;
+	if (drv_data->flags & RK_TAP_VALUE_SEL)
+		extra |= DLL_TAP_VALUE_SEL | dll_lock_value << DLL_TAP_VALUE_OFFSET;
+	sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_RXCLK);
 
-	if ((priv->flags & RK_DLL_CMD_OUT) &&
+	txclk_tapnum = drv_data->hs200_tx_tap;
+	if ((drv_data->flags & RK_DLL_CMD_OUT) &&
 	    host->mmc->ios.timing == MMC_TIMING_MMC_HS400) {
-		txclk_tapnum = DLL_TXCLK_TAPNUM_90_DEGREES;
-
+		txclk_tapnum = drv_data->hs400_tx_tap;
 		extra = DLL_CMDOUT_SRC_CLK_NEG |
-			DLL_CMDOUT_EN_SRC_CLK_NEG |
+			DLL_CMDOUT_BOTH_CLK_EDGE |
 			DWCMSHC_EMMC_DLL_DLYENA |
-			DLL_CMDOUT_TAPNUM_90_DEGREES |
+			drv_data->hs400_cmd_tap |
 			DLL_CMDOUT_TAPNUM_FROM_SW;
+		if (drv_data->flags & RK_TAP_VALUE_SEL)
+			extra |= DLL_TAP_VALUE_SEL | dll_lock_value << DLL_TAP_VALUE_OFFSET;
 		sdhci_writel(host, extra, DECMSHC_EMMC_DLL_CMDOUT);
 	}
-
 	extra = DWCMSHC_EMMC_DLL_DLYENA |
 		DLL_TXCLK_TAPNUM_FROM_SW |
-		DLL_RXCLK_NO_INVERTER |
+		DLL_RXCLK_NO_INVERTER << DWCMSHC_EMMC_DLL_RXCLK_SRCSEL |
 		txclk_tapnum;
+	if (drv_data->flags & RK_TAP_VALUE_SEL)
+		extra |= DLL_TAP_VALUE_SEL | dll_lock_value << DLL_TAP_VALUE_OFFSET;
 	sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_TXCLK);
 
 	extra = DWCMSHC_EMMC_DLL_DLYENA |
-		DLL_STRBIN_TAPNUM_DEFAULT |
+		drv_data->hs400_strbin_tap |
 		DLL_STRBIN_TAPNUM_FROM_SW;
+	if (drv_data->flags & RK_TAP_VALUE_SEL)
+		extra |= DLL_TAP_VALUE_SEL | dll_lock_value << DLL_TAP_VALUE_OFFSET;
 	sdhci_writel(host, extra, DWCMSHC_EMMC_DLL_STRBIN);
+
+exit:
+	/* enable output clock */
+	sdhci_enable_clk(host, 0);
 }
 
-static void rockchip_sdhci_reset(struct sdhci_host *host, u8 mask)
+static void rk35xx_sdhci_reset(struct sdhci_host *host, u8 mask)
 {
-	struct sdhci_pltfm_host *pltfm_host;
-	struct dwcmshc_priv *priv;
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct dwcmshc_priv *dwc_priv = sdhci_pltfm_priv(pltfm_host);
+	struct rk35xx_priv *priv = dwc_priv->priv;
 
-	if (mask & SDHCI_RESET_ALL) {
-		pltfm_host = sdhci_priv(host);
-		priv = sdhci_pltfm_priv(pltfm_host);
-		if (!IS_ERR_OR_NULL(priv->reset)) {
-			reset_control_assert(priv->reset);
-			udelay(1);
-			reset_control_deassert(priv->reset);
-		}
+	if (mask & SDHCI_RESET_ALL && priv->reset) {
+		reset_control_assert(priv->reset);
+		udelay(1);
+		reset_control_deassert(priv->reset);
 	}
 
 	sdhci_reset(host, mask);
@@ -344,17 +394,17 @@ static const struct sdhci_ops sdhci_dwcm
 	.set_clock		= sdhci_set_clock,
 	.set_bus_width		= sdhci_set_bus_width,
 	.set_uhs_signaling	= dwcmshc_set_uhs_signaling,
-	.get_max_clock		= sdhci_pltfm_clk_get_max_clock,
+	.get_max_clock		= dwcmshc_get_max_clock,
 	.reset			= sdhci_reset,
 	.adma_write_desc	= dwcmshc_adma_write_desc,
 };
 
-static const struct sdhci_ops sdhci_dwcmshc_rk_ops = {
-	.set_clock		= dwcmshc_rk_set_clock,
+static const struct sdhci_ops sdhci_dwcmshc_rk35xx_ops = {
+	.set_clock		= dwcmshc_rk3568_set_clock,
 	.set_bus_width		= sdhci_set_bus_width,
 	.set_uhs_signaling	= dwcmshc_set_uhs_signaling,
 	.get_max_clock		= sdhci_pltfm_clk_get_max_clock,
-	.reset			= rockchip_sdhci_reset,
+	.reset			= rk35xx_sdhci_reset,
 	.adma_write_desc	= dwcmshc_adma_write_desc,
 	.request_done		= sdhci_dwcmshc_request_done,
 };
@@ -365,91 +415,165 @@ static const struct sdhci_pltfm_data sdh
 	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
 };
 
-static const struct sdhci_pltfm_data sdhci_dwcmshc_rk_pdata = {
-	.ops = &sdhci_dwcmshc_rk_ops,
-	.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
+#ifdef CONFIG_ACPI
+static const struct sdhci_pltfm_data sdhci_dwcmshc_bf3_pdata = {
+	.ops = &sdhci_dwcmshc_ops,
+	.quirks = SDHCI_QUIRK_CAP_CLOCK_BASE_BROKEN,
 	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
-		   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
-};
-
-static const struct dwcmshc_driver_data dwcmshc_drvdata = {
-	.pdata = &sdhci_dwcmshc_pdata,
-	.flags = 0,
-};
-
-static const struct dwcmshc_driver_data rk3568_drvdata = {
-	.pdata = &sdhci_dwcmshc_rk_pdata,
-	.flags = RK_PLATFROM | RK_RXCLK_NO_INVERTER,
+		   SDHCI_QUIRK2_ACMD23_BROKEN,
 };
+#endif
 
-static const struct dwcmshc_driver_data rk3588_drvdata = {
-	.pdata = &sdhci_dwcmshc_rk_pdata,
-	.flags = RK_PLATFROM | RK_DLL_CMD_OUT,
+static const struct sdhci_pltfm_data sdhci_dwcmshc_rk35xx_pdata = {
+	.ops = &sdhci_dwcmshc_rk35xx_ops,
+	.quirks = SDHCI_QUIRK_BROKEN_TIMEOUT_VAL,
+	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN |
+		   SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
 };
 
-static int rockchip_pltf_init(struct sdhci_host *host, struct dwcmshc_priv *priv)
+static int dwcmshc_rk35xx_init(struct sdhci_host *host, struct dwcmshc_priv *dwc_priv)
 {
 	int err;
+	struct rk35xx_priv *priv = dwc_priv->priv;
+
+	priv->reset = devm_reset_control_array_get_optional_exclusive(mmc_dev(host->mmc));
+	if (IS_ERR(priv->reset)) {
+		err = PTR_ERR(priv->reset);
+		dev_err(mmc_dev(host->mmc), "failed to get reset control %d\n", err);
+		return err;
+	}
 
 	priv->rockchip_clks[0].id = "axi";
 	priv->rockchip_clks[1].id = "block";
 	priv->rockchip_clks[2].id = "timer";
-	err = devm_clk_bulk_get_optional(mmc_dev(host->mmc), ROCKCHIP_MAX_CLKS,
+	err = devm_clk_bulk_get_optional(mmc_dev(host->mmc), RK35xx_MAX_CLKS,
 					 priv->rockchip_clks);
 	if (err) {
 		dev_err(mmc_dev(host->mmc), "failed to get clocks %d\n", err);
 		return err;
 	}
 
-	err = clk_bulk_prepare_enable(ROCKCHIP_MAX_CLKS, priv->rockchip_clks);
+	err = clk_bulk_prepare_enable(RK35xx_MAX_CLKS, priv->rockchip_clks);
 	if (err) {
 		dev_err(mmc_dev(host->mmc), "failed to enable clocks %d\n", err);
 		return err;
 	}
 
-	if (of_property_read_u32(mmc_dev(host->mmc)->of_node, "rockchip,txclk-tapnum",
-				 &priv->txclk_tapnum))
+	if (of_property_read_u8(mmc_dev(host->mmc)->of_node, "rockchip,txclk-tapnum",
+				&priv->txclk_tapnum))
 		priv->txclk_tapnum = DLL_TXCLK_TAPNUM_DEFAULT;
 
 	/* Disable cmd conflict check */
-	sdhci_writel(host, 0x0, DWCMSHC_HOST_CTRL3);
+	sdhci_writel(host, 0x0, dwc_priv->vendor_specific_area1 + DWCMSHC_HOST_CTRL3);
 	/* Reset previous settings */
 	sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_TXCLK);
 	sdhci_writel(host, 0, DWCMSHC_EMMC_DLL_STRBIN);
 
+	return 0;
+}
+
+static void dwcmshc_rk35xx_postinit(struct sdhci_host *host, struct dwcmshc_priv *dwc_priv)
+{
 	/*
 	 * Don't support highspeed bus mode with low clk speed as we
 	 * cannot use DLL for this condition.
 	 */
 	if (host->mmc->f_max <= 52000000) {
+		dev_info(mmc_dev(host->mmc), "Disabling HS200/HS400, frequency too low (%d)\n",
+			 host->mmc->f_max);
 		host->mmc->caps2 &= ~(MMC_CAP2_HS200 | MMC_CAP2_HS400);
 		host->mmc->caps &= ~(MMC_CAP_3_3V_DDR | MMC_CAP_1_8V_DDR);
 	}
-
-	return 0;
 }
 
+static const struct dwcmshc_driver_data dwcmshc_drvdata = {
+	.pdata = &sdhci_dwcmshc_pdata,
+	.flags = 0,
+};
+
+static const struct dwcmshc_driver_data rk3568_drvdata = {
+	.pdata = &sdhci_dwcmshc_rk35xx_pdata,
+	.flags = RK_PLATFROM | RK_RXCLK_NO_INVERTER,
+	.hs200_tx_tap = 16,
+	.hs400_tx_tap = 8,
+	.hs400_cmd_tap = 8,
+	.hs400_strbin_tap = 4,
+	.ddr50_strbin_delay_num = 16,
+};
+
+static const struct dwcmshc_driver_data rk3588_drvdata = {
+	.pdata = &sdhci_dwcmshc_rk35xx_pdata,
+	.flags = RK_PLATFROM | RK_DLL_CMD_OUT,
+	.hs200_tx_tap = 16,
+	.hs400_tx_tap = 9,
+	.hs400_cmd_tap = 8,
+	.hs400_strbin_tap = 4,
+	.ddr50_strbin_delay_num = 16,
+};
+
+static const struct dwcmshc_driver_data rk3528_drvdata = {
+	.pdata = &sdhci_dwcmshc_rk35xx_pdata,
+	.flags = RK_PLATFROM | RK_DLL_CMD_OUT | RK_TAP_VALUE_SEL,
+	.hs200_tx_tap = 12,
+	.hs400_tx_tap = 6,
+	.hs400_cmd_tap = 6,
+	.hs400_strbin_tap = 3,
+	.ddr50_strbin_delay_num = 10,
+};
+
+static const struct dwcmshc_driver_data rk3562_drvdata = {
+	.pdata = &sdhci_dwcmshc_rk35xx_pdata,
+	.flags = RK_PLATFROM | RK_DLL_CMD_OUT | RK_TAP_VALUE_SEL,
+	.hs200_tx_tap = 12,
+	.hs400_tx_tap = 6,
+	.hs400_cmd_tap = 6,
+	.hs400_strbin_tap = 3,
+	.ddr50_strbin_delay_num = 10,
+};
+
 static const struct of_device_id sdhci_dwcmshc_dt_ids[] = {
 	{
-		.compatible = "snps,dwcmshc-sdhci",
-		.data = &dwcmshc_drvdata,
+		.compatible = "rockchip,rk3588-dwcmshc",
+		.data = &rk3588_drvdata,
 	},
 	{
-		.compatible = "rockchip,dwcmshc-sdhci",
+		.compatible = "rockchip,rk3568-dwcmshc",
 		.data = &rk3568_drvdata,
 	},
 	{
-		.compatible = "rockchip,rk3588-dwcmshc",
-		.data = &rk3588_drvdata,
+		.compatible = "rockchip,rk3528-dwcmshc",
+		.data = &rk3528_drvdata,
+	},
+	{
+		.compatible = "rockchip,rk3562-dwcmshc",
+		.data = &rk3562_drvdata,
+	},
+	{
+		.compatible = "snps,dwcmshc-sdhci",
+		.data = &dwcmshc_drvdata,
 	},
 	{},
 };
+MODULE_DEVICE_TABLE(of, sdhci_dwcmshc_dt_ids);
+
+#ifdef CONFIG_ACPI
+static const struct acpi_device_id sdhci_dwcmshc_acpi_ids[] = {
+	{
+		.id = "MLNXBF30",
+		.driver_data = (kernel_ulong_t)&sdhci_dwcmshc_bf3_pdata,
+	},
+	{}
+};
+#endif
 
 static int dwcmshc_probe(struct platform_device *pdev)
 {
+	struct device *dev = &pdev->dev;
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_host *host;
 	struct dwcmshc_priv *priv;
+	struct rk35xx_priv *rk_priv = NULL;
+	const struct sdhci_pltfm_data *pltfm_data;
 	const struct dwcmshc_driver_data *drv_data;
 	struct mmc_hsq *hsq;
 	int err;
@@ -460,8 +584,9 @@ static int dwcmshc_probe(struct platform
 		dev_err(&pdev->dev, "Error: No device match data found\n");
 		return -ENODEV;
 	}
+	pltfm_data = drv_data->pdata;
 
-	host = sdhci_pltfm_init(pdev, drv_data->pdata,
+	host = sdhci_pltfm_init(pdev, pltfm_data,
 				sizeof(struct dwcmshc_priv));
 	if (IS_ERR(host))
 		return PTR_ERR(host);
@@ -469,7 +594,7 @@ static int dwcmshc_probe(struct platform
 	/*
 	 * extra adma table cnt for cross 128M boundary handling.
 	 */
-	extra = DIV_ROUND_UP_ULL(dma_get_required_mask(&pdev->dev), SZ_128M);
+	extra = DIV_ROUND_UP_ULL(dma_get_required_mask(dev), SZ_128M);
 	if (extra > SDHCI_MAX_SEGS)
 		extra = SDHCI_MAX_SEGS;
 	host->adma_table_cnt += extra;
@@ -477,21 +602,18 @@ static int dwcmshc_probe(struct platform
 	pltfm_host = sdhci_priv(host);
 	priv = sdhci_pltfm_priv(pltfm_host);
 
-	priv->acpi_en = has_acpi_companion(&pdev->dev);
-
-	if (!priv->acpi_en) {
-		priv->reset = devm_reset_control_array_get_exclusive(&pdev->dev);
-		pltfm_host->clk = devm_clk_get(&pdev->dev, "core");
+	if (dev->of_node) {
+		pltfm_host->clk = devm_clk_get(dev, "core");
 		if (IS_ERR(pltfm_host->clk)) {
 			err = PTR_ERR(pltfm_host->clk);
-			dev_err(&pdev->dev, "failed to get core clk: %d\n", err);
+			dev_err(dev, "failed to get core clk: %d\n", err);
 			goto free_pltfm;
 		}
 		err = clk_prepare_enable(pltfm_host->clk);
 		if (err)
 			goto free_pltfm;
 
-		priv->bus_clk = devm_clk_get(&pdev->dev, "bus");
+		priv->bus_clk = devm_clk_get(dev, "bus");
 		if (!IS_ERR(priv->bus_clk))
 			clk_prepare_enable(priv->bus_clk);
 	}
@@ -502,6 +624,9 @@ static int dwcmshc_probe(struct platform
 
 	sdhci_get_of_property(pdev);
 
+	priv->vendor_specific_area1 =
+		sdhci_readl(host, DWCMSHC_P_VENDOR_AREA1) & DWCMSHC_AREA1_MASK;
+
 	host->mmc_host_ops.request = dwcmshc_request;
 	host->mmc_host_ops.hs400_enhanced_strobe = dwcmshc_hs400_enhanced_strobe;
 
@@ -515,18 +640,42 @@ static int dwcmshc_probe(struct platform
 	if (err)
 		goto err_clk;
 
-	err = sdhci_add_host(host);
-	if (err)
-		goto err_clk;
-
-	priv->flags = drv_data->flags;
 	if (drv_data->flags & RK_PLATFROM) {
-		err = rockchip_pltf_init(host, priv);
+		rk_priv = devm_kzalloc(&pdev->dev, sizeof(struct rk35xx_priv), GFP_KERNEL);
+		if (!rk_priv) {
+			err = -ENOMEM;
+			goto err_clk;
+		}
+
+		rk_priv->drv_data = drv_data;
+		rk_priv->acpi_en = has_acpi_companion(&pdev->dev);
+
+		if (of_device_is_compatible(pdev->dev.of_node, "rockchip,rk3588-dwcmshc"))
+			rk_priv->devtype = DWCMSHC_RK3588;
+		else
+			rk_priv->devtype = DWCMSHC_RK3568;
+
+		priv->priv = rk_priv;
+
+		err = dwcmshc_rk35xx_init(host, priv);
 		if (err)
 			goto err_clk;
 	}
 
-	if (!priv->acpi_en) {
+	host->mmc->caps |= MMC_CAP_WAIT_WHILE_BUSY;
+
+	err = sdhci_setup_host(host);
+	if (err)
+		goto err_clk;
+
+	if (rk_priv)
+		dwcmshc_rk35xx_postinit(host, priv);
+
+	err = __sdhci_add_host(host);
+	if (err)
+		goto err_setup_host;
+
+	if (rk_priv && !rk_priv->acpi_en) {
 		pm_runtime_get_noresume(&pdev->dev);
 		pm_runtime_set_active(&pdev->dev);
 		pm_runtime_enable(&pdev->dev);
@@ -537,10 +686,14 @@ static int dwcmshc_probe(struct platform
 
 	return 0;
 
+err_setup_host:
+	sdhci_cleanup_host(host);
 err_clk:
 	clk_disable_unprepare(pltfm_host->clk);
 	clk_disable_unprepare(priv->bus_clk);
-	clk_bulk_disable_unprepare(ROCKCHIP_MAX_CLKS, priv->rockchip_clks);
+	if (rk_priv)
+		clk_bulk_disable_unprepare(RK35xx_MAX_CLKS,
+					   rk_priv->rockchip_clks);
 free_pltfm:
 	sdhci_pltfm_free(pdev);
 	return err;
@@ -551,13 +704,15 @@ static int dwcmshc_remove(struct platfor
 	struct sdhci_host *host = platform_get_drvdata(pdev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct rk35xx_priv *rk_priv = priv->priv;
 
 	sdhci_remove_host(host, 0);
 
 	clk_disable_unprepare(pltfm_host->clk);
 	clk_disable_unprepare(priv->bus_clk);
-	clk_bulk_disable_unprepare(ROCKCHIP_MAX_CLKS, priv->rockchip_clks);
-
+	if (rk_priv)
+		clk_bulk_disable_unprepare(RK35xx_MAX_CLKS,
+					   rk_priv->rockchip_clks);
 	sdhci_pltfm_free(pdev);
 
 	return 0;
@@ -569,6 +724,7 @@ static int dwcmshc_suspend(struct device
 	struct sdhci_host *host = dev_get_drvdata(dev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct rk35xx_priv *rk_priv = priv->priv;
 	int ret;
 
 	mmc_hsq_suspend(host->mmc);
@@ -581,7 +737,10 @@ static int dwcmshc_suspend(struct device
 	if (!IS_ERR(priv->bus_clk))
 		clk_disable_unprepare(priv->bus_clk);
 
-	clk_bulk_disable_unprepare(ROCKCHIP_MAX_CLKS, priv->rockchip_clks);
+	if (rk_priv)
+		clk_bulk_disable_unprepare(RK35xx_MAX_CLKS,
+					   rk_priv->rockchip_clks);
+
 	return ret;
 }
 
@@ -590,6 +749,7 @@ static int dwcmshc_resume(struct device
 	struct sdhci_host *host = dev_get_drvdata(dev);
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 	struct dwcmshc_priv *priv = sdhci_pltfm_priv(pltfm_host);
+	struct rk35xx_priv *rk_priv = priv->priv;
 	int ret;
 
 	ret = clk_prepare_enable(pltfm_host->clk);
@@ -602,9 +762,12 @@ static int dwcmshc_resume(struct device
 			return ret;
 	}
 
-	ret = clk_bulk_prepare_enable(ROCKCHIP_MAX_CLKS, priv->rockchip_clks);
-	if (ret)
-		return ret;
+	if (rk_priv) {
+		ret = clk_bulk_prepare_enable(RK35xx_MAX_CLKS,
+					      rk_priv->rockchip_clks);
+		if (ret)
+			return ret;
+	}
 
 	ret = sdhci_resume_host(host);
 	if (ret)
@@ -612,6 +775,7 @@ static int dwcmshc_resume(struct device
 
 	return mmc_hsq_resume(host->mmc);
 }
+#endif
 
 static int dwcmshc_runtime_suspend(struct device *dev)
 {
@@ -641,17 +805,14 @@ static const struct dev_pm_ops dwcmshc_p
 	SET_SYSTEM_SLEEP_PM_OPS(dwcmshc_suspend, dwcmshc_resume)
 	SET_RUNTIME_PM_OPS(dwcmshc_runtime_suspend, dwcmshc_runtime_resume, NULL)
 };
-MODULE_DEVICE_TABLE(of, sdhci_dwcmshc_dt_ids);
-#endif
 
 static struct platform_driver sdhci_dwcmshc_driver = {
 	.driver	= {
 		.name	= "sdhci-dwcmshc",
 		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 		.of_match_table = sdhci_dwcmshc_dt_ids,
-#ifdef CONFIG_PM_SLEEP
+		.acpi_match_table = ACPI_PTR(sdhci_dwcmshc_acpi_ids),
 		.pm = &dwcmshc_pmops,
-#endif
 	},
 	.probe	= dwcmshc_probe,
 	.remove	= dwcmshc_remove,
--- a/drivers/net/ethernet/stmicro/stmmac/Kconfig
+++ b/drivers/net/ethernet/stmicro/stmmac/Kconfig
@@ -25,6 +25,13 @@ config STMMAC_SELFTESTS
 	  feature if you are facing problems with your HW and submit the test
 	  results to the netdev Mailing List.
 
+config STMMAC_UIO
+	tristate "STMMAC_UIO ethernet controller"
+	default n
+	select UIO
+	help
+	  Say M here if you want to use the stmmac_uio.ko for DPDK.
+
 config STMMAC_ETHTOOL
 	bool "Ethtool feature for STMMAC"
 	default STMMAC_ETH if !ROCKCHIP_MINI_KERNEL
--- a/drivers/net/ethernet/stmicro/stmmac/Makefile
+++ b/drivers/net/ethernet/stmicro/stmmac/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_DWMAC_QCOM_ETHQOS)	+= dwmac
 obj-$(CONFIG_DWMAC_ROCKCHIP)	+= dwmac-rockchip.o
 dwmac-rockchip-objs := dwmac-rk.o
 dwmac-rockchip-$(CONFIG_DWMAC_ROCKCHIP_TOOL) += dwmac-rk-tool.o
+obj-$(CONFIG_STMMAC_UIO) += stmmac_uio.o
 obj-$(CONFIG_DWMAC_SOCFPGA)	+= dwmac-altr-socfpga.o
 obj-$(CONFIG_DWMAC_STI)		+= dwmac-sti.o
 obj-$(CONFIG_DWMAC_STM32)	+= dwmac-stm32.o
--- a/drivers/net/ethernet/stmicro/stmmac/altr_tse_pcs.c
+++ b/drivers/net/ethernet/stmicro/stmmac/altr_tse_pcs.c
@@ -57,10 +57,6 @@
 #define TSE_PCS_USE_SGMII_ENA				BIT(0)
 #define TSE_PCS_IF_USE_SGMII				0x03
 
-#define SGMII_ADAPTER_CTRL_REG				0x00
-#define SGMII_ADAPTER_DISABLE				0x0001
-#define SGMII_ADAPTER_ENABLE				0x0000
-
 #define AUTONEGO_LINK_TIMER				20
 
 static int tse_pcs_reset(void __iomem *base, struct tse_pcs *pcs)
@@ -202,12 +198,8 @@ void tse_pcs_fix_mac_speed(struct tse_pc
 			   unsigned int speed)
 {
 	void __iomem *tse_pcs_base = pcs->tse_pcs_base;
-	void __iomem *sgmii_adapter_base = pcs->sgmii_adapter_base;
 	u32 val;
 
-	writew(SGMII_ADAPTER_ENABLE,
-	       sgmii_adapter_base + SGMII_ADAPTER_CTRL_REG);
-
 	pcs->autoneg = phy_dev->autoneg;
 
 	if (phy_dev->autoneg == AUTONEG_ENABLE) {
--- a/drivers/net/ethernet/stmicro/stmmac/altr_tse_pcs.h
+++ b/drivers/net/ethernet/stmicro/stmmac/altr_tse_pcs.h
@@ -10,6 +10,10 @@
 #include <linux/phy.h>
 #include <linux/timer.h>
 
+#define SGMII_ADAPTER_CTRL_REG		0x00
+#define SGMII_ADAPTER_ENABLE		0x0000
+#define SGMII_ADAPTER_DISABLE		0x0001
+
 struct tse_pcs {
 	struct device *dev;
 	void __iomem *tse_pcs_base;
--- a/drivers/net/ethernet/stmicro/stmmac/common.h
+++ b/drivers/net/ethernet/stmicro/stmmac/common.h
@@ -48,10 +48,18 @@
  */
 #define DMA_MIN_TX_SIZE		64
 #define DMA_MAX_TX_SIZE		1024
+#if IS_ENABLED(CONFIG_STMMAC_UIO)
+#define DMA_DEFAULT_TX_SIZE	1024
+#else
 #define DMA_DEFAULT_TX_SIZE	512
+#endif
 #define DMA_MIN_RX_SIZE		64
 #define DMA_MAX_RX_SIZE		1024
+#if IS_ENABLED(CONFIG_STMMAC_UIO)
+#define DMA_DEFAULT_RX_SIZE	1024
+#else
 #define DMA_DEFAULT_RX_SIZE	512
+#endif
 #define STMMAC_GET_ENTRY(x, size)	((x + 1) & (size - 1))
 
 #undef FRAME_FILTER_DEBUG
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac-rk.c
@@ -78,7 +78,7 @@ struct rk_priv_data {
 	struct regmap *php_grf;
 	struct regmap *xpcs;
 
-	unsigned char otp_data[4];
+	unsigned char otp_data;
 };
 
 /* XPCS */
@@ -221,6 +221,12 @@ static int xpcs_setup(struct rk_priv_dat
 	((((tx) >= 0) ? soc##_GMAC_CLK_TX_DL_CFG(tx) : 0) | \
 	 (((rx) >= 0) ? soc##_GMAC_CLK_RX_DL_CFG(rx) : 0))
 
+#define GMAC_RGMII_CLK_DIV_BY_ID(soc, id, div) \
+		(soc##_GMAC##id##_CLK_RGMII_DIV##div)
+
+#define GMAC_RMII_CLK_DIV_BY_ID(soc, id, div) \
+		(soc##_GMAC##id##_CLK_RMII_DIV##div)
+
 /* Integrated EPHY */
 
 #define RK_GRF_MACPHY_CON0		0xb00
@@ -264,6 +270,52 @@ static void rk_gmac_integrated_ephy_powe
 		reset_control_assert(priv->phy_reset);
 }
 
+/* Integrated FEPHY */
+#define RK_FEPHY_SHUTDOWN		GRF_BIT(1)
+#define RK_FEPHY_POWERUP		GRF_CLR_BIT(1)
+#define RK_FEPHY_INTERNAL_RMII_SEL	GRF_BIT(6)
+#define RK_FEPHY_24M_CLK_SEL		(GRF_BIT(8) | GRF_BIT(9))
+#define RK_FEPHY_PHY_ID			GRF_BIT(11)
+
+#define RK_FEPHY_BGS			HIWORD_UPDATE(0x0, 0xf, 0)
+
+static void rk_gmac_integrated_fephy_power(struct rk_priv_data *priv,
+					   unsigned int ctrl_offset,
+					   unsigned int bgs_offset,
+					   bool up)
+{
+	struct device *dev = &priv->pdev->dev;
+
+	if (IS_ERR(priv->grf) || !priv->phy_reset) {
+		dev_err(dev, "%s: Missing rockchip,grf or phy_reset property\n",
+			__func__);
+		return;
+	}
+
+	if (up) {
+		unsigned int bgs = RK_FEPHY_BGS;
+
+		reset_control_assert(priv->phy_reset);
+		udelay(20);
+		regmap_write(priv->grf, ctrl_offset,
+			     RK_FEPHY_POWERUP |
+			     RK_FEPHY_INTERNAL_RMII_SEL |
+			     RK_FEPHY_24M_CLK_SEL |
+			     RK_FEPHY_PHY_ID);
+
+		if (priv->otp_data > 0)
+			bgs = HIWORD_UPDATE(priv->otp_data, 0xf, 0);
+
+		regmap_write(priv->grf, bgs_offset, bgs);
+		usleep_range(10 * 1000, 12 * 1000);
+		reset_control_deassert(priv->phy_reset);
+		usleep_range(50 * 1000, 60 * 1000);
+	} else {
+		regmap_write(priv->grf, ctrl_offset,
+			     RK_FEPHY_SHUTDOWN);
+	}
+}
+
 #define PX30_GRF_GMAC_CON1		0x0904
 
 /* PX30_GRF_GMAC_CON1 */
@@ -1320,6 +1372,360 @@ static const struct rk_gmac_ops rk3399_o
 	.set_rmii_speed = rk3399_set_rmii_speed,
 };
 
+#define RK3528_VO_GRF_GMAC_CON		0X60018
+#define RK3528_VPU_GRF_GMAC_CON5	0X40018
+#define RK3528_VPU_GRF_GMAC_CON6	0X4001c
+
+#define RK3528_GMAC_RXCLK_DLY_ENABLE	GRF_BIT(15)
+#define RK3528_GMAC_RXCLK_DLY_DISABLE	GRF_CLR_BIT(15)
+#define RK3528_GMAC_TXCLK_DLY_ENABLE	GRF_BIT(14)
+#define RK3528_GMAC_TXCLK_DLY_DISABLE	GRF_CLR_BIT(14)
+
+#define RK3528_GMAC_CLK_RX_DL_CFG(val)	HIWORD_UPDATE(val, 0xFF, 8)
+#define RK3528_GMAC_CLK_TX_DL_CFG(val)	HIWORD_UPDATE(val, 0xFF, 0)
+
+#define RK3528_GMAC0_PHY_INTF_SEL_RMII	GRF_BIT(1)
+#define RK3528_GMAC1_PHY_INTF_SEL_RGMII	GRF_CLR_BIT(8)
+#define RK3528_GMAC1_PHY_INTF_SEL_RMII	GRF_BIT(8)
+
+#define RK3528_GMAC1_CLK_SELET_CRU	GRF_CLR_BIT(12)
+#define RK3528_GMAC1_CLK_SELET_IO	GRF_BIT(12)
+
+#define RK3528_GMAC0_CLK_RMII_DIV2	GRF_BIT(3)
+#define RK3528_GMAC0_CLK_RMII_DIV20	GRF_CLR_BIT(3)
+#define RK3528_GMAC1_CLK_RMII_DIV2	GRF_BIT(10)
+#define RK3528_GMAC1_CLK_RMII_DIV20	GRF_CLR_BIT(10)
+
+#define RK3528_GMAC1_CLK_RGMII_DIV1		\
+			(GRF_CLR_BIT(11) | GRF_CLR_BIT(10))
+#define RK3528_GMAC1_CLK_RGMII_DIV5		\
+			(GRF_BIT(11) | GRF_BIT(10))
+#define RK3528_GMAC1_CLK_RGMII_DIV50		\
+			(GRF_BIT(11) | GRF_CLR_BIT(10))
+
+#define RK3528_GMAC0_CLK_RMII_GATE	GRF_BIT(2)
+#define RK3528_GMAC0_CLK_RMII_NOGATE	GRF_CLR_BIT(2)
+#define RK3528_GMAC1_CLK_RMII_GATE	GRF_BIT(9)
+#define RK3528_GMAC1_CLK_RMII_NOGATE	GRF_CLR_BIT(9)
+
+#define RK3528_VO_GRF_MACPHY_CON0		0X6001c
+#define RK3528_VO_GRF_MACPHY_CON1		0X60020
+
+static void rk3528_set_to_rgmii(struct rk_priv_data *bsp_priv,
+				int tx_delay, int rx_delay)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+
+	if (IS_ERR(bsp_priv->grf)) {
+		dev_err(dev, "Missing rockchip,grf property\n");
+		return;
+	}
+
+	regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON5,
+		     RK3528_GMAC1_PHY_INTF_SEL_RGMII);
+
+	regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON5,
+		     DELAY_ENABLE(RK3528, tx_delay, rx_delay));
+
+	regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON6,
+		     DELAY_VALUE(RK3528, tx_delay, rx_delay));
+}
+
+static void rk3528_set_to_rmii(struct rk_priv_data *bsp_priv)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int id = bsp_priv->bus_id;
+
+	if (IS_ERR(bsp_priv->grf)) {
+		dev_err(dev, "%s: Missing rockchip,grf property\n", __func__);
+		return;
+	}
+
+	if (id == 1)
+		regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON5,
+			     RK3528_GMAC1_PHY_INTF_SEL_RMII);
+	else
+		regmap_write(bsp_priv->grf, RK3528_VO_GRF_GMAC_CON,
+			     RK3528_GMAC0_PHY_INTF_SEL_RMII);
+}
+
+static void rk3528_set_rgmii_speed(struct rk_priv_data *bsp_priv, int speed)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int val = 0;
+
+	switch (speed) {
+	case 10:
+		val = RK3528_GMAC1_CLK_RGMII_DIV50;
+		break;
+	case 100:
+		val = RK3528_GMAC1_CLK_RGMII_DIV5;
+		break;
+	case 1000:
+		val = RK3528_GMAC1_CLK_RGMII_DIV1;
+		break;
+	default:
+		goto err;
+	}
+
+	regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON5, val);
+	return;
+err:
+	dev_err(dev, "unknown RGMII speed value for GMAC speed=%d", speed);
+}
+
+static void rk3528_set_rmii_speed(struct rk_priv_data *bsp_priv, int speed)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int val, offset, id = bsp_priv->bus_id;
+
+	switch (speed) {
+	case 10:
+		val = (id == 1) ? RK3528_GMAC1_CLK_RMII_DIV20 :
+				  RK3528_GMAC0_CLK_RMII_DIV20;
+		break;
+	case 100:
+		val = (id == 1) ? RK3528_GMAC1_CLK_RMII_DIV2 :
+				  RK3528_GMAC0_CLK_RMII_DIV2;
+		break;
+	default:
+		goto err;
+	}
+
+	offset = (id == 1) ? RK3528_VPU_GRF_GMAC_CON5 : RK3528_VO_GRF_GMAC_CON;
+	regmap_write(bsp_priv->grf, offset, val);
+
+	return;
+err:
+	dev_err(dev, "unknown RMII speed value for GMAC speed=%d", speed);
+}
+
+static void rk3528_set_clock_selection(struct rk_priv_data *bsp_priv,
+				       bool input, bool enable)
+{
+	unsigned int value, id = bsp_priv->bus_id;
+
+	if (id == 1) {
+		value = input ? RK3528_GMAC1_CLK_SELET_IO :
+				RK3528_GMAC1_CLK_SELET_CRU;
+		value |= enable ? RK3528_GMAC1_CLK_RMII_NOGATE :
+				  RK3528_GMAC1_CLK_RMII_GATE;
+		regmap_write(bsp_priv->grf, RK3528_VPU_GRF_GMAC_CON5, value);
+	} else {
+		value = enable ? RK3528_GMAC0_CLK_RMII_NOGATE :
+				 RK3528_GMAC0_CLK_RMII_GATE;
+		regmap_write(bsp_priv->grf, RK3528_VO_GRF_GMAC_CON, value);
+	}
+}
+
+static void rk3528_integrated_sphy_power(struct rk_priv_data *priv, bool up)
+{
+	rk_gmac_integrated_fephy_power(priv, RK3528_VO_GRF_MACPHY_CON0,
+				       RK3528_VO_GRF_MACPHY_CON1, up);
+}
+
+static const struct rk_gmac_ops rk3528_ops = {
+	.set_to_rgmii = rk3528_set_to_rgmii,
+	.set_to_rmii = rk3528_set_to_rmii,
+	.set_rgmii_speed = rk3528_set_rgmii_speed,
+	.set_rmii_speed = rk3528_set_rmii_speed,
+	.set_clock_selection = rk3528_set_clock_selection,
+	.integrated_phy_power = rk3528_integrated_sphy_power,
+};
+
+/* sys_grf */
+#define RK3562_GRF_SYS_SOC_CON0			0X0400
+#define RK3562_GRF_SYS_SOC_CON1			0X0404
+
+#define RK3562_GMAC0_CLK_RMII_MODE		GRF_BIT(5)
+#define RK3562_GMAC0_CLK_RGMII_MODE		GRF_CLR_BIT(5)
+
+#define RK3562_GMAC0_CLK_RMII_GATE		GRF_BIT(6)
+#define RK3562_GMAC0_CLK_RMII_NOGATE		GRF_CLR_BIT(6)
+
+#define RK3562_GMAC0_CLK_RMII_DIV2		GRF_BIT(7)
+#define RK3562_GMAC0_CLK_RMII_DIV20		GRF_CLR_BIT(7)
+
+#define RK3562_GMAC0_CLK_RGMII_DIV1		\
+				(GRF_CLR_BIT(7) | GRF_CLR_BIT(8))
+#define RK3562_GMAC0_CLK_RGMII_DIV5		\
+				(GRF_BIT(7) | GRF_BIT(8))
+#define RK3562_GMAC0_CLK_RGMII_DIV50		\
+				(GRF_CLR_BIT(7) | GRF_BIT(8))
+
+#define RK3562_GMAC0_CLK_RMII_DIV2		GRF_BIT(7)
+#define RK3562_GMAC0_CLK_RMII_DIV20		GRF_CLR_BIT(7)
+
+#define RK3562_GMAC0_CLK_SELET_CRU		GRF_CLR_BIT(9)
+#define RK3562_GMAC0_CLK_SELET_IO		GRF_BIT(9)
+
+#define RK3562_GMAC1_CLK_RMII_GATE		GRF_BIT(12)
+#define RK3562_GMAC1_CLK_RMII_NOGATE		GRF_CLR_BIT(12)
+
+#define RK3562_GMAC1_CLK_RMII_DIV2		GRF_BIT(13)
+#define RK3562_GMAC1_CLK_RMII_DIV20		GRF_CLR_BIT(13)
+
+#define RK3562_GMAC1_RMII_SPEED100		GRF_BIT(11)
+#define RK3562_GMAC1_RMII_SPEED10		GRF_CLR_BIT(11)
+
+#define RK3562_GMAC1_CLK_SELET_CRU		GRF_CLR_BIT(15)
+#define RK3562_GMAC1_CLK_SELET_IO		GRF_BIT(15)
+
+/* ioc_grf */
+#define RK3562_GRF_IOC_GMAC_IOFUNC0_CON0	0X10400
+#define RK3562_GRF_IOC_GMAC_IOFUNC0_CON1	0X10404
+#define RK3562_GRF_IOC_GMAC_IOFUNC1_CON0	0X00400
+#define RK3562_GRF_IOC_GMAC_IOFUNC1_CON1	0X00404
+
+#define RK3562_GMAC_RXCLK_DLY_ENABLE		GRF_BIT(1)
+#define RK3562_GMAC_RXCLK_DLY_DISABLE		GRF_CLR_BIT(1)
+#define RK3562_GMAC_TXCLK_DLY_ENABLE		GRF_BIT(0)
+#define RK3562_GMAC_TXCLK_DLY_DISABLE		GRF_CLR_BIT(0)
+
+#define RK3562_GMAC_CLK_RX_DL_CFG(val)		HIWORD_UPDATE(val, 0xFF, 8)
+#define RK3562_GMAC_CLK_TX_DL_CFG(val)		HIWORD_UPDATE(val, 0xFF, 0)
+
+#define RK3562_GMAC0_IO_EXTCLK_SELET_CRU	GRF_CLR_BIT(2)
+#define RK3562_GMAC0_IO_EXTCLK_SELET_IO		GRF_BIT(2)
+
+#define RK3562_GMAC1_IO_EXTCLK_SELET_CRU	GRF_CLR_BIT(3)
+#define RK3562_GMAC1_IO_EXTCLK_SELET_IO		GRF_BIT(3)
+
+static void rk3562_set_to_rgmii(struct rk_priv_data *bsp_priv,
+				int tx_delay, int rx_delay)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+
+	if (IS_ERR(bsp_priv->grf) || IS_ERR(bsp_priv->php_grf)) {
+		dev_err(dev, "Missing rockchip,grf or rockchip,php_grf property\n");
+		return;
+	}
+
+	if (bsp_priv->bus_id > 0)
+		return;
+
+	regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON0,
+		     RK3562_GMAC0_CLK_RGMII_MODE);
+
+	regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC0_CON1,
+		     DELAY_ENABLE(RK3562, tx_delay, rx_delay));
+	regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC0_CON0,
+		     DELAY_VALUE(RK3562, tx_delay, rx_delay));
+
+	regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC1_CON1,
+		     DELAY_ENABLE(RK3562, tx_delay, rx_delay));
+	regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC1_CON0,
+		     DELAY_VALUE(RK3562, tx_delay, rx_delay));
+}
+
+static void rk3562_set_to_rmii(struct rk_priv_data *bsp_priv)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+
+	if (IS_ERR(bsp_priv->grf)) {
+		dev_err(dev, "%s: Missing rockchip,grf property\n", __func__);
+		return;
+	}
+
+	if (!bsp_priv->bus_id)
+		regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON0,
+			     RK3562_GMAC0_CLK_RMII_MODE);
+}
+
+static void rk3562_set_gmac_speed(struct rk_priv_data *bsp_priv, int speed)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int val = 0, offset, id = bsp_priv->bus_id;
+
+	switch (speed) {
+	case 10:
+		if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {
+			if (id > 0) {
+				val = GMAC_RMII_CLK_DIV_BY_ID(RK3562, 1, 20);
+				regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON0,
+					     RK3562_GMAC1_RMII_SPEED10);
+			} else {
+				val = GMAC_RMII_CLK_DIV_BY_ID(RK3562, 0, 20);
+			}
+		} else {
+			val = GMAC_RGMII_CLK_DIV_BY_ID(RK3562, 0, 50);
+		}
+		break;
+	case 100:
+		if (bsp_priv->phy_iface == PHY_INTERFACE_MODE_RMII) {
+			if (id > 0) {
+				val = GMAC_RMII_CLK_DIV_BY_ID(RK3562, 1, 2);
+				regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON0,
+					     RK3562_GMAC1_RMII_SPEED100);
+			} else {
+				val = GMAC_RMII_CLK_DIV_BY_ID(RK3562, 0, 2);
+			}
+		} else {
+			val = GMAC_RGMII_CLK_DIV_BY_ID(RK3562, 0, 5);
+		}
+		break;
+	case 1000:
+		if (bsp_priv->phy_iface != PHY_INTERFACE_MODE_RMII)
+			val = GMAC_RGMII_CLK_DIV_BY_ID(RK3562, 0, 1);
+		else
+			goto err;
+		break;
+	default:
+		goto err;
+	}
+
+	offset = (bsp_priv->bus_id > 0) ? RK3562_GRF_SYS_SOC_CON1 :
+					  RK3562_GRF_SYS_SOC_CON0;
+	regmap_write(bsp_priv->grf, offset, val);
+
+	return;
+err:
+	dev_err(dev, "unknown speed value for GMAC speed=%d", speed);
+}
+
+static void rk3562_set_clock_selection(struct rk_priv_data *bsp_priv, bool input,
+				       bool enable)
+{
+	struct device *dev = &bsp_priv->pdev->dev;
+	unsigned int value;
+
+	if (IS_ERR(bsp_priv->grf) || IS_ERR(bsp_priv->php_grf)) {
+		dev_err(dev, "Missing rockchip,grf or rockchip,php_grf property\n");
+		return;
+	}
+
+	if (!bsp_priv->bus_id) {
+		value = input ? RK3562_GMAC0_CLK_SELET_IO :
+				RK3562_GMAC0_CLK_SELET_CRU;
+		value |= enable ? RK3562_GMAC0_CLK_RMII_NOGATE :
+				  RK3562_GMAC0_CLK_RMII_GATE;
+		regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON0, value);
+
+		value = input ? RK3562_GMAC0_IO_EXTCLK_SELET_IO :
+				RK3562_GMAC0_IO_EXTCLK_SELET_CRU;
+		regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC0_CON1, value);
+		regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC1_CON1, value);
+	} else {
+		value = input ? RK3562_GMAC1_CLK_SELET_IO :
+				RK3562_GMAC1_CLK_SELET_CRU;
+		value |= enable ? RK3562_GMAC1_CLK_RMII_NOGATE :
+				 RK3562_GMAC1_CLK_RMII_GATE;
+		regmap_write(bsp_priv->grf, RK3562_GRF_SYS_SOC_CON1, value);
+
+		value = input ? RK3562_GMAC1_IO_EXTCLK_SELET_IO :
+				RK3562_GMAC1_IO_EXTCLK_SELET_CRU;
+		regmap_write(bsp_priv->php_grf, RK3562_GRF_IOC_GMAC_IOFUNC1_CON1, value);
+	}
+}
+
+static const struct rk_gmac_ops rk3562_ops = {
+	.set_to_rgmii = rk3562_set_to_rgmii,
+	.set_to_rmii = rk3562_set_to_rmii,
+	.set_rgmii_speed = rk3562_set_gmac_speed,
+	.set_rmii_speed = rk3562_set_gmac_speed,
+	.set_clock_selection = rk3562_set_clock_selection,
+};
+
 #define RK3568_GRF_GMAC0_CON0		0X0380
 #define RK3568_GRF_GMAC0_CON1		0X0384
 #define RK3568_GRF_GMAC1_CON0		0X0388
@@ -1604,17 +2010,8 @@ static const struct rk_gmac_ops rk3588_o
 #define RV1106_VOGRF_GMAC_CLK_RMII_DIV20	GRF_CLR_BIT(2)
 
 #define RV1106_VOGRF_MACPHY_CON0		0X60028
-
-#define RV1106_VOGRF_MACPHY_SHUTDOWN		GRF_BIT(1)
-#define RV1106_VOGRF_MACPHY_POWERUP		GRF_CLR_BIT(1)
-#define RV1106_VOGRF_MACPHY_INTERNAL_RMII_SEL	GRF_BIT(6)
-#define RV1106_VOGRF_MACPHY_24M_CLK_SEL		(GRF_BIT(8) | GRF_BIT(9))
-#define RV1106_VOGRF_MACPHY_PHY_ID		GRF_BIT(11)
-
 #define RV1106_VOGRF_MACPHY_CON1		0X6002C
 
-#define RV1106_VOGRF_MACPHY_BGS			HIWORD_UPDATE(0x0, 0xf, 0)
-
 static void rv1106_set_to_rmii(struct rk_priv_data *bsp_priv)
 {
 	struct device *dev = &bsp_priv->pdev->dev;
@@ -1652,36 +2049,8 @@ static void rv1106_set_rmii_speed(struct
 
 static void rv1106_integrated_sphy_power(struct rk_priv_data *priv, bool up)
 {
-	struct device *dev = &priv->pdev->dev;
-
-	if (IS_ERR(priv->grf) || !priv->phy_reset) {
-		dev_err(dev, "%s: Missing rockchip,grf or phy_reset property\n",
-			__func__);
-		return;
-	}
-
-	if (up) {
-		unsigned int bgs = RV1106_VOGRF_MACPHY_BGS;
-
-		reset_control_assert(priv->phy_reset);
-		udelay(20);
-		regmap_write(priv->grf, RV1106_VOGRF_MACPHY_CON0,
-			     RV1106_VOGRF_MACPHY_POWERUP |
-			     RV1106_VOGRF_MACPHY_INTERNAL_RMII_SEL |
-			     RV1106_VOGRF_MACPHY_24M_CLK_SEL |
-			     RV1106_VOGRF_MACPHY_PHY_ID);
-
-		if (priv->otp_data[0] > 0)
-			bgs = HIWORD_UPDATE(priv->otp_data[0], 0xf, 0);
-
-		regmap_write(priv->grf, RV1106_VOGRF_MACPHY_CON1, bgs);
-		usleep_range(10 * 1000, 12 * 1000);
-		reset_control_deassert(priv->phy_reset);
-		usleep_range(50 * 1000, 60 * 1000);
-	} else {
-		regmap_write(priv->grf, RV1106_VOGRF_MACPHY_CON0,
-			     RV1106_VOGRF_MACPHY_SHUTDOWN);
-	}
+	rk_gmac_integrated_fephy_power(priv, RV1106_VOGRF_MACPHY_CON0,
+				       RV1106_VOGRF_MACPHY_CON1, up);
 }
 
 static const struct rk_gmac_ops rv1106_ops = {
@@ -2186,14 +2555,17 @@ static struct rk_priv_data *rk_gmac_setu
 			/* Read bgs from OTP if it exists */
 			cell = nvmem_cell_get(dev, "bgs");
 			if (IS_ERR(cell)) {
-				dev_info(dev, "failed to get bgs cell: %ld, use default\n",
-					 PTR_ERR(cell));
+				if (PTR_ERR(cell) != -EPROBE_DEFER)
+					dev_info(dev, "failed to get bgs cell: %ld, use default\n",
+						 PTR_ERR(cell));
+				else
+					return ERR_CAST(cell);
 			} else {
 				efuse_buf = nvmem_cell_read(cell, &len);
 				nvmem_cell_put(cell);
 				if (!IS_ERR(efuse_buf)) {
 					if (len == 1)
-						bsp_priv->otp_data[0] = efuse_buf[0];
+						bsp_priv->otp_data = efuse_buf[0];
 					kfree(efuse_buf);
 				} else {
 					dev_err(dev, "failed to get efuse buf, use default\n");
@@ -2526,6 +2898,12 @@ static const struct of_device_id rk_gmac
 #ifdef CONFIG_CPU_RK3399
 	{ .compatible = "rockchip,rk3399-gmac", .data = &rk3399_ops },
 #endif
+#ifdef CONFIG_CPU_RK3528
+	{ .compatible = "rockchip,rk3528-gmac", .data = &rk3528_ops },
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{ .compatible = "rockchip,rk3562-gmac", .data = &rk3562_ops },
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{ .compatible = "rockchip,rk3568-gmac", .data = &rk3568_ops },
 #endif
--- a/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
+++ b/drivers/net/ethernet/stmicro/stmmac/dwmac4_core.c
@@ -215,6 +215,9 @@ static void dwmac4_map_mtl_dma(struct ma
 	if (queue == 0 || queue == 4) {
 		value &= ~MTL_RXQ_DMA_Q04MDMACH_MASK;
 		value |= MTL_RXQ_DMA_Q04MDMACH(chan);
+	} else if (queue > 4) {
+		value &= ~MTL_RXQ_DMA_QXMDMACH_MASK(queue - 4);
+		value |= MTL_RXQ_DMA_QXMDMACH(chan, queue - 4);
 	} else {
 		value &= ~MTL_RXQ_DMA_QXMDMACH_MASK(queue);
 		value |= MTL_RXQ_DMA_QXMDMACH(chan, queue);
@@ -665,6 +668,8 @@ static void dwmac4_flow_ctrl(struct mac_
 	if (fc & FLOW_RX) {
 		pr_debug("\tReceive Flow-Control ON\n");
 		flow |= GMAC_RX_FLOW_CTRL_RFE;
+	} else {
+		pr_debug("\tReceive Flow-Control OFF\n");
 	}
 	writel(flow, ioaddr + GMAC_RX_FLOW_CTRL);
 
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_hwtstamp.c
@@ -68,9 +68,9 @@ static int init_systime(void __iomem *io
 	writel(value, ioaddr + PTP_TCR);
 
 	/* wait for present system time initialize to complete */
-	return readl_poll_timeout(ioaddr + PTP_TCR, value,
+	return readl_poll_timeout_atomic(ioaddr + PTP_TCR, value,
 				 !(value & PTP_TCR_TSINIT),
-				 10000, 100000);
+				 10, 100000);
 }
 
 static int config_addend(void __iomem *ioaddr, u32 addend)
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -738,19 +738,10 @@ int stmmac_init_tstamp_counter(struct st
 	struct timespec64 now;
 	u32 sec_inc = 0;
 	u64 temp = 0;
-	int ret;
 
 	if (!(priv->dma_cap.time_stamp || priv->dma_cap.atime_stamp))
 		return -EOPNOTSUPP;
 
-	ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
-	if (ret < 0) {
-		netdev_warn(priv->dev,
-			    "failed to enable PTP reference clock: %pe\n",
-			    ERR_PTR(ret));
-		return ret;
-	}
-
 	stmmac_config_hw_tstamping(priv, priv->ptpaddr, systime_flags);
 	priv->systime_flags = systime_flags;
 
@@ -1052,8 +1043,16 @@ static void stmmac_mac_link_up(struct ph
 		ctrl |= priv->hw->link.duplex;
 
 	/* Flow Control operation */
-	if (tx_pause && rx_pause)
-		stmmac_mac_flow_ctrl(priv, duplex);
+	if (rx_pause && tx_pause)
+		priv->flow_ctrl = FLOW_AUTO;
+	else if (rx_pause && !tx_pause)
+		priv->flow_ctrl = FLOW_RX;
+	else if (!rx_pause && tx_pause)
+		priv->flow_ctrl = FLOW_TX;
+	else
+		priv->flow_ctrl = FLOW_OFF;
+
+	stmmac_mac_flow_ctrl(priv, duplex);
 
 	writel(ctrl, priv->ioaddr + MAC_CTRL_REG);
 
@@ -2766,6 +2765,14 @@ static int stmmac_hw_setup(struct net_de
 
 	stmmac_mmc_setup(priv);
 
+	if (ptp_register) {
+		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
+		if (ret < 0)
+			netdev_warn(priv->dev,
+				    "failed to enable PTP reference clock: %pe\n",
+				    ERR_PTR(ret));
+	}
+
 	ret = stmmac_init_ptp(priv);
 	if (ret == -EOPNOTSUPP)
 		netdev_warn(priv->dev, "PTP not supported by HW\n");
@@ -2927,6 +2934,15 @@ static int stmmac_open(struct net_device
 		goto init_error;
 	}
 
+	if (priv->plat->serdes_powerup) {
+		ret = priv->plat->serdes_powerup(dev, priv->plat->bsp_priv);
+		if (ret < 0) {
+			netdev_err(priv->dev, "%s: Serdes powerup failed\n",
+				   __func__);
+			goto init_error;
+		}
+	}
+
 	ret = stmmac_hw_setup(dev, true);
 	if (ret < 0) {
 		netdev_err(priv->dev, "%s: Hw setup failed\n", __func__);
@@ -3045,6 +3061,10 @@ static int stmmac_release(struct net_dev
 	/* Disable the MAC Rx/Tx */
 	stmmac_mac_set(priv, priv->ioaddr, false);
 
+	/* Powerdown Serdes if there is */
+	if (priv->plat->serdes_powerdown)
+		priv->plat->serdes_powerdown(dev, priv->plat->bsp_priv);
+
 	netif_carrier_off(dev);
 
 	stmmac_release_ptp(priv);
@@ -5075,7 +5095,7 @@ int stmmac_dvr_probe(struct device *devi
 		dev_info(priv->device, "TSO feature enabled\n");
 	}
 
-	if (priv->dma_cap.sphen) {
+	if (priv->dma_cap.sphen && !priv->plat->sph_disable) {
 		ndev->hw_features |= NETIF_F_GRO;
 		if (!priv->plat->sph_disable) {
 			priv->sph = true;
@@ -5210,14 +5230,6 @@ int stmmac_dvr_probe(struct device *devi
 		goto error_netdev_register;
 	}
 
-	if (priv->plat->serdes_powerup) {
-		ret = priv->plat->serdes_powerup(ndev,
-						 priv->plat->bsp_priv);
-
-		if (ret < 0)
-			goto error_serdes_powerup;
-	}
-
 #ifdef CONFIG_DEBUG_FS
 	stmmac_init_fs(ndev);
 #endif
@@ -5229,8 +5241,6 @@ int stmmac_dvr_probe(struct device *devi
 
 	return ret;
 
-error_serdes_powerup:
-	unregister_netdev(ndev);
 error_netdev_register:
 	phylink_destroy(priv->phylink);
 error_phy_setup:
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_mdio.c
@@ -396,6 +396,7 @@ int stmmac_mdio_reset(struct mii_bus *bu
 #endif
 	return 0;
 }
+EXPORT_SYMBOL(stmmac_mdio_reset);
 
 /**
  * stmmac_mdio_register
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_pci.c
@@ -175,7 +175,7 @@ static int stmmac_pci_probe(struct pci_d
 		return -ENOMEM;
 
 	/* Enable pci device */
-	ret = pci_enable_device(pdev);
+	ret = pcim_enable_device(pdev);
 	if (ret) {
 		dev_err(&pdev->dev, "%s: ERROR: failed to enable device\n",
 			__func__);
@@ -227,8 +227,6 @@ static void stmmac_pci_remove(struct pci
 		pcim_iounmap_regions(pdev, BIT(i));
 		break;
 	}
-
-	pci_disable_device(pdev);
 }
 
 static int __maybe_unused stmmac_pci_suspend(struct device *dev)
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
@@ -108,10 +108,10 @@ static struct stmmac_axi *stmmac_axi_set
 
 	axi->axi_lpi_en = of_property_read_bool(np, "snps,lpi_en");
 	axi->axi_xit_frm = of_property_read_bool(np, "snps,xit_frm");
-	axi->axi_kbbe = of_property_read_bool(np, "snps,axi_kbbe");
-	axi->axi_fb = of_property_read_bool(np, "snps,axi_fb");
-	axi->axi_mb = of_property_read_bool(np, "snps,axi_mb");
-	axi->axi_rb =  of_property_read_bool(np, "snps,axi_rb");
+	axi->axi_kbbe = of_property_read_bool(np, "snps,kbbe");
+	axi->axi_fb = of_property_read_bool(np, "snps,fb");
+	axi->axi_mb = of_property_read_bool(np, "snps,mb");
+	axi->axi_rb =  of_property_read_bool(np, "snps,rb");
 
 	if (of_property_read_u32(np, "snps,wr_osr_lmt", &axi->axi_wr_osr_lmt))
 		axi->axi_wr_osr_lmt = 1;
@@ -432,8 +432,7 @@ stmmac_probe_config_dt(struct platform_d
 	plat->phylink_node = np;
 
 	/* Get max speed of operation from device tree */
-	if (of_property_read_u32(np, "max-speed", &plat->max_speed))
-		plat->max_speed = -1;
+	of_property_read_u32(np, "max-speed", &plat->max_speed);
 
 	plat->bus_id = of_alias_get_id(np, "ethernet");
 	if (plat->bus_id < 0)
@@ -620,12 +619,6 @@ stmmac_probe_config_dt(struct platform_d
 		plat->stmmac_rst = NULL;
 	}
 
-	plat->stmmac_ahb_rst = devm_reset_control_get_optional_shared(
-							&pdev->dev, "ahb");
-	if (IS_ERR(plat->stmmac_ahb_rst))
-		if (PTR_ERR(plat->stmmac_ahb_rst) == -EPROBE_DEFER)
-			goto error_hw_init;
-
 	return plat;
 
 error_hw_init:
@@ -824,7 +817,13 @@ static int __maybe_unused stmmac_pltfr_n
 		if (ret)
 			return ret;
 
-		stmmac_init_tstamp_counter(priv, priv->systime_flags);
+		ret = clk_prepare_enable(priv->plat->clk_ptp_ref);
+		if (ret < 0) {
+			netdev_warn(priv->dev,
+				    "failed to enable PTP reference clock: %pe\n",
+				    ERR_PTR(ret));
+			return ret;
+		}
 	}
 
 	return 0;
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_selftests.c
@@ -1084,8 +1084,9 @@ static int stmmac_test_rxp(struct stmmac
 	unsigned char addr[ETH_ALEN] = {0xde, 0xad, 0xbe, 0xef, 0x00, 0x00};
 	struct tc_cls_u32_offload cls_u32 = { };
 	struct stmmac_packet_attrs attr = { };
-	struct tc_action **actions, *act;
+	struct tc_action **actions;
 	struct tc_u32_sel *sel;
+	struct tcf_gact *gact;
 	struct tcf_exts *exts;
 	int ret, i, nk = 1;
 
@@ -1104,14 +1105,14 @@ static int stmmac_test_rxp(struct stmmac
 		goto cleanup_sel;
 	}
 
-	actions = kzalloc(nk * sizeof(*actions), GFP_KERNEL);
+	actions = kcalloc(nk, sizeof(*actions), GFP_KERNEL);
 	if (!actions) {
 		ret = -ENOMEM;
 		goto cleanup_exts;
 	}
 
-	act = kzalloc(nk * sizeof(*act), GFP_KERNEL);
-	if (!act) {
+	gact = kcalloc(nk, sizeof(*gact), GFP_KERNEL);
+	if (!gact) {
 		ret = -ENOMEM;
 		goto cleanup_actions;
 	}
@@ -1126,9 +1127,7 @@ static int stmmac_test_rxp(struct stmmac
 	exts->nr_actions = nk;
 	exts->actions = actions;
 	for (i = 0; i < nk; i++) {
-		struct tcf_gact *gact = to_gact(&act[i]);
-
-		actions[i] = &act[i];
+		actions[i] = (struct tc_action *)&gact[i];
 		gact->tcf_action = TC_ACT_SHOT;
 	}
 
@@ -1152,7 +1151,7 @@ static int stmmac_test_rxp(struct stmmac
 	stmmac_tc_setup_cls_u32(priv, priv, &cls_u32);
 
 cleanup_act:
-	kfree(act);
+	kfree(gact);
 cleanup_actions:
 	kfree(actions);
 cleanup_exts:
--- a/drivers/nvmem/rockchip-otp.c
+++ b/drivers/nvmem/rockchip-otp.c
@@ -761,6 +761,28 @@ static const struct rockchip_data px30s_
 	.reg_read = px30s_otp_read,
 };
 
+static const char * const rk3528_otp_clocks[] = {
+	"usr", "sbpi", "apb",
+};
+
+static const struct rockchip_data rk3528_data = {
+	.size = 0x80,
+	.clocks = rk3528_otp_clocks,
+	.num_clks = ARRAY_SIZE(rk3528_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
+static const char * const rk3562_otp_clocks[] = {
+	"usr", "sbpi", "apb", "arb", "phy",
+};
+
+static const struct rockchip_data rk3562_data = {
+	.size = 0x80,
+	.clocks = rk3562_otp_clocks,
+	.num_clks = ARRAY_SIZE(rk3562_otp_clocks),
+	.reg_read = rk3568_otp_read,
+};
+
 static const char * const rk3568_otp_clocks[] = {
 	"usr", "sbpi", "apb", "phy",
 };
@@ -828,6 +850,18 @@ static const struct of_device_id rockchi
 		.data = (void *)&px30s_data,
 	},
 #endif
+#ifdef CONFIG_CPU_RK3528
+	{
+		.compatible = "rockchip,rk3528-otp",
+		.data = (void *)&rk3528_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{
+		.compatible = "rockchip,rk3562-otp",
+		.data = (void *)&rk3562_data,
+	},
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{
 		.compatible = "rockchip,rk3568-otp",
--- a/drivers/pci/controller/dwc/pcie-designware-host.c
+++ b/drivers/pci/controller/dwc/pcie-designware-host.c
@@ -61,7 +61,7 @@ irqreturn_t dw_handle_msi_irq(struct pci
 	irqreturn_t ret = IRQ_NONE;
 	struct dw_pcie *pci = to_dw_pcie_from_pp(pp);
 
-	num_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;
+	num_ctrls = DIV_ROUND_UP(pp->num_vectors, MAX_MSI_IRQS_PER_CTRL);
 
 	for (i = 0; i < num_ctrls; i++) {
 		status = dw_pcie_readl_dbi(pci, PCIE_MSI_INTR0_STATUS +
@@ -84,6 +84,7 @@ irqreturn_t dw_handle_msi_irq(struct pci
 
 	return ret;
 }
+EXPORT_SYMBOL_GPL(dw_handle_msi_irq);
 
 /* Chained MSI interrupt service routine */
 static void dw_chained_msi_isr(struct irq_desc *desc)
@@ -465,9 +466,7 @@ static void __iomem *dw_pcie_other_conf_
 		type = PCIE_ATU_TYPE_CFG1;
 
 
-	dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX1,
-				  type, pp->cfg0_base,
-				  busdev, pp->cfg0_size);
+	dw_pcie_prog_outbound_atu(pci, 0, type, pp->cfg0_base, busdev, pp->cfg0_size);
 
 	return pp->va_cfg0_base + where;
 }
@@ -481,9 +480,8 @@ static int dw_pcie_rd_other_conf(struct
 
 	ret = pci_generic_config_read(bus, devfn, where, size, val);
 
-	if (!ret && pci->num_viewport <= 2)
-		dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX1,
-					  PCIE_ATU_TYPE_IO, pp->io_base,
+	if (!ret && (pci->iatu_unroll_enabled & DWC_IATU_IOCFG_SHARED))
+		dw_pcie_prog_outbound_atu(pci, 0, PCIE_ATU_TYPE_IO, pp->io_base,
 					  pp->io_bus_addr, pp->io_size);
 
 	return ret;
@@ -498,9 +496,8 @@ static int dw_pcie_wr_other_conf(struct
 
 	ret = pci_generic_config_write(bus, devfn, where, size, val);
 
-	if (!ret && pci->num_viewport <= 2)
-		dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX1,
-					  PCIE_ATU_TYPE_IO, pp->io_base,
+	if (!ret && (pci->iatu_unroll_enabled & DWC_IATU_IOCFG_SHARED))
+		dw_pcie_prog_outbound_atu(pci, 0, PCIE_ATU_TYPE_IO, pp->io_base,
 					  pp->io_bus_addr, pp->io_size);
 
 	return ret;
@@ -544,7 +541,7 @@ void dw_pcie_setup_rc(struct pcie_port *
 	dw_pcie_setup(pci);
 
 	if (pci_msi_enabled() && !pp->ops->msi_host_init) {
-		num_ctrls = pp->num_vectors / MAX_MSI_IRQS_PER_CTRL;
+		num_ctrls = DIV_ROUND_UP(pp->num_vectors, MAX_MSI_IRQS_PER_CTRL);
 
 		/* Initialize IRQ Status array */
 		for (ctrl = 0; ctrl < num_ctrls; ctrl++) {
@@ -587,21 +584,35 @@ void dw_pcie_setup_rc(struct pcie_port *
 	 * ATU, so we should not program the ATU here.
 	 */
 	if (pp->bridge->child_ops == &dw_child_pcie_ops) {
-		struct resource_entry *tmp, *entry = NULL;
+		int atu_idx = 0;
+		struct resource_entry *entry;
 
 		/* Get last memory resource entry */
-		resource_list_for_each_entry(tmp, &pp->bridge->windows)
-			if (resource_type(tmp->res) == IORESOURCE_MEM)
-				entry = tmp;
-
-		dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX0,
-					  PCIE_ATU_TYPE_MEM, entry->res->start,
-					  entry->res->start - entry->offset,
-					  resource_size(entry->res));
-		if (pci->num_viewport > 2)
-			dw_pcie_prog_outbound_atu(pci, PCIE_ATU_REGION_INDEX2,
-						  PCIE_ATU_TYPE_IO, pp->io_base,
-						  pp->io_bus_addr, pp->io_size);
+		resource_list_for_each_entry(entry, &pp->bridge->windows) {
+			if (resource_type(entry->res) != IORESOURCE_MEM)
+				continue;
+
+			if (pci->num_viewport <= ++atu_idx)
+				break;
+
+			dw_pcie_prog_outbound_atu(pci, atu_idx,
+						  PCIE_ATU_TYPE_MEM, entry->res->start,
+						  entry->res->start - entry->offset,
+						  resource_size(entry->res));
+		}
+
+		if (pp->io_size) {
+			if (pci->num_viewport > ++atu_idx)
+				dw_pcie_prog_outbound_atu(pci, atu_idx,
+							  PCIE_ATU_TYPE_IO, pp->io_base,
+							  pp->io_bus_addr, pp->io_size);
+			else
+				pci->iatu_unroll_enabled |= DWC_IATU_IOCFG_SHARED;
+		}
+
+		if (pci->num_viewport <= atu_idx)
+			dev_warn(pci->dev, "Resources exceed number of ATU entries (%d)",
+				 pci->num_viewport);
 	}
 
 	dw_pcie_writel_dbi(pci, PCI_BASE_ADDRESS_0, 0);
--- a/drivers/pci/controller/dwc/pcie-designware.c
+++ b/drivers/pci/controller/dwc/pcie-designware.c
@@ -274,7 +274,7 @@ static void __dw_pcie_prog_outbound_atu(
 	if (pci->ops->cpu_addr_fixup)
 		cpu_addr = pci->ops->cpu_addr_fixup(pci, cpu_addr);
 
-	if (pci->iatu_unroll_enabled) {
+	if (pci->iatu_unroll_enabled & DWC_IATU_UNROLL_EN) {
 		dw_pcie_prog_outbound_atu_unroll(pci, func_no, index, type,
 						 cpu_addr, pci_addr, size);
 		return;
@@ -394,7 +394,7 @@ int dw_pcie_prog_inbound_atu(struct dw_p
 	int type;
 	u32 retries, val;
 
-	if (pci->iatu_unroll_enabled)
+	if (pci->iatu_unroll_enabled & DWC_IATU_UNROLL_EN)
 		return dw_pcie_prog_inbound_atu_unroll(pci, func_no, index, bar,
 						       cpu_addr, as_type);
 
@@ -496,6 +496,7 @@ int dw_pcie_link_up(struct dw_pcie *pci)
 	return ((val & PCIE_PORT_DEBUG1_LINK_UP) &&
 		(!(val & PCIE_PORT_DEBUG1_LINK_IN_TRAINING)));
 }
+EXPORT_SYMBOL_GPL(dw_pcie_link_up);
 
 void dw_pcie_upconfig_setup(struct dw_pcie *pci)
 {
@@ -563,14 +564,15 @@ void dw_pcie_setup(struct dw_pcie *pci)
 
 	if (pci->version >= 0x480A || (!pci->version &&
 				       dw_pcie_iatu_unroll_enabled(pci))) {
-		pci->iatu_unroll_enabled = true;
+		pci->iatu_unroll_enabled |= DWC_IATU_UNROLL_EN;
 		if (!pci->atu_base)
 			pci->atu_base =
 			    devm_platform_ioremap_resource_byname(pdev, "atu");
 		if (IS_ERR(pci->atu_base))
 			pci->atu_base = pci->dbi_base + DEFAULT_DBI_ATU_OFFSET;
 	}
-	dev_dbg(pci->dev, "iATU unroll: %s\n", pci->iatu_unroll_enabled ?
+	dev_dbg(pci->dev, "iATU unroll: %s\n",
+		pci->iatu_unroll_enabled & DWC_IATU_UNROLL_EN ?
 		"enabled" : "disabled");
 
 	if (pci->link_gen > 0)
@@ -589,7 +591,7 @@ void dw_pcie_setup(struct dw_pcie *pci)
 	if (pci->n_fts[1]) {
 		val = dw_pcie_readl_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL);
 		val &= ~PORT_LOGIC_N_FTS_MASK;
-		val |= pci->n_fts[1];
+		val |= pci->n_fts[pci->link_gen - 1];
 		dw_pcie_writel_dbi(pci, PCIE_LINK_WIDTH_SPEED_CONTROL, val);
 	}
 
--- a/drivers/pci/controller/dwc/pcie-designware.h
+++ b/drivers/pci/controller/dwc/pcie-designware.h
@@ -81,9 +81,6 @@
 #define PCIE_ATU_VIEWPORT		0x900
 #define PCIE_ATU_REGION_INBOUND		BIT(31)
 #define PCIE_ATU_REGION_OUTBOUND	0
-#define PCIE_ATU_REGION_INDEX2		0x2
-#define PCIE_ATU_REGION_INDEX1		0x1
-#define PCIE_ATU_REGION_INDEX0		0x0
 #define PCIE_ATU_CR1			0x904
 #define PCIE_ATU_TYPE_MEM		0x0
 #define PCIE_ATU_TYPE_IO		0x2
@@ -260,6 +257,8 @@ struct dw_pcie_ops {
 	void	(*stop_link)(struct dw_pcie *pcie);
 };
 
+#define DWC_IATU_UNROLL_EN	BIT(0)
+#define DWC_IATU_IOCFG_SHARED	BIT(1)
 struct dw_pcie {
 	struct device		*dev;
 	void __iomem		*dbi_base;
--- a/drivers/phy/rockchip/Kconfig
+++ b/drivers/phy/rockchip/Kconfig
@@ -2,6 +2,16 @@
 #
 # Phy drivers for Rockchip platforms
 #
+
+config PHY_ROCKCHIP_CSI2_DPHY
+	tristate "Rockchip CSI2 D-PHY Driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on ARCH_ROCKCHIP && OF
+	select GENERIC_PHY
+	select V4L2_FWNODE
+	help
+	  Enable this to support the Rockchip CSI2 DPHY.
+
 config PHY_ROCKCHIP_DP
 	tristate "Rockchip Display Port PHY Driver"
 	depends on ARCH_ROCKCHIP && OF
@@ -55,6 +65,14 @@ config PHY_ROCKCHIP_INNO_USB2
 	help
 	  Support for Rockchip USB2.0 PHY with Innosilicon IP block.
 
+config PHY_ROCKCHIP_INNO_USB3
+	tristate "Rockchip INNO USB 3.0 PHY Driver"
+	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
+	select GENERIC_PHY
+	select USB_PHY
+	help
+	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
+
 config PHY_ROCKCHIP_INNO_DSIDPHY
 	tristate "Rockchip Innosilicon MIPI/LVDS/TTL PHY driver"
 	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
@@ -64,14 +82,14 @@ config PHY_ROCKCHIP_INNO_DSIDPHY
 	  Enable this to support the Rockchip MIPI/LVDS/TTL PHY with
 	  Innosilicon IP block.
 
-config PHY_ROCKCHIP_INNO_USB3
-	tristate "Rockchip INNO USB 3.0 PHY Driver"
-	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
-	depends on USB_SUPPORT
+config PHY_ROCKCHIP_MIPI_RX
+	tristate "Rockchip MIPI RX D-PHY Driver"
+	depends on VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	depends on ARCH_ROCKCHIP && OF
 	select GENERIC_PHY
-	select USB_PHY
+	select V4L2_FWNODE
 	help
-	  Support for Rockchip USB 3.0 PHY with Innosilicon IP block.
+	  Enable this to support the Rockchip MIPI D-PHY with Synopsys or Innosilicon IP block.
 
 config PHY_ROCKCHIP_NANENG_COMBO_PHY
 	tristate "Rockchip NANENG COMBO PHY Driver"
@@ -108,6 +126,29 @@ config PHY_ROCKCHIP_PCIE
 	help
 	  Enable this to support the Rockchip PCIe PHY.
 
+config PHY_ROCKCHIP_SAMSUNG_DCPHY
+	tristate "Rockchip Samsung MIPI DCPHY driver"
+	depends on (ARCH_ROCKCHIP || COMPILE_TEST) && OF
+	select GENERIC_PHY
+	select GENERIC_PHY_MIPI_DPHY
+	help
+	  Enable this to support the Rockchip MIPI DCPHY with
+	  Samsung IP block.
+
+config PHY_ROCKCHIP_SAMSUNG_HDPTX
+	tristate "Rockchip Samsung HDMI/DP Combo PHY driver"
+	depends on OF && (ARCH_ROCKCHIP || COMPILE_TEST)
+	select GENERIC_PHY
+	help
+	  Support for Rockchip HDMI/DP Combo PHY with Samsung IP block.
+
+config PHY_ROCKCHIP_SAMSUNG_HDPTX_HDMI
+	tristate "Rockchip Samsung HDMI/DP Combo PHY HDMI driver"
+	depends on OF && (ARCH_ROCKCHIP || COMPILE_TEST)
+	select GENERIC_PHY
+	help
+	  Support for Rockchip HDMI/DP Combo PHY with Samsung IP block.
+
 config PHY_ROCKCHIP_SNPS_PCIE3
 	tristate "Rockchip Snps PCIe3 PHY Driver"
 	depends on (ARCH_ROCKCHIP && OF) || COMPILE_TEST
@@ -123,6 +164,7 @@ config PHY_ROCKCHIP_TYPEC
 	select EXTCON
 	select GENERIC_PHY
 	select RESET_CONTROLLER
+	select TYPEC
 	help
 	  Enable this to support the Rockchip USB TYPEC PHY.
 
--- a/drivers/phy/rockchip/Makefile
+++ b/drivers/phy/rockchip/Makefile
@@ -1,16 +1,22 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_PHY_ROCKCHIP_CSI2_DPHY)	+= phy-rockchip-csi2-dphy-hw.o \
+					   phy-rockchip-csi2-dphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_DP)		+= phy-rockchip-dp.o
 obj-$(CONFIG_PHY_ROCKCHIP_DPHY_RX0)     += phy-rockchip-dphy-rx0.o
 obj-$(CONFIG_PHY_ROCKCHIP_EMMC)		+= phy-rockchip-emmc.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_COMBPHY)	+= phy-rockchip-inno-combphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_DSIDPHY)	+= phy-rockchip-inno-dsidphy.o
-obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi.o
+obj-$(CONFIG_PHY_ROCKCHIP_INNO_HDMI)	+= phy-rockchip-inno-hdmi-phy.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB2)	+= phy-rockchip-inno-usb2.o
 obj-$(CONFIG_PHY_ROCKCHIP_INNO_USB3)	+= phy-rockchip-inno-usb3.o
+obj-$(CONFIG_PHY_ROCKCHIP_MIPI_RX)	+= phy-rockchip-mipi-rx.o
 obj-$(CONFIG_PHY_ROCKCHIP_NANENG_COMBO_PHY)	+= phy-rockchip-naneng-combphy.o
 obj-$(CONFIG_PHY_ROCKCHIP_NANENG_EDP)	+= phy-rockchip-naneng-edp.o
 obj-$(CONFIG_PHY_ROCKCHIP_NANENG_USB2)	+= phy-rockchip-naneng-usb2.o
 obj-$(CONFIG_PHY_ROCKCHIP_PCIE)		+= phy-rockchip-pcie.o
+obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_DCPHY)	+= phy-rockchip-samsung-dcphy.o
+obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX)	+= phy-rockchip-samsung-hdptx.o
+obj-$(CONFIG_PHY_ROCKCHIP_SAMSUNG_HDPTX_HDMI)	+= phy-rockchip-samsung-hdptx-hdmi.o
 obj-$(CONFIG_PHY_ROCKCHIP_SNPS_PCIE3)	+= phy-rockchip-snps-pcie3.o
 obj-$(CONFIG_PHY_ROCKCHIP_TYPEC)	+= phy-rockchip-typec.o
 obj-$(CONFIG_PHY_ROCKCHIP_USB)		+= phy-rockchip-usb.o
--- a/drivers/phy/rockchip/phy-rockchip-inno-dsidphy.c
+++ b/drivers/phy/rockchip/phy-rockchip-inno-dsidphy.c
@@ -19,6 +19,7 @@
 #include <linux/phy/phy-mipi-dphy.h>
 #include <linux/pm_runtime.h>
 #include <linux/mfd/syscon.h>
+#include <linux/rockchip/cpu.h>
 
 #define PSEC_PER_SEC	1000000000000LL
 
@@ -83,9 +84,31 @@
 #define DATA_LANE_0_SKEW_PHASE_MASK		GENMASK(2, 0)
 #define DATA_LANE_0_SKEW_PHASE(x)		UPDATE(x, 2, 0)
 /* Analog Register Part: reg08 */
+#define PRE_EMPHASIS_ENABLE_MASK		BIT(7)
+#define PRE_EMPHASIS_ENABLE			BIT(7)
+#define PRE_EMPHASIS_DISABLE			0
+#define PLL_POST_DIV_ENABLE_MASK		BIT(5)
+#define PLL_POST_DIV_ENABLE			BIT(5)
+#define PLL_POST_DIV_DISABLE			0
+#define DATA_LANE_VOD_RANGE_SET_MASK		GENMASK(3, 0)
+#define DATA_LANE_VOD_RANGE_SET(x)		UPDATE(x, 3, 0)
 #define SAMPLE_CLOCK_DIRECTION_MASK		BIT(4)
 #define SAMPLE_CLOCK_DIRECTION_REVERSE		BIT(4)
 #define SAMPLE_CLOCK_DIRECTION_FORWARD		0
+#define LOWFRE_EN_MASK                          BIT(5)
+#define PLL_OUTPUT_FREQUENCY_DIV_BY_1           0
+#define PLL_OUTPUT_FREQUENCY_DIV_BY_2           1
+/* Analog Register Part: reg1e */
+#define PLL_MODE_SEL_MASK			GENMASK(6, 5)
+#define PLL_MODE_SEL_LVDS_MODE			0
+#define PLL_MODE_SEL_MIPI_MODE			BIT(5)
+/* Analog Register Part: reg0b */
+#define CLOCK_LANE_VOD_RANGE_SET_MASK	GENMASK(3, 0)
+#define CLOCK_LANE_VOD_RANGE_SET(x)	UPDATE(x, 3, 0)
+#define VOD_MIN_RANGE			0x1
+#define VOD_MID_RANGE			0x3
+#define VOD_BIG_RANGE			0x7
+#define VOD_MAX_RANGE			0xf
 /* Digital Register Part: reg00 */
 #define REG_DIG_RSTN_MASK			BIT(0)
 #define REG_DIG_RSTN_NORMAL			BIT(0)
@@ -101,20 +124,22 @@
 #define T_LPX_CNT_MASK				GENMASK(5, 0)
 #define T_LPX_CNT(x)				UPDATE(x, 5, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg06 */
+#define T_HS_ZERO_CNT_HI_MASK			BIT(7)
+#define T_HS_ZERO_CNT_HI(x)			UPDATE(x, 7, 7)
 #define T_HS_PREPARE_CNT_MASK			GENMASK(6, 0)
 #define T_HS_PREPARE_CNT(x)			UPDATE(x, 6, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg07 */
-#define T_HS_ZERO_CNT_MASK			GENMASK(5, 0)
-#define T_HS_ZERO_CNT(x)			UPDATE(x, 5, 0)
+#define T_HS_ZERO_CNT_LO_MASK			GENMASK(5, 0)
+#define T_HS_ZERO_CNT_LO(x)			UPDATE(x, 5, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg08 */
 #define T_HS_TRAIL_CNT_MASK			GENMASK(6, 0)
 #define T_HS_TRAIL_CNT(x)			UPDATE(x, 6, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg09 */
-#define T_HS_EXIT_CNT_MASK			GENMASK(4, 0)
-#define T_HS_EXIT_CNT(x)			UPDATE(x, 4, 0)
+#define T_HS_EXIT_CNT_LO_MASK			GENMASK(4, 0)
+#define T_HS_EXIT_CNT_LO(x)			UPDATE(x, 4, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0a */
-#define T_CLK_POST_CNT_MASK			GENMASK(3, 0)
-#define T_CLK_POST_CNT(x)			UPDATE(x, 3, 0)
+#define T_CLK_POST_CNT_LO_MASK			GENMASK(3, 0)
+#define T_CLK_POST_CNT_LO(x)			UPDATE(x, 3, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg0c */
 #define LPDT_TX_PPI_SYNC_MASK			BIT(2)
 #define LPDT_TX_PPI_SYNC_ENABLE			BIT(2)
@@ -128,9 +153,13 @@
 #define T_CLK_PRE_CNT_MASK			GENMASK(3, 0)
 #define T_CLK_PRE_CNT(x)			UPDATE(x, 3, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg10 */
+#define T_CLK_POST_HI_MASK			GENMASK(7, 6)
+#define T_CLK_POST_HI(x)			UPDATE(x, 7, 6)
 #define T_TA_GO_CNT_MASK			GENMASK(5, 0)
 #define T_TA_GO_CNT(x)				UPDATE(x, 5, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg11 */
+#define T_HS_EXIT_CNT_HI_MASK			BIT(6)
+#define T_HS_EXIT_CNT_HI(x)			UPDATE(x, 6, 6)
 #define T_TA_SURE_CNT_MASK			GENMASK(5, 0)
 #define T_TA_SURE_CNT(x)			UPDATE(x, 5, 0)
 /* Clock/Data0/Data1/Data2/Data3 Lane Register Part: reg12 */
@@ -168,6 +197,30 @@
 #define DSI_PHY_STATUS		0xb0
 #define PHY_LOCK		BIT(0)
 
+enum soc_type {
+	PX30,
+	PX30S,
+	RK3128,
+	RK3368,
+	RK3562,
+	RK3568,
+	RV1126,
+};
+
+enum phy_max_rate {
+	MAX_1GHZ,
+	MAX_2_5GHZ,
+};
+
+struct inno_mipi_dphy_timing {
+	unsigned int max_lane_mbps;
+	u8 lpx;
+	u8 hs_prepare;
+	u8 clk_lane_hs_zero;
+	u8 data_lane_hs_zero;
+	u8 hs_trail;
+};
+
 struct inno_dsidphy {
 	struct device *dev;
 	struct clk *ref_clk;
@@ -176,8 +229,9 @@ struct inno_dsidphy {
 	void __iomem *phy_base;
 	void __iomem *host_base;
 	struct reset_control *rst;
-	enum phy_mode mode;
 	struct phy_configure_opts_mipi_dphy dphy_cfg;
+	unsigned int lanes;
+	const struct inno_dsidphy_plat_data *pdata;
 
 	struct clk *pll_clk;
 	struct {
@@ -188,6 +242,13 @@ struct inno_dsidphy {
 	} pll;
 };
 
+struct inno_dsidphy_plat_data {
+	enum soc_type soc_type;
+	const struct inno_mipi_dphy_timing *inno_mipi_dphy_timing_table;
+	const unsigned int num_timings;
+	enum phy_max_rate max_rate;
+};
+
 enum {
 	REGISTER_PART_ANALOG,
 	REGISTER_PART_DIGITAL,
@@ -199,6 +260,44 @@ enum {
 	REGISTER_PART_LVDS,
 };
 
+static const
+struct inno_mipi_dphy_timing inno_mipi_dphy_timing_table_max_1GHz[] = {
+	{ 110, 0x0, 0x20, 0x16, 0x02, 0x22},
+	{ 150, 0x0, 0x06, 0x16, 0x03, 0x45},
+	{ 200, 0x0, 0x18, 0x17, 0x04, 0x0b},
+	{ 250, 0x0, 0x05, 0x17, 0x05, 0x16},
+	{ 300, 0x0, 0x51, 0x18, 0x06, 0x2c},
+	{ 400, 0x0, 0x64, 0x19, 0x07, 0x33},
+	{ 500, 0x0, 0x20, 0x1b, 0x07, 0x4e},
+	{ 600, 0x0, 0x6a, 0x1d, 0x08, 0x3a},
+	{ 700, 0x0, 0x3e, 0x1e, 0x08, 0x6a},
+	{ 800, 0x0, 0x21, 0x1f, 0x09, 0x29},
+	{1000, 0x0, 0x09, 0x20, 0x09, 0x27},
+};
+
+static const
+struct inno_mipi_dphy_timing inno_mipi_dphy_timing_table_max_2_5GHz[] = {
+	{ 110, 0x02, 0x7f, 0x16, 0x02, 0x02},
+	{ 150, 0x02, 0x7f, 0x16, 0x03, 0x02},
+	{ 200, 0x02, 0x7f, 0x17, 0x04, 0x02},
+	{ 250, 0x02, 0x7f, 0x17, 0x05, 0x04},
+	{ 300, 0x02, 0x7f, 0x18, 0x06, 0x04},
+	{ 400, 0x03, 0x7e, 0x19, 0x07, 0x04},
+	{ 500, 0x03, 0x7c, 0x1b, 0x07, 0x08},
+	{ 600, 0x03, 0x70, 0x1d, 0x08, 0x10},
+	{ 700, 0x05, 0x40, 0x1e, 0x08, 0x30},
+	{ 800, 0x05, 0x02, 0x1f, 0x09, 0x30},
+	{1000, 0x05, 0x08, 0x20, 0x09, 0x30},
+	{1200, 0x06, 0x03, 0x32, 0x14, 0x0f},
+	{1400, 0x09, 0x03, 0x32, 0x14, 0x0f},
+	{1600, 0x0d, 0x42, 0x36, 0x0e, 0x0f},
+	{1800, 0x0e, 0x47, 0x7a, 0x0e, 0x0f},
+	{2000, 0x11, 0x64, 0x7a, 0x0e, 0x0b},
+	{2200, 0x13, 0x64, 0x7e, 0x15, 0x0b},
+	{2400, 0x13, 0x33, 0x7f, 0x15, 0x6a},
+	{2500, 0x15, 0x54, 0x7f, 0x15, 0x6a},
+};
+
 static inline struct inno_dsidphy *hw_to_inno(struct clk_hw *hw)
 {
 	return container_of(hw, struct inno_dsidphy, pll.hw);
@@ -216,6 +315,17 @@ static void phy_update_bits(struct inno_
 	writel(tmp, inno->phy_base + reg);
 }
 
+static void host_update_bits(struct inno_dsidphy *inno,
+			     u32 reg, u32 mask, u32 val)
+{
+	unsigned int tmp, orig;
+
+	orig = readl(inno->host_base + reg);
+	tmp = orig & ~mask;
+	tmp |= val & mask;
+	writel(tmp, inno->host_base + reg);
+}
+
 static unsigned long inno_dsidphy_pll_calc_rate(struct inno_dsidphy *inno,
 						unsigned long rate)
 {
@@ -286,39 +396,48 @@ static unsigned long inno_dsidphy_pll_ca
 	return best_freq;
 }
 
-static void inno_dsidphy_mipi_mode_enable(struct inno_dsidphy *inno)
+static const struct inno_mipi_dphy_timing *
+inno_mipi_dphy_get_timing(struct inno_dsidphy *inno)
 {
-	struct phy_configure_opts_mipi_dphy *cfg = &inno->dphy_cfg;
-	const struct {
-		unsigned long rate;
-		u8 hs_prepare;
-		u8 clk_lane_hs_zero;
-		u8 data_lane_hs_zero;
-		u8 hs_trail;
-	} timings[] = {
-		{ 110000000, 0x20, 0x16, 0x02, 0x22},
-		{ 150000000, 0x06, 0x16, 0x03, 0x45},
-		{ 200000000, 0x18, 0x17, 0x04, 0x0b},
-		{ 250000000, 0x05, 0x17, 0x05, 0x16},
-		{ 300000000, 0x51, 0x18, 0x06, 0x2c},
-		{ 400000000, 0x64, 0x19, 0x07, 0x33},
-		{ 500000000, 0x20, 0x1b, 0x07, 0x4e},
-		{ 600000000, 0x6a, 0x1d, 0x08, 0x3a},
-		{ 700000000, 0x3e, 0x1e, 0x08, 0x6a},
-		{ 800000000, 0x21, 0x1f, 0x09, 0x29},
-		{1000000000, 0x09, 0x20, 0x09, 0x27},
-	};
-	u32 t_txbyteclkhs, t_txclkesc;
-	u32 txbyteclkhs, txclkesc, esc_clk_div;
-	u32 hs_exit, clk_post, clk_pre, wakeup, lpx, ta_go, ta_sure, ta_wait;
-	u32 hs_prepare, hs_trail, hs_zero, clk_lane_hs_zero, data_lane_hs_zero;
+	const struct inno_mipi_dphy_timing *timings;
+	unsigned int num_timings;
+	unsigned int lane_mbps = inno->pll.rate / USEC_PER_SEC;
 	unsigned int i;
 
-	inno_dsidphy_pll_calc_rate(inno, cfg->hs_clk_rate);
+	timings = inno->pdata->inno_mipi_dphy_timing_table;
+	num_timings = inno->pdata->num_timings;
 
-	/* Select MIPI mode */
-	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
-			MODE_ENABLE_MASK, MIPI_MODE_ENABLE);
+	for (i = 0; i < num_timings; i++)
+		if (lane_mbps <= timings[i].max_lane_mbps)
+			break;
+
+	if (i == num_timings)
+		--i;
+
+	return &timings[i];
+}
+
+static void inno_mipi_dphy_max_2_5GHz_pll_enable(struct inno_dsidphy *inno)
+{
+
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_PREDIV_MASK, REG_PREDIV(inno->pll.prediv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
+			REG_FBDIV_HI_MASK, REG_FBDIV_HI(inno->pll.fbdiv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x04,
+			REG_FBDIV_LO_MASK, REG_FBDIV_LO(inno->pll.fbdiv));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,
+			PLL_POST_DIV_ENABLE_MASK, PLL_POST_DIV_ENABLE);
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x0b,
+			CLOCK_LANE_VOD_RANGE_SET_MASK,
+			CLOCK_LANE_VOD_RANGE_SET(VOD_MAX_RANGE));
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
+			 REG_LDOPD_MASK | REG_PLLPD_MASK,
+			 REG_LDOPD_POWER_ON | REG_PLLPD_POWER_ON);
+}
+
+static void inno_mipi_dphy_max_1GHz_pll_enable(struct inno_dsidphy *inno)
+{
 	/* Configure PLL */
 	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x03,
 			REG_PREDIV_MASK, REG_PREDIV(inno->pll.prediv));
@@ -330,6 +449,10 @@ static void inno_dsidphy_mipi_mode_enabl
 	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
 			REG_LDOPD_MASK | REG_PLLPD_MASK,
 			REG_LDOPD_POWER_ON | REG_PLLPD_POWER_ON);
+}
+
+static void inno_mipi_dphy_reset(struct inno_dsidphy *inno)
+{
 	/* Reset analog */
 	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x01,
 			REG_SYNCRST_MASK, REG_SYNCRST_RESET);
@@ -342,6 +465,17 @@ static void inno_dsidphy_mipi_mode_enabl
 	udelay(1);
 	phy_update_bits(inno, REGISTER_PART_DIGITAL, 0x00,
 			REG_DIG_RSTN_MASK, REG_DIG_RSTN_NORMAL);
+}
+
+static void inno_mipi_dphy_timing_init(struct inno_dsidphy *inno)
+{
+	struct phy_configure_opts_mipi_dphy *cfg = &inno->dphy_cfg;
+	u32 t_txbyteclkhs, t_txclkesc;
+	u32 txbyteclkhs, txclkesc, esc_clk_div;
+	u32 hs_exit, clk_post, clk_pre, wakeup, lpx, ta_go, ta_sure, ta_wait;
+	u32 hs_prepare, hs_trail, hs_zero, clk_lane_hs_zero, data_lane_hs_zero;
+	const struct inno_mipi_dphy_timing *timing;
+	unsigned int i;
 
 	txbyteclkhs = inno->pll.rate / 8;
 	t_txbyteclkhs = div_u64(PSEC_PER_SEC, txbyteclkhs);
@@ -365,15 +499,6 @@ static void inno_dsidphy_mipi_mode_enabl
 	 * Tclk-pre = Tpin_txbyteclkhs * value
 	 */
 	clk_pre = DIV_ROUND_UP(cfg->clk_pre, t_txbyteclkhs);
-
-	/*
-	 * The value of counter for HS Tlpx Time
-	 * Tlpx = Tpin_txbyteclkhs * (2 + value)
-	 */
-	lpx = DIV_ROUND_UP(cfg->lpx, t_txbyteclkhs);
-	if (lpx >= 2)
-		lpx -= 2;
-
 	/*
 	 * The value of counter for HS Tta-go
 	 * Tta-go for turnaround
@@ -393,17 +518,22 @@ static void inno_dsidphy_mipi_mode_enabl
 	 */
 	ta_wait = DIV_ROUND_UP(cfg->ta_get, t_txclkesc);
 
-	for (i = 0; i < ARRAY_SIZE(timings); i++)
-		if (inno->pll.rate <= timings[i].rate)
-			break;
-
-	if (i == ARRAY_SIZE(timings))
-		--i;
-
-	hs_prepare = timings[i].hs_prepare;
-	hs_trail = timings[i].hs_trail;
-	clk_lane_hs_zero = timings[i].clk_lane_hs_zero;
-	data_lane_hs_zero = timings[i].data_lane_hs_zero;
+	timing = inno_mipi_dphy_get_timing(inno);
+	/*
+	 * The value of counter for HS Tlpx Time
+	 * Tlpx = Tpin_txbyteclkhs * (2 + value)
+	 */
+	if (inno->pdata->max_rate == MAX_1GHZ) {
+		lpx = DIV_ROUND_UP(cfg->lpx, t_txbyteclkhs);
+		if (lpx >= 2)
+			lpx -= 2;
+	} else
+		lpx = timing->lpx;
+
+	hs_prepare = timing->hs_prepare;
+	hs_trail = timing->hs_trail;
+	clk_lane_hs_zero = timing->clk_lane_hs_zero;
+	data_lane_hs_zero = timing->data_lane_hs_zero;
 	wakeup = 0x3ff;
 
 	for (i = REGISTER_PART_CLOCK_LANE; i <= REGISTER_PART_DATA3_LANE; i++) {
@@ -416,14 +546,29 @@ static void inno_dsidphy_mipi_mode_enabl
 				T_LPX_CNT(lpx));
 		phy_update_bits(inno, i, 0x06, T_HS_PREPARE_CNT_MASK,
 				T_HS_PREPARE_CNT(hs_prepare));
-		phy_update_bits(inno, i, 0x07, T_HS_ZERO_CNT_MASK,
-				T_HS_ZERO_CNT(hs_zero));
+
+		if (inno->pdata->max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x06, T_HS_ZERO_CNT_HI_MASK,
+					T_HS_ZERO_CNT_HI(hs_zero >> 6));
+
+		phy_update_bits(inno, i, 0x07, T_HS_ZERO_CNT_LO_MASK,
+				T_HS_ZERO_CNT_LO(hs_zero));
 		phy_update_bits(inno, i, 0x08, T_HS_TRAIL_CNT_MASK,
 				T_HS_TRAIL_CNT(hs_trail));
-		phy_update_bits(inno, i, 0x09, T_HS_EXIT_CNT_MASK,
-				T_HS_EXIT_CNT(hs_exit));
-		phy_update_bits(inno, i, 0x0a, T_CLK_POST_CNT_MASK,
-				T_CLK_POST_CNT(clk_post));
+
+		if (inno->pdata->max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x11, T_HS_EXIT_CNT_HI_MASK,
+					T_HS_EXIT_CNT_HI(hs_exit >> 5));
+
+		phy_update_bits(inno, i, 0x09, T_HS_EXIT_CNT_LO_MASK,
+				T_HS_EXIT_CNT_LO(hs_exit));
+
+		if (inno->pdata->max_rate == MAX_2_5GHZ)
+			phy_update_bits(inno, i, 0x10, T_CLK_POST_HI_MASK,
+					T_CLK_POST_HI(clk_post >> 4));
+
+		phy_update_bits(inno, i, 0x0a, T_CLK_POST_CNT_LO_MASK,
+				T_CLK_POST_CNT_LO(clk_post));
 		phy_update_bits(inno, i, 0x0e, T_CLK_PRE_CNT_MASK,
 				T_CLK_PRE_CNT(clk_pre));
 		phy_update_bits(inno, i, 0x0c, T_WAKEUP_CNT_HI_MASK,
@@ -437,11 +582,51 @@ static void inno_dsidphy_mipi_mode_enabl
 		phy_update_bits(inno, i, 0x12, T_TA_WAIT_CNT_MASK,
 				T_TA_WAIT_CNT(ta_wait));
 	}
+}
 
-	/* Enable all lanes on analog part */
-	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
-			LANE_EN_MASK, LANE_EN_CK | LANE_EN_3 | LANE_EN_2 |
-			LANE_EN_1 | LANE_EN_0);
+static void inno_mipi_dphy_lane_enable(struct inno_dsidphy *inno)
+{
+	u8 val = LANE_EN_CK;
+
+	switch (inno->lanes) {
+	case 1:
+		val |= LANE_EN_0;
+		break;
+	case 2:
+		val |= LANE_EN_1 | LANE_EN_0;
+		break;
+	case 3:
+		val |= LANE_EN_2 | LANE_EN_1 | LANE_EN_0;
+		break;
+	case 4:
+	default:
+		val |= LANE_EN_3 | LANE_EN_2 | LANE_EN_1 | LANE_EN_0;
+		break;
+	}
+
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00, LANE_EN_MASK, val);
+}
+
+static void inno_dsidphy_mipi_mode_enable(struct inno_dsidphy *inno)
+{
+	/* Select MIPI mode */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
+			MODE_ENABLE_MASK, MIPI_MODE_ENABLE);
+
+	/* set pin_txclkesc_0 pin_txbyteclk invert disable */
+	if (inno->pdata->soc_type == PX30S)
+		phy_update_bits(inno, REGISTER_PART_DIGITAL, 0x01,
+				INVERT_TXCLKESC_MASK, INVERT_TXCLKESC_DISABLE);
+
+	if (inno->pdata->max_rate == MAX_2_5GHZ)
+		inno_mipi_dphy_max_2_5GHz_pll_enable(inno);
+	else
+		inno_mipi_dphy_max_1GHz_pll_enable(inno);
+
+	inno_mipi_dphy_reset(inno);
+	inno_mipi_dphy_timing_init(inno);
+	inno_mipi_dphy_lane_enable(inno);
+	inno_mipi_dphy_lane_enable(inno);
 }
 
 static void inno_dsidphy_lvds_mode_enable(struct inno_dsidphy *inno)
@@ -451,8 +636,18 @@ static void inno_dsidphy_lvds_mode_enabl
 
 	/* Sample clock reverse direction */
 	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x08,
-			SAMPLE_CLOCK_DIRECTION_MASK,
-			SAMPLE_CLOCK_DIRECTION_REVERSE);
+			SAMPLE_CLOCK_DIRECTION_MASK | LOWFRE_EN_MASK,
+			SAMPLE_CLOCK_DIRECTION_REVERSE |
+			PLL_OUTPUT_FREQUENCY_DIV_BY_1);
+
+	/* Reset LVDS digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_ENABLE);
+	udelay(1);
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
+			LVDS_DIGITAL_INTERNAL_RESET_MASK,
+			LVDS_DIGITAL_INTERNAL_RESET_DISABLE);
 
 	/* Select LVDS mode */
 	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
@@ -472,7 +667,24 @@ static void inno_dsidphy_lvds_mode_enabl
 
 	msleep(20);
 
-	/* Reset LVDS digital logic */
+	/* Select PLL mode */
+	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x1e,
+			PLL_MODE_SEL_MASK, PLL_MODE_SEL_LVDS_MODE);
+
+	/* Enable LVDS digital logic */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x01,
+			LVDS_DIGITAL_INTERNAL_ENABLE_MASK,
+			LVDS_DIGITAL_INTERNAL_ENABLE);
+	/* Enable LVDS analog driver */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
+			LVDS_LANE_EN_MASK, LVDS_CLK_LANE_EN |
+			LVDS_DATA_LANE0_EN | LVDS_DATA_LANE1_EN |
+			LVDS_DATA_LANE2_EN | LVDS_DATA_LANE3_EN);
+}
+
+static void inno_dsidphy_phy_ttl_mode_enable(struct inno_dsidphy *inno)
+{
+	/* Reset digital logic */
 	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
 			LVDS_DIGITAL_INTERNAL_RESET_MASK,
 			LVDS_DIGITAL_INTERNAL_RESET_ENABLE);
@@ -480,20 +692,28 @@ static void inno_dsidphy_lvds_mode_enabl
 	phy_update_bits(inno, REGISTER_PART_LVDS, 0x00,
 			LVDS_DIGITAL_INTERNAL_RESET_MASK,
 			LVDS_DIGITAL_INTERNAL_RESET_DISABLE);
-	/* Enable LVDS digital logic */
+
+	/* Select TTL mode */
+	phy_update_bits(inno, REGISTER_PART_LVDS, 0x03,
+			MODE_ENABLE_MASK, TTL_MODE_ENABLE);
+
+	/* Enable digital logic */
 	phy_update_bits(inno, REGISTER_PART_LVDS, 0x01,
 			LVDS_DIGITAL_INTERNAL_ENABLE_MASK,
 			LVDS_DIGITAL_INTERNAL_ENABLE);
-	/* Enable LVDS analog driver */
+	/* Enable analog driver */
 	phy_update_bits(inno, REGISTER_PART_LVDS, 0x0b,
 			LVDS_LANE_EN_MASK, LVDS_CLK_LANE_EN |
 			LVDS_DATA_LANE0_EN | LVDS_DATA_LANE1_EN |
 			LVDS_DATA_LANE2_EN | LVDS_DATA_LANE3_EN);
+	/* Enable for clk lane in TTL mode */
+	host_update_bits(inno, DSI_PHY_RSTZ, PHY_ENABLECLK, PHY_ENABLECLK);
 }
 
 static int inno_dsidphy_power_on(struct phy *phy)
 {
 	struct inno_dsidphy *inno = phy_get_drvdata(phy);
+	enum phy_mode mode = phy_get_mode(phy);
 
 	clk_prepare_enable(inno->pclk_phy);
 	clk_prepare_enable(inno->ref_clk);
@@ -506,7 +726,7 @@ static int inno_dsidphy_power_on(struct
 	phy_update_bits(inno, REGISTER_PART_ANALOG, 0x00,
 			POWER_WORK_MASK, POWER_WORK_ENABLE);
 
-	switch (inno->mode) {
+	switch (mode) {
 	case PHY_MODE_MIPI_DPHY:
 		inno_dsidphy_mipi_mode_enable(inno);
 		break;
@@ -514,7 +734,7 @@ static int inno_dsidphy_power_on(struct
 		inno_dsidphy_lvds_mode_enable(inno);
 		break;
 	default:
-		return -EINVAL;
+		inno_dsidphy_phy_ttl_mode_enable(inno);
 	}
 
 	return 0;
@@ -551,17 +771,6 @@ static int inno_dsidphy_power_off(struct
 static int inno_dsidphy_set_mode(struct phy *phy, enum phy_mode mode,
 				   int submode)
 {
-	struct inno_dsidphy *inno = phy_get_drvdata(phy);
-
-	switch (mode) {
-	case PHY_MODE_MIPI_DPHY:
-	case PHY_MODE_LVDS:
-		inno->mode = mode;
-		break;
-	default:
-		return -EINVAL;
-	}
-
 	return 0;
 }
 
@@ -569,9 +778,11 @@ static int inno_dsidphy_configure(struct
 				  union phy_configure_opts *opts)
 {
 	struct inno_dsidphy *inno = phy_get_drvdata(phy);
+	struct phy_configure_opts_mipi_dphy *cfg = &inno->dphy_cfg;
+	enum phy_mode mode = phy_get_mode(phy);
 	int ret;
 
-	if (inno->mode != PHY_MODE_MIPI_DPHY)
+	if (mode != PHY_MODE_MIPI_DPHY)
 		return -EINVAL;
 
 	ret = phy_mipi_dphy_config_validate(&opts->mipi_dphy);
@@ -580,6 +791,32 @@ static int inno_dsidphy_configure(struct
 
 	memcpy(&inno->dphy_cfg, &opts->mipi_dphy, sizeof(inno->dphy_cfg));
 
+	inno_dsidphy_pll_calc_rate(inno, cfg->hs_clk_rate);
+	cfg->hs_clk_rate = inno->pll.rate;
+	opts->mipi_dphy.hs_clk_rate = inno->pll.rate;
+
+	return 0;
+}
+
+static int inno_dsidphy_init(struct phy *phy)
+{
+	struct inno_dsidphy *inno = phy_get_drvdata(phy);
+
+	clk_prepare_enable(inno->pclk_phy);
+	clk_prepare_enable(inno->ref_clk);
+	pm_runtime_get_sync(inno->dev);
+
+	return 0;
+}
+
+static int inno_dsidphy_exit(struct phy *phy)
+{
+	struct inno_dsidphy *inno = phy_get_drvdata(phy);
+
+	pm_runtime_put(inno->dev);
+	clk_disable_unprepare(inno->ref_clk);
+	clk_disable_unprepare(inno->pclk_phy);
+
 	return 0;
 }
 
@@ -588,15 +825,67 @@ static const struct phy_ops inno_dsidphy
 	.set_mode = inno_dsidphy_set_mode,
 	.power_on = inno_dsidphy_power_on,
 	.power_off = inno_dsidphy_power_off,
+	.init = inno_dsidphy_init,
+	.exit = inno_dsidphy_exit,
 	.owner = THIS_MODULE,
 };
 
+static const struct inno_dsidphy_plat_data px30_video_phy_plat_data = {
+	.soc_type = PX30,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_1GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_1GHz),
+	.max_rate = MAX_1GHZ,
+};
+
+static const struct inno_dsidphy_plat_data px30s_video_phy_plat_data = {
+	.soc_type = PX30S,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5GHz),
+	.max_rate = MAX_2_5GHZ,
+};
+
+static const struct inno_dsidphy_plat_data rk3128_video_phy_plat_data = {
+	.soc_type = RK3128,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_1GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_1GHz),
+	.max_rate = MAX_1GHZ,
+};
+
+static const struct inno_dsidphy_plat_data rk3368_video_phy_plat_data = {
+	.soc_type = RK3368,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_1GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_1GHz),
+	.max_rate = MAX_1GHZ,
+};
+
+static const struct inno_dsidphy_plat_data rk3562_video_phy_plat_data = {
+	.soc_type = RK3562,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5GHz),
+	.max_rate = MAX_2_5GHZ,
+};
+
+static const struct inno_dsidphy_plat_data rk3568_video_phy_plat_data = {
+	.soc_type = RK3568,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5GHz),
+	.max_rate = MAX_2_5GHZ,
+};
+
+static const struct inno_dsidphy_plat_data rv1126_video_phy_plat_data = {
+	.soc_type = RV1126,
+	.inno_mipi_dphy_timing_table = inno_mipi_dphy_timing_table_max_2_5GHz,
+	.num_timings = ARRAY_SIZE(inno_mipi_dphy_timing_table_max_2_5GHz),
+	.max_rate = MAX_2_5GHZ,
+};
+
 static int inno_dsidphy_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct inno_dsidphy *inno;
 	struct phy_provider *phy_provider;
 	struct phy *phy;
+	struct resource *res;
 	int ret;
 
 	inno = devm_kzalloc(dev, sizeof(*inno), GFP_KERNEL);
@@ -604,12 +893,26 @@ static int inno_dsidphy_probe(struct pla
 		return -ENOMEM;
 
 	inno->dev = dev;
+	inno->pdata = of_device_get_match_data(inno->dev);
+	if (soc_is_px30s())
+		inno->pdata = &px30s_video_phy_plat_data;
+
 	platform_set_drvdata(pdev, inno);
 
-	inno->phy_base = devm_platform_ioremap_resource(pdev, 0);
+	inno->phy_base = devm_platform_ioremap_resource_byname(pdev, "phy");
 	if (IS_ERR(inno->phy_base))
 		return PTR_ERR(inno->phy_base);
 
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "host");
+	if (!res) {
+		dev_err(dev, "invalid host resource\n");
+		return -EINVAL;
+	}
+
+	inno->host_base = devm_ioremap(dev, res->start, resource_size(res));
+	if (IS_ERR(inno->host_base))
+		return PTR_ERR(inno->host_base);
+
 	inno->ref_clk = devm_clk_get(dev, "ref");
 	if (IS_ERR(inno->ref_clk)) {
 		ret = PTR_ERR(inno->ref_clk);
@@ -624,6 +927,13 @@ static int inno_dsidphy_probe(struct pla
 		return ret;
 	}
 
+	inno->pclk_host = devm_clk_get(dev, "pclk_host");
+	if (IS_ERR(inno->pclk_host)) {
+		ret = PTR_ERR(inno->pclk_host);
+		dev_err(dev, "failed to get host pclk: %d\n", ret);
+		return ret;
+	}
+
 	inno->rst = devm_reset_control_get(dev, "apb");
 	if (IS_ERR(inno->rst)) {
 		ret = PTR_ERR(inno->rst);
@@ -638,6 +948,9 @@ static int inno_dsidphy_probe(struct pla
 		return ret;
 	}
 
+	if (of_property_read_u32(dev->of_node, "inno,lanes", &inno->lanes))
+		inno->lanes = 4;
+
 	phy_set_drvdata(phy, inno);
 
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
@@ -662,9 +975,28 @@ static int inno_dsidphy_remove(struct pl
 }
 
 static const struct of_device_id inno_dsidphy_of_match[] = {
-	{ .compatible = "rockchip,px30-dsi-dphy", },
-	{ .compatible = "rockchip,rk3128-dsi-dphy", },
-	{ .compatible = "rockchip,rk3368-dsi-dphy", },
+	{
+		.compatible = "rockchip,px30-dsi-dphy",
+		.data = &px30_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,px30s-dsi-dphy",
+		.data = &px30s_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,rk3128-dsi-dphy",
+		.data = &rk3128_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,rk3368-dsi-dphy",
+		.data = &rk3368_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,rk3562-dsi-dphy",
+		.data = &rk3562_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,rk3568-dsi-dphy",
+		.data = &rk3568_video_phy_plat_data,
+	}, {
+		.compatible = "rockchip,rv1126-mipi-dphy",
+		.data = &rv1126_video_phy_plat_data,
+	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, inno_dsidphy_of_match);
--- a/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
+++ b/drivers/phy/rockchip/phy-rockchip-inno-usb2.c
@@ -163,6 +163,7 @@ struct rockchip_chg_det_reg {
  * @utmi_ls: utmi linestate state register.
  * @utmi_hstdet: utmi host disconnect register.
  * @vbus_det_en: vbus detect function power down register.
+ * @port_ls_filter_con: set linestate filter time for otg port or host port.
  */
 struct rockchip_usb2phy_port_cfg {
 	struct usb2phy_reg	phy_sus;
@@ -202,6 +203,7 @@ struct rockchip_usb2phy_port_cfg {
 	struct usb2phy_reg	utmi_ls;
 	struct usb2phy_reg	utmi_hstdet;
 	struct usb2phy_reg	vbus_det_en;
+	struct usb2phy_reg	port_ls_filter_con;
 };
 
 /**
@@ -210,7 +212,9 @@ struct rockchip_usb2phy_port_cfg {
  * @num_ports: specify how many ports that the phy has.
  * @phy_tuning: phy default parameters tuning.
  * @vbus_detect: vbus voltage level detection function.
- * @clkout_ctl: keep on/turn off output clk of phy.
+ * @clkout_ctl: keep on/turn off output clk of phy via commonon bit.
+ * @clkout_ctl_phy: keep on/turn off output clk of phy via phy inner
+ *		    debug register.
  * @ls_filter_con: set linestate filter time.
  * @port_cfgs: usb-phy port configurations.
  * @ls_filter_con: set linestate filter time.
@@ -220,8 +224,11 @@ struct rockchip_usb2phy_cfg {
 	unsigned int	reg;
 	unsigned int	num_ports;
 	int (*phy_tuning)(struct rockchip_usb2phy *rphy);
-	int (*vbus_detect)(struct rockchip_usb2phy *rphy, bool en);
+	int (*vbus_detect)(struct rockchip_usb2phy *rphy,
+			   const struct usb2phy_reg *vbus_det_en,
+			   bool en);
 	struct usb2phy_reg	clkout_ctl;
+	struct usb2phy_reg	clkout_ctl_phy;
 	struct usb2phy_reg	ls_filter_con;
 	const struct rockchip_usb2phy_port_cfg	port_cfgs[USB2PHY_NUM_PORTS];
 	const struct rockchip_chg_det_reg	chg_det;
@@ -380,6 +387,29 @@ static inline bool property_enabled(stru
 	return tmp == reg->enable;
 }
 
+static inline void phy_property_enable(void __iomem *base,
+				    const struct usb2phy_reg *reg, bool en)
+{
+	unsigned int val, tmp;
+
+	val = readl(base + reg->offset);
+	tmp = en ? reg->enable : reg->disable;
+	val &= ~GENMASK(reg->bitend, reg->bitstart);
+	val |= tmp << reg->bitstart;
+	writel(val, base + reg->offset);
+}
+
+static inline bool phy_property_enabled(void __iomem *base,
+				    const struct usb2phy_reg *reg)
+{
+	unsigned int orig, tmp;
+	unsigned int mask = GENMASK(reg->bitend, reg->bitstart);
+
+	orig = readl(base + reg->offset);
+	tmp = (orig & mask) >> reg->bitstart;
+	return tmp == reg->enable;
+}
+
 static inline void phy_clear_bits(void __iomem *reg, u32 bits)
 {
 	u32 tmp = readl(reg);
@@ -435,7 +465,14 @@ static int rockchip_usb2phy_clk480m_prep
 	int ret;
 
 	/* turn on 480m clk output if it is off */
-	if (!property_enabled(base, &rphy->phy_cfg->clkout_ctl)) {
+	if (rphy->phy_cfg->clkout_ctl_phy.enable) {
+		if (!phy_property_enabled(rphy->phy_base, &rphy->phy_cfg->clkout_ctl_phy)) {
+			phy_property_enable(rphy->phy_base, &rphy->phy_cfg->clkout_ctl_phy, true);
+
+			/* waiting for the clk become stable */
+			usleep_range(1200, 1300);
+		}
+	} else if (!property_enabled(base, &rphy->phy_cfg->clkout_ctl)) {
 		ret = property_enable(base, &rphy->phy_cfg->clkout_ctl, true);
 		if (ret)
 			return ret;
@@ -454,7 +491,10 @@ static void rockchip_usb2phy_clk480m_unp
 	struct regmap *base = get_reg_base(rphy);
 
 	/* turn off 480m clk output */
-	property_enable(base, &rphy->phy_cfg->clkout_ctl, false);
+	if (rphy->phy_cfg->clkout_ctl_phy.enable)
+		phy_property_enable(rphy->phy_base, &rphy->phy_cfg->clkout_ctl_phy, false);
+	else
+		property_enable(base, &rphy->phy_cfg->clkout_ctl, false);
 }
 
 static int rockchip_usb2phy_clk480m_prepared(struct clk_hw *hw)
@@ -463,7 +503,10 @@ static int rockchip_usb2phy_clk480m_prep
 		container_of(hw, struct rockchip_usb2phy, clk480m_hw);
 	struct regmap *base = get_reg_base(rphy);
 
-	return property_enabled(base, &rphy->phy_cfg->clkout_ctl);
+	if (rphy->phy_cfg->clkout_ctl_phy.enable)
+		return phy_property_enabled(rphy->phy_base, &rphy->phy_cfg->clkout_ctl_phy);
+	else
+		return property_enabled(base, &rphy->phy_cfg->clkout_ctl);
 }
 
 static unsigned long
@@ -756,6 +799,10 @@ static int rockchip_usb2phy_init(struct
 
 	mutex_lock(&rport->mutex);
 
+	if (rport->sel_pipe_phystatus)
+		property_enable(rphy->usbctrl_grf,
+				&rport->port_cfg->pipe_phystatus, true);
+
 	if (rport->port_id == USB2PHY_PORT_OTG &&
 	    (rport->mode == USB_DR_MODE_PERIPHERAL ||
 	     rport->mode == USB_DR_MODE_OTG)) {
@@ -843,10 +890,6 @@ static int rockchip_usb2phy_power_on(str
 	if (ret)
 		goto unlock;
 
-	if (rport->sel_pipe_phystatus)
-		property_enable(rphy->usbctrl_grf,
-				&rport->port_cfg->pipe_phystatus, true);
-
 	ret = property_enable(base, &rport->port_cfg->phy_sus, false);
 	if (ret)
 		goto unlock;
@@ -1015,7 +1058,8 @@ static int rockchip_usb2phy_set_mode(str
 	}
 
 	if (rphy->phy_cfg->vbus_detect)
-		rphy->phy_cfg->vbus_detect(rphy, vbus_det_en);
+		rphy->phy_cfg->vbus_detect(rphy, &rport->port_cfg->vbus_det_en,
+					   vbus_det_en);
 	else
 		ret = property_enable(rphy->grf, &rport->port_cfg->vbus_det_en,
 				      vbus_det_en);
@@ -1255,6 +1299,7 @@ static void rockchip_usb2phy_otg_sm_work
 		} else {
 			rphy->chg_state = USB_CHG_STATE_UNDEFINED;
 			rphy->chg_type = POWER_SUPPLY_TYPE_UNKNOWN;
+			rport->perip_connected = false;
 			mutex_unlock(&rport->mutex);
 			if (!rport->dis_u2_susphy)
 				rockchip_usb2phy_power_off(rport->phy);
@@ -1724,7 +1769,9 @@ static irqreturn_t rockchip_usb2phy_id_i
 	if (property_enabled(rphy->grf, &rport->port_cfg->idfall_det_st)) {
 		property_enable(rphy->grf, &rport->port_cfg->idfall_det_clr,
 				true);
-		cable_vbus_state = true;
+		/* switch to host if id fall det and iddig status is low */
+		if (!property_enabled(rphy->grf, &rport->port_cfg->utmi_iddig))
+			cable_vbus_state = true;
 	} else if (property_enabled(rphy->grf, &rport->port_cfg->idrise_det_st)) {
 		property_enable(rphy->grf, &rport->port_cfg->idrise_det_clr,
 				true);
@@ -2045,6 +2092,13 @@ static int rockchip_otg_event(struct not
 	return NOTIFY_DONE;
 }
 
+#ifdef CONFIG_PM_WAKELOCKS
+static void rockchip_otg_wake_lock_destroy(void *data)
+{
+	wake_lock_destroy((struct wake_lock *)(data));
+}
+#endif
+
 static int rockchip_usb2phy_otg_port_init(struct rockchip_usb2phy *rphy,
 					  struct rockchip_usb2phy_port *rport,
 					  struct device_node *child_np)
@@ -2164,7 +2218,12 @@ static int rockchip_usb2phy_otg_port_ini
 
 #ifdef CONFIG_PM_WAKELOCKS
 	wake_lock_init(&rport->wakelock, WAKE_LOCK_SUSPEND, "rockchip_otg");
+	ret = devm_add_action_or_reset(rphy->dev, rockchip_otg_wake_lock_destroy,
+				       &rport->wakelock);
+	if (ret)
+		return ret;
 #endif
+
 	INIT_DELAYED_WORK(&rport->bypass_uart_work,
 			  rockchip_usb_bypass_uart_work);
 	INIT_DELAYED_WORK(&rport->chg_work, rockchip_chg_detect_work);
@@ -2177,7 +2236,7 @@ static int rockchip_usb2phy_otg_port_ini
 					EXTCON_USB_HOST, &rport->event_nb);
 		if (ret) {
 			dev_err(rphy->dev, "register USB HOST notifier failed\n");
-			goto err;
+			return ret;
 		}
 	}
 
@@ -2193,12 +2252,6 @@ out:
 	rport->suspended = true;
 
 	return 0;
-
-err:
-#ifdef CONFIG_PM_WAKELOCKS
-	wake_lock_destroy(&rport->wakelock);
-#endif
-	return ret;
 }
 
 static int rockchip_usb2phy_probe(struct platform_device *pdev)
@@ -2682,6 +2735,59 @@ static int rk3399_usb2phy_tuning(struct
 	return ret;
 }
 
+static int rk3528_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret = 0;
+
+	/* Turn off otg port differential receiver in suspend mode */
+	phy_clear_bits(rphy->phy_base + 0x30, BIT(2));
+
+	/* Turn off host port differential receiver in suspend mode */
+	phy_clear_bits(rphy->phy_base + 0x430, BIT(2));
+
+	/* Set otg port HS eye height to 400mv(default is 450mv) */
+	phy_update_bits(rphy->phy_base + 0x30, GENMASK(6, 4), (0x00 << 4));
+
+	/* Set host port HS eye height to 400mv(default is 450mv) */
+	phy_update_bits(rphy->phy_base + 0x430, GENMASK(6, 4), (0x00 << 4));
+
+	/* Choose the Tx fs/ls data as linestate from TX driver for otg port */
+	phy_update_bits(rphy->phy_base + 0x94, GENMASK(6, 3), (0x03 << 3));
+
+	/* Enable otg and host ports phy irq to pmu wakeup source */
+	ret |= regmap_write(rphy->grf, 0x80004, 0x00030003);
+
+	return ret;
+}
+
+static int rk3562_usb2phy_tuning(struct rockchip_usb2phy *rphy)
+{
+	int ret = 0;
+
+	/* Turn off differential receiver by default to save power */
+	phy_clear_bits(rphy->phy_base + 0x0030, BIT(2));
+	phy_clear_bits(rphy->phy_base + 0x0430, BIT(2));
+
+	/* Enable pre-emphasis during non-chirp phase */
+	phy_update_bits(rphy->phy_base, GENMASK(2, 0), 0x04);
+	phy_update_bits(rphy->phy_base + 0x0400, GENMASK(2, 0), 0x04);
+
+	/* Set HS eye height to 425mv(default is 400mv) */
+	phy_update_bits(rphy->phy_base + 0x0030, GENMASK(6, 4), (0x05 << 4));
+	phy_update_bits(rphy->phy_base + 0x0430, GENMASK(6, 4), (0x05 << 4));
+
+	/* Set the bvalid filter time to 10ms based on the u2phy grf pclk 100MHz */
+	ret |= regmap_write(rphy->grf, 0x0138, FILTER_COUNTER);
+
+	/* Set the id filter time to 10ms based on the u2phy grf pclk 100MHz */
+	ret |= regmap_write(rphy->grf, 0x013c, FILTER_COUNTER);
+
+	/* Enable host port wakeup irq */
+	ret |= regmap_write(rphy->grf, 0x010c, 0x80008000);
+
+	return ret;
+}
+
 static int rk3568_usb2phy_tuning(struct rockchip_usb2phy *rphy)
 {
 	int ret = 0;
@@ -2747,17 +2853,22 @@ static int rv1106_usb2phy_tuning(struct
 	phy_update_bits(rphy->phy_base + 0x1a4, GENMASK(7, 4), (0x01 << 4));
 	phy_update_bits(rphy->phy_base + 0x1b4, GENMASK(7, 4), (0x01 << 4));
 
+	/* Set HS disconnect detect mode to single ended detect mode */
+	phy_set_bits(rphy->phy_base + 0x70, BIT(2));
+
 	return 0;
 }
 
-static int rk3568_vbus_detect_control(struct rockchip_usb2phy *rphy, bool en)
+static int rockchip_usb2phy_vbus_det_control(struct rockchip_usb2phy *rphy,
+					     const struct usb2phy_reg *vbus_det_en,
+					     bool en)
 {
 	if (en) {
 		/* Enable vbus voltage level detection function */
-		phy_clear_bits(rphy->phy_base + 0x3c, BIT(7));
+		phy_clear_bits(rphy->phy_base + vbus_det_en->offset, BIT(7));
 	} else {
 		/* Disable vbus voltage level detection function */
-		phy_set_bits(rphy->phy_base + 0x3c, BIT(7));
+		phy_set_bits(rphy->phy_base + vbus_det_en->offset, BIT(7));
 	}
 
 	return 0;
@@ -2896,6 +3007,14 @@ static int rockchip_usb2phy_pm_suspend(s
 		if (!rport->phy)
 			continue;
 
+		if (rport->port_cfg->port_ls_filter_con.enable) {
+			ret = regmap_write(rphy->grf,
+					   rport->port_cfg->port_ls_filter_con.offset,
+					   rport->port_cfg->port_ls_filter_con.enable);
+			if (ret)
+				dev_err(rphy->dev, "failed to set port ls filter %d\n", ret);
+		}
+
 		if (rport->port_id == USB2PHY_PORT_OTG &&
 		    (rport->id_irq > 0 || rphy->irq > 0)) {
 			mutex_lock(&rport->mutex);
@@ -2972,6 +3091,14 @@ static int rockchip_usb2phy_pm_resume(st
 		if (!rport->phy)
 			continue;
 
+		if (rport->port_cfg->port_ls_filter_con.disable) {
+			ret = regmap_write(rphy->grf,
+					   rport->port_cfg->port_ls_filter_con.offset,
+					   rport->port_cfg->port_ls_filter_con.disable);
+			if (ret)
+				dev_err(rphy->dev, "failed to set port ls filter %d\n", ret);
+		}
+
 		if (rport->port_id == USB2PHY_PORT_OTG &&
 		    (rport->id_irq > 0 || rphy->irq > 0)) {
 			mutex_lock(&rport->mutex);
@@ -3493,12 +3620,127 @@ static const struct rockchip_usb2phy_cfg
 	{ /* sentinel */ }
 };
 
+static const struct rockchip_usb2phy_cfg rk3528_phy_cfgs[] = {
+	{
+		.reg = 0xffdf0000,
+		.num_ports	= 2,
+		.phy_tuning	= rk3528_usb2phy_tuning,
+		.vbus_detect	= rockchip_usb2phy_vbus_det_control,
+		.clkout_ctl_phy	= { 0x041c, 7, 2, 0, 0x27 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x6004c, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x60074, 2, 2, 0, 1 },
+				.bvalid_det_st	= { 0x60078, 2, 2, 0, 1 },
+				.bvalid_det_clr = { 0x6007c, 2, 2, 0, 1 },
+				.iddig_output	= { 0x6004c, 10, 10, 0, 1 },
+				.iddig_en	= { 0x6004c, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x60074, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x60078, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x6007c, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x60074, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x60078, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x6007c, 4, 4, 0, 1 },
+				.ls_det_en	= { 0x60074, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x60078, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x6007c, 0, 0, 0, 1 },
+				.utmi_avalid	= { 0x6006c, 1, 1, 0, 1 },
+				.utmi_bvalid	= { 0x6006c, 0, 0, 0, 1 },
+				.utmi_iddig	= { 0x6006c, 6, 6, 0, 1 },
+				.utmi_ls	= { 0x6006c, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x003c, 7, 7, 0, 1 },
+				.port_ls_filter_con = { 0x60080, 19, 0, 0x30100, 0x20 },
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x6005c, 8, 0, 0x1d2, 0x1d1 },
+				.ls_det_en	= { 0x60090, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x60094, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x60098, 0, 0, 0, 1 },
+				.utmi_ls	= { 0x6006c, 13, 12, 0, 1 },
+				.utmi_hstdet	= { 0x6006c, 15, 15, 0, 1 },
+				.port_ls_filter_con = { 0x6009c, 19, 0, 0x30100, 0x20 },
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x6004c, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x6006c, 19, 19, 0, 1 },
+			.dcp_det	= { 0x6006c, 18, 18, 0, 1 },
+			.dp_det		= { 0x6006c, 20, 20, 0, 1 },
+			.idm_sink_en	= { 0x60058, 1, 1, 0, 1 },
+			.idp_sink_en	= { 0x60058, 0, 0, 0, 1 },
+			.idp_src_en	= { 0x60058, 2, 2, 0, 1 },
+			.rdm_pdwn_en	= { 0x60058, 3, 3, 0, 1 },
+			.vdm_src_en	= { 0x60058, 5, 5, 0, 1 },
+			.vdp_src_en	= { 0x60058, 4, 4, 0, 1 },
+		},
+	}
+};
+
+static const struct rockchip_usb2phy_cfg rk3562_phy_cfgs[] = {
+	{
+		.reg = 0xff740000,
+		.num_ports	= 2,
+		.phy_tuning	= rk3562_usb2phy_tuning,
+		.vbus_detect	= rockchip_usb2phy_vbus_det_control,
+		.clkout_ctl	= { 0x0108, 4, 4, 1, 0 },
+		.ls_filter_con	= { 0x0130, 19, 0, 0x30100, 0x00020 },
+		.port_cfgs	= {
+			[USB2PHY_PORT_OTG] = {
+				.phy_sus	= { 0x0100, 8, 0, 0, 0x1d1 },
+				.bvalid_det_en	= { 0x0110, 2, 2, 0, 1 },
+				.bvalid_det_st	= { 0x0114, 2, 2, 0, 1 },
+				.bvalid_det_clr = { 0x0118, 2, 2, 0, 1 },
+				.bvalid_grf_sel	= { 0x0108, 15, 14, 0, 3 },
+				.bypass_dm_en	= { 0x0108, 2, 2, 0, 1},
+				.bypass_sel	= { 0x0108, 3, 3, 0, 1},
+				.iddig_output	= { 0x0100, 10, 10, 0, 1 },
+				.iddig_en	= { 0x0100, 9, 9, 0, 1 },
+				.idfall_det_en	= { 0x0110, 5, 5, 0, 1 },
+				.idfall_det_st	= { 0x0114, 5, 5, 0, 1 },
+				.idfall_det_clr = { 0x0118, 5, 5, 0, 1 },
+				.idrise_det_en	= { 0x0110, 4, 4, 0, 1 },
+				.idrise_det_st	= { 0x0114, 4, 4, 0, 1 },
+				.idrise_det_clr = { 0x0118, 4, 4, 0, 1 },
+				.ls_det_en	= { 0x0110, 0, 0, 0, 1 },
+				.ls_det_st	= { 0x0114, 0, 0, 0, 1 },
+				.ls_det_clr	= { 0x0118, 0, 0, 0, 1 },
+				.utmi_avalid	= { 0x0120, 10, 10, 0, 1 },
+				.utmi_bvalid	= { 0x0120, 9, 9, 0, 1 },
+				.utmi_iddig	= { 0x0120, 6, 6, 0, 1 },
+				.utmi_ls	= { 0x0120, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x003c, 7, 7, 0, 1 },
+			},
+			[USB2PHY_PORT_HOST] = {
+				.phy_sus	= { 0x0104, 8, 0, 0x1d2, 0x1d1 },
+				.ls_det_en	= { 0x0110, 1, 1, 0, 1 },
+				.ls_det_st	= { 0x0114, 1, 1, 0, 1 },
+				.ls_det_clr	= { 0x0118, 1, 1, 0, 1 },
+				.utmi_ls	= { 0x0120, 17, 16, 0, 1 },
+				.utmi_hstdet	= { 0x0120, 19, 19, 0, 1 }
+			}
+		},
+		.chg_det = {
+			.chg_mode	= { 0x0100, 8, 0, 0, 0x1d7 },
+			.cp_det		= { 0x0120, 24, 24, 0, 1 },
+			.dcp_det	= { 0x0120, 23, 23, 0, 1 },
+			.dp_det		= { 0x0120, 25, 25, 0, 1 },
+			.idm_sink_en	= { 0x0108, 8, 8, 0, 1 },
+			.idp_sink_en	= { 0x0108, 7, 7, 0, 1 },
+			.idp_src_en	= { 0x0108, 9, 9, 0, 1 },
+			.rdm_pdwn_en	= { 0x0108, 10, 10, 0, 1 },
+			.vdm_src_en	= { 0x0108, 12, 12, 0, 1 },
+			.vdp_src_en	= { 0x0108, 11, 11, 0, 1 },
+		},
+	},
+	{ /* sentinel */ }
+};
+
 static const struct rockchip_usb2phy_cfg rk3568_phy_cfgs[] = {
 	{
 		.reg = 0xfe8a0000,
 		.num_ports	= 2,
 		.phy_tuning	= rk3568_usb2phy_tuning,
-		.vbus_detect	= rk3568_vbus_detect_control,
+		.vbus_detect	= rockchip_usb2phy_vbus_det_control,
 		.clkout_ctl	= { 0x0008, 4, 4, 1, 0 },
 		.ls_filter_con	= { 0x0040, 19, 0, 0x30100, 0x00020 },
 		.port_cfgs	= {
@@ -3525,6 +3767,7 @@ static const struct rockchip_usb2phy_cfg
 				.utmi_bvalid	= { 0x00c0, 9, 9, 0, 1 },
 				.utmi_iddig	= { 0x00c0, 6, 6, 0, 1 },
 				.utmi_ls	= { 0x00c0, 5, 4, 0, 1 },
+				.vbus_det_en	= { 0x003c, 7, 7, 0, 1 },
 			},
 			[USB2PHY_PORT_HOST] = {
 				/* Select suspend control from controller */
@@ -3849,6 +4092,12 @@ static const struct of_device_id rockchi
 #ifdef CONFIG_CPU_RK3399
 	{ .compatible = "rockchip,rk3399-usb2phy", .data = &rk3399_phy_cfgs },
 #endif
+#ifdef CONFIG_CPU_RK3528
+	{ .compatible = "rockchip,rk3528-usb2phy", .data = &rk3528_phy_cfgs },
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{ .compatible = "rockchip,rk3562-usb2phy", .data = &rk3562_phy_cfgs },
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{ .compatible = "rockchip,rk3568-usb2phy", .data = &rk3568_phy_cfgs },
 #endif
--- a/drivers/phy/rockchip/phy-rockchip-typec.c
+++ b/drivers/phy/rockchip/phy-rockchip-typec.c
@@ -51,6 +51,7 @@
 #include <linux/platform_device.h>
 #include <linux/regmap.h>
 #include <linux/reset.h>
+#include <linux/usb/typec_dp.h>
 #include <linux/usb/typec_mux.h>
 
 #include <linux/mfd/syscon.h>
@@ -411,10 +412,16 @@ struct phy_config {
 	int pe;
 };
 
+enum {
+	TYPEC_PHY_USB,
+	TYPEC_PHY_DP,
+	TYPEC_PHY_MAX,
+};
+
 struct rockchip_typec_phy {
 	struct device *dev;
 	void __iomem *base;
-	struct extcon_dev *extcon;
+	struct typec_mux *mux;
 	struct typec_switch *sw;
 	struct regmap *grf_regs;
 	struct clk *clk_core;
@@ -422,12 +429,14 @@ struct rockchip_typec_phy {
 	struct reset_control *uphy_rst;
 	struct reset_control *pipe_rst;
 	struct reset_control *tcphy_rst;
+	struct phy *phys[TYPEC_PHY_MAX];
 	const struct rockchip_usb3phy_port_cfg *port_cfgs;
 	/* mutex to protect access to individual PHYs */
 	struct mutex lock;
 
 	bool flip;
 	u8 mode;
+	u8 new_mode;
 	struct phy_config config[3][4];
 };
 
@@ -1335,50 +1344,7 @@ static void tcphy_phy_deinit(struct rock
 
 static int tcphy_get_mode(struct rockchip_typec_phy *tcphy)
 {
-	struct extcon_dev *edev = tcphy->extcon;
-	union extcon_property_value property;
-	unsigned int id;
-	bool ufp, dp;
-	u8 mode;
-	int ret;
-
-	if (!edev)
-		return MODE_DFP_USB;
-
-	ufp = extcon_get_state(edev, EXTCON_USB);
-	dp = extcon_get_state(edev, EXTCON_DISP_DP);
-
-	mode = MODE_DFP_USB;
-	id = EXTCON_USB_HOST;
-
-	if (ufp) {
-		mode = MODE_UFP_USB;
-		id = EXTCON_USB;
-	} else if (dp) {
-		mode = MODE_DFP_DP;
-		id = EXTCON_DISP_DP;
-
-		ret = extcon_get_property(edev, id, EXTCON_PROP_USB_SS,
-					  &property);
-		if (ret) {
-			dev_err(tcphy->dev, "get superspeed property failed\n");
-			return ret;
-		}
-
-		if (property.intval)
-			mode |= MODE_DFP_USB;
-	}
-
-	ret = extcon_get_property(edev, id, EXTCON_PROP_USB_TYPEC_POLARITY,
-				  &property);
-	if (ret) {
-		dev_err(tcphy->dev, "get polarity property failed\n");
-		return ret;
-	}
-
-	tcphy->flip = property.intval ? 1 : 0;
-
-	return mode;
+	return tcphy->new_mode;
 }
 
 static int tcphy_orien_sw_set(struct typec_switch *sw,
@@ -1388,10 +1354,13 @@ static int tcphy_orien_sw_set(struct typ
 
 	mutex_lock(&tcphy->lock);
 
-	if (orien == TYPEC_ORIENTATION_NONE)
+	if (orien == TYPEC_ORIENTATION_NONE) {
+		tcphy->new_mode = MODE_DISCONNECT;
 		goto unlock_ret;
+	}
 
 	tcphy->flip = (orien == TYPEC_ORIENTATION_REVERSE) ? true : false;
+	tcphy->new_mode = MODE_DFP_USB;
 
 unlock_ret:
 	mutex_unlock(&tcphy->lock);
@@ -1615,6 +1584,68 @@ static const struct phy_ops rockchip_dp_
 	.owner		= THIS_MODULE,
 };
 
+static int tcphy_typec_mux_set(struct typec_mux *mux, struct typec_mux_state *state)
+{
+	struct rockchip_typec_phy *tcphy = typec_mux_get_drvdata(mux);
+	struct typec_displayport_data *data;
+	int hpd = 0;
+
+	mutex_lock(&tcphy->lock);
+
+	switch (state->mode) {
+	case TYPEC_STATE_SAFE:
+		fallthrough;
+	case TYPEC_STATE_USB:
+		tcphy->new_mode = MODE_DFP_USB;
+		phy_set_bus_width(tcphy->phys[TYPEC_PHY_DP], 0);
+		break;
+	case TYPEC_DP_STATE_C:
+	case TYPEC_DP_STATE_E:
+		tcphy->new_mode = MODE_DFP_DP;
+		data = state->data;
+		hpd = !!(data->status & DP_STATUS_HPD_STATE);
+		phy_set_bus_width(tcphy->phys[TYPEC_PHY_DP], hpd ? 4 : 0);
+		break;
+	case TYPEC_DP_STATE_D:
+		tcphy->new_mode = MODE_DFP_DP | MODE_DFP_USB;
+		data = state->data;
+		hpd = !!(data->status & DP_STATUS_HPD_STATE);
+		phy_set_bus_width(tcphy->phys[TYPEC_PHY_DP], hpd ? 2 : 0);
+		break;
+	default:
+		break;
+	}
+
+	mutex_unlock(&tcphy->lock);
+
+	return 0;
+}
+
+static int tcphy_setup_typec_mux(struct rockchip_typec_phy *tcphy)
+{
+	struct typec_mux_desc mux_desc = {};
+
+	mux_desc.drvdata = tcphy;
+	mux_desc.fwnode = dev_fwnode(tcphy->dev);
+	mux_desc.set = tcphy_typec_mux_set;
+
+	tcphy->mux = typec_mux_register(tcphy->dev, &mux_desc);
+	if (IS_ERR(tcphy->mux)) {
+		dev_err(tcphy->dev, "Error register typec mux: %ld\n",
+			PTR_ERR(tcphy->mux));
+		return PTR_ERR(tcphy->mux);
+	}
+
+	return 0;
+}
+
+static void tcphy_typec_mux_unregister(void *data)
+{
+	struct rockchip_typec_phy *tcphy = data;
+
+	typec_mux_unregister(tcphy->mux);
+}
+
 static int tcphy_parse_dt(struct rockchip_typec_phy *tcphy,
 			  struct device *dev)
 {
@@ -1735,29 +1766,30 @@ static int rockchip_typec_phy_probe(stru
 		return ret;
 
 	tcphy->dev = dev;
+	tcphy->new_mode = MODE_DFP_USB;
 	platform_set_drvdata(pdev, tcphy);
 	mutex_init(&tcphy->lock);
 
 	typec_phy_pre_init(tcphy);
 
-	tcphy->extcon = extcon_get_edev_by_phandle(dev, 0);
-	if (IS_ERR(tcphy->extcon)) {
-		if (PTR_ERR(tcphy->extcon) == -ENODEV) {
-			tcphy->extcon = NULL;
-			if (device_property_present(dev, "orientation-switch")) {
-				ret = tcphy_setup_orien_switch(tcphy);
-				if (ret)
-					return ret;
-				ret = devm_add_action_or_reset(dev, udphy_orien_switch_unregister,
-							       tcphy);
-				if (ret)
-					return ret;
-			}
-		} else {
-			if (PTR_ERR(tcphy->extcon) != -EPROBE_DEFER)
-				dev_err(dev, "Invalid or missing extcon\n");
-			return PTR_ERR(tcphy->extcon);
-		}
+	if (device_property_present(dev, "orientation-switch")) {
+		ret = tcphy_setup_orien_switch(tcphy);
+		if (ret)
+			return ret;
+		ret = devm_add_action_or_reset(dev, udphy_orien_switch_unregister,
+					       tcphy);
+		if (ret)
+			return ret;
+	}
+
+	if (device_property_present(dev, "svid")) {
+		ret = tcphy_setup_typec_mux(tcphy);
+		if (ret)
+			return ret;
+
+		ret = devm_add_action_or_reset(dev, tcphy_typec_mux_unregister, tcphy);
+		if (ret)
+			return ret;
 	}
 
 	pm_runtime_enable(dev);
@@ -1765,20 +1797,31 @@ static int rockchip_typec_phy_probe(stru
 	for_each_available_child_of_node(np, child_np) {
 		struct phy *phy;
 
-		if (of_node_name_eq(child_np, "dp-port"))
+		if (!of_node_cmp(child_np->name, "dp-port")) {
 			phy = devm_phy_create(dev, child_np,
 					      &rockchip_dp_phy_ops);
-		else if (of_node_name_eq(child_np, "usb3-port"))
+			if (IS_ERR(phy)) {
+				dev_err(dev, "failed to create phy: %s\n",
+					child_np->name);
+				of_node_put(child_np);
+				ret = PTR_ERR(phy);
+				goto error;
+			}
+			tcphy->phys[TYPEC_PHY_DP] = phy;
+		} else if (!of_node_cmp(child_np->name, "usb3-port")) {
 			phy = devm_phy_create(dev, child_np,
 					      &rockchip_usb3_phy_ops);
-		else
+			if (IS_ERR(phy)) {
+				dev_err(dev, "failed to create phy: %s\n",
+					child_np->name);
+				of_node_put(child_np);
+				ret = PTR_ERR(phy);
+				goto error;
+			}
+			tcphy->phys[TYPEC_PHY_USB] = phy;
+		} else {
 			continue;
 
-		if (IS_ERR(phy)) {
-			dev_err(dev, "failed to create phy: %pOFn\n",
-				child_np);
-			pm_runtime_disable(dev);
-			return PTR_ERR(phy);
 		}
 
 		phy_set_drvdata(phy, tcphy);
@@ -1787,11 +1830,15 @@ static int rockchip_typec_phy_probe(stru
 	phy_provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
 	if (IS_ERR(phy_provider)) {
 		dev_err(dev, "Failed to register phy provider\n");
-		pm_runtime_disable(dev);
-		return PTR_ERR(phy_provider);
+		ret = PTR_ERR(phy_provider);
+		goto error;
 	}
 
 	return 0;
+
+error:
+	pm_runtime_disable(dev);
+	return ret;
 }
 
 static int rockchip_typec_phy_remove(struct platform_device *pdev)
--- a/drivers/pinctrl/pinctrl-rockchip.c
+++ b/drivers/pinctrl/pinctrl-rockchip.c
@@ -622,9 +622,9 @@ static struct rockchip_mux_recalced_data
 		/* gpio3b3_sel_plus */
 		.num = 3,
 		.pin = 11,
-		.reg = 0x68,
-		.bit = 6,
-		.mask = 0x3
+		.reg = 0x610,
+		.bit = 4,
+		.mask = 0x7
 	}, {
 		/* gpio3b4_sel */
 		.num = 3,
@@ -1223,6 +1223,19 @@ static int rockchip_set_mux(struct rockc
 	if (bank->recalced_mask & BIT(pin))
 		rockchip_get_recalced_mux(bank, pin, &reg, &bit, &mask);
 
+	/* rk3562 force jtag m1 */
+	if (ctrl->type == RK3562) {
+		if (bank->bank_num == 1) {
+			if ((pin == RK_PB5) || (pin == RK_PB6)) {
+				if (mux == 1) {
+					regmap_update_bits(regmap, 0x504, 0x10001, 0x10001);
+				} else {
+					regmap_update_bits(regmap, 0x504, 0x10001, 0x10000);
+				}
+			}
+		}
+	}
+
 	if (ctrl->type == RK3588) {
 		if (bank->bank_num == 0) {
 			if ((pin >= RK_PB4) && (pin <= RK_PD7)) {
@@ -2271,6 +2284,295 @@ static int rk3399_calc_drv_reg_and_bit(s
 	return 0;
 }
 
+#define RK3528_DRV_BITS_PER_PIN		8
+#define RK3528_DRV_PINS_PER_REG		2
+#define RK3528_DRV_GPIO0_OFFSET		0x100
+#define RK3528_DRV_GPIO1_OFFSET		0x20120
+#define RK3528_DRV_GPIO2_OFFSET		0x30160
+#define RK3528_DRV_GPIO3_OFFSET		0x20190
+#define RK3528_DRV_GPIO4_OFFSET		0x101C0
+
+static int rk3528_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_DRV_PINS_PER_REG;
+	*bit *= RK3528_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3528_PULL_BITS_PER_PIN		2
+#define RK3528_PULL_PINS_PER_REG		8
+#define RK3528_PULL_GPIO0_OFFSET		0x200
+#define RK3528_PULL_GPIO1_OFFSET		0x20210
+#define RK3528_PULL_GPIO2_OFFSET		0x30220
+#define RK3528_PULL_GPIO3_OFFSET		0x20230
+#define RK3528_PULL_GPIO4_OFFSET		0x10240
+
+static int rk3528_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_PULL_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_PULL_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_PULL_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_PULL_PINS_PER_REG;
+	*bit *= RK3528_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3528_SMT_BITS_PER_PIN		1
+#define RK3528_SMT_PINS_PER_REG		8
+#define RK3528_SMT_GPIO0_OFFSET		0x400
+#define RK3528_SMT_GPIO1_OFFSET		0x20410
+#define RK3528_SMT_GPIO2_OFFSET		0x30420
+#define RK3528_SMT_GPIO3_OFFSET		0x20430
+#define RK3528_SMT_GPIO4_OFFSET		0x10440
+
+static int rk3528_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3528_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3528_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3528_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3528_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3528_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3528_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3528_SMT_PINS_PER_REG;
+	*bit *= RK3528_SMT_BITS_PER_PIN;
+	return 0;
+}
+
+#define RK3562_DRV_BITS_PER_PIN		8
+#define RK3562_DRV_PINS_PER_REG		2
+#define RK3562_DRV_GPIO0_OFFSET		0x20070
+#define RK3562_DRV_GPIO1_OFFSET		0x200
+#define RK3562_DRV_GPIO2_OFFSET		0x240
+#define RK3562_DRV_GPIO3_OFFSET		0x10280
+#define RK3562_DRV_GPIO4_OFFSET		0x102C0
+
+static int rk3562_calc_drv_reg_and_bit(struct rockchip_pin_bank *bank,
+				       int pin_num, struct regmap **regmap,
+				       int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_DRV_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_DRV_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_DRV_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_DRV_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_DRV_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_DRV_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_DRV_PINS_PER_REG;
+	*bit *= RK3562_DRV_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3562_PULL_BITS_PER_PIN		2
+#define RK3562_PULL_PINS_PER_REG		8
+#define RK3562_PULL_GPIO0_OFFSET		0x20020
+#define RK3562_PULL_GPIO1_OFFSET		0x80
+#define RK3562_PULL_GPIO2_OFFSET		0x90
+#define RK3562_PULL_GPIO3_OFFSET		0x100A0
+#define RK3562_PULL_GPIO4_OFFSET		0x100B0
+
+static int rk3562_calc_pull_reg_and_bit(struct rockchip_pin_bank *bank,
+					int pin_num, struct regmap **regmap,
+					int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_PULL_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_PULL_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_PULL_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_PULL_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_PULL_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_PULL_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_PULL_PINS_PER_REG;
+	*bit *= RK3562_PULL_BITS_PER_PIN;
+
+	return 0;
+}
+
+#define RK3562_SMT_BITS_PER_PIN		2
+#define RK3562_SMT_PINS_PER_REG		8
+#define RK3562_SMT_GPIO0_OFFSET		0x20030
+#define RK3562_SMT_GPIO1_OFFSET		0xC0
+#define RK3562_SMT_GPIO2_OFFSET		0xD0
+#define RK3562_SMT_GPIO3_OFFSET		0x100E0
+#define RK3562_SMT_GPIO4_OFFSET		0x100F0
+
+static int rk3562_calc_schmitt_reg_and_bit(struct rockchip_pin_bank *bank,
+					   int pin_num,
+					   struct regmap **regmap,
+					   int *reg, u8 *bit)
+{
+	struct rockchip_pinctrl *info = bank->drvdata;
+
+	*regmap = info->regmap_base;
+	switch (bank->bank_num) {
+	case 0:
+		*reg = RK3562_SMT_GPIO0_OFFSET;
+		break;
+
+	case 1:
+		*reg = RK3562_SMT_GPIO1_OFFSET;
+		break;
+
+	case 2:
+		*reg = RK3562_SMT_GPIO2_OFFSET;
+		break;
+
+	case 3:
+		*reg = RK3562_SMT_GPIO3_OFFSET;
+		break;
+
+	case 4:
+		*reg = RK3562_SMT_GPIO4_OFFSET;
+		break;
+
+	default:
+		dev_err(info->dev, "unsupported bank_num %d\n", bank->bank_num);
+		break;
+	}
+
+	*reg += ((pin_num / RK3562_SMT_PINS_PER_REG) * 4);
+	*bit = pin_num % RK3562_SMT_PINS_PER_REG;
+	*bit *= RK3562_SMT_BITS_PER_PIN;
+
+	return 0;
+}
+
 #define RK3568_SR_PMU_OFFSET		0x60
 #define RK3568_SR_GRF_OFFSET		0x0180
 #define RK3568_SR_BANK_STRIDE		0x10
@@ -2371,108 +2673,108 @@ static int rk3568_calc_drv_reg_and_bit(s
 	return 0;
 }
 
-#define RK3588_PMU1_IOC_REG		0x0000
-#define RK3588_PMU2_IOC_REG		0x4000
-#define RK3588_BUS_IOC_REG		0x8000
-#define RK3588_VCCIO1_4_IOC_REG		0x9000
-#define RK3588_VCCIO3_5_IOC_REG		0xA000
-#define RK3588_VCCIO2_IOC_REG		0xB000
-#define RK3588_VCCIO6_IOC_REG		0xC000
-#define RK3588_EMMC_IOC_REG		0xD000
+#define RK3588_PMU1_IOC_REG		(0x0000)
+#define RK3588_PMU2_IOC_REG		(0x4000)
+#define RK3588_BUS_IOC_REG		(0x8000)
+#define RK3588_VCCIO1_4_IOC_REG		(0x9000)
+#define RK3588_VCCIO3_5_IOC_REG		(0xA000)
+#define RK3588_VCCIO2_IOC_REG		(0xB000)
+#define RK3588_VCCIO6_IOC_REG		(0xC000)
+#define RK3588_EMMC_IOC_REG		(0xD000)
 
 static const u32 rk3588_ds_regs[][2] = {
-	{ RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0010 },
-	{ RK_GPIO0_A4, RK3588_PMU1_IOC_REG + 0x0014 },
-	{ RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0018 },
-	{ RK_GPIO0_B4, RK3588_PMU2_IOC_REG + 0x0014 },
-	{ RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0018 },
-	{ RK_GPIO0_C4, RK3588_PMU2_IOC_REG + 0x001C },
-	{ RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0020 },
-	{ RK_GPIO0_D4, RK3588_PMU2_IOC_REG + 0x0024 },
-	{ RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0020 },
-	{ RK_GPIO1_A4, RK3588_VCCIO1_4_IOC_REG + 0x0024 },
-	{ RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0028 },
-	{ RK_GPIO1_B4, RK3588_VCCIO1_4_IOC_REG + 0x002C },
-	{ RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0030 },
-	{ RK_GPIO1_C4, RK3588_VCCIO1_4_IOC_REG + 0x0034 },
-	{ RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x0038 },
-	{ RK_GPIO1_D4, RK3588_VCCIO1_4_IOC_REG + 0x003C },
-	{ RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0040 },
-	{ RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0044 },
-	{ RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0048 },
-	{ RK_GPIO2_B4, RK3588_VCCIO3_5_IOC_REG + 0x004C },
-	{ RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0050 },
-	{ RK_GPIO2_C4, RK3588_VCCIO3_5_IOC_REG + 0x0054 },
-	{ RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x0058 },
-	{ RK_GPIO2_D4, RK3588_EMMC_IOC_REG + 0x005C },
-	{ RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0060 },
-	{ RK_GPIO3_A4, RK3588_VCCIO3_5_IOC_REG + 0x0064 },
-	{ RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0068 },
-	{ RK_GPIO3_B4, RK3588_VCCIO3_5_IOC_REG + 0x006C },
-	{ RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0070 },
-	{ RK_GPIO3_C4, RK3588_VCCIO3_5_IOC_REG + 0x0074 },
-	{ RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x0078 },
-	{ RK_GPIO3_D4, RK3588_VCCIO3_5_IOC_REG + 0x007C },
-	{ RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0080 },
-	{ RK_GPIO4_A4, RK3588_VCCIO6_IOC_REG + 0x0084 },
-	{ RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0088 },
-	{ RK_GPIO4_B4, RK3588_VCCIO6_IOC_REG + 0x008C },
-	{ RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0090 },
-	{ RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0090 },
-	{ RK_GPIO4_C4, RK3588_VCCIO3_5_IOC_REG + 0x0094 },
-	{ RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x0098 },
+	{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0010},
+	{RK_GPIO0_A4, RK3588_PMU1_IOC_REG + 0x0014},
+	{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0018},
+	{RK_GPIO0_B4, RK3588_PMU2_IOC_REG + 0x0014},
+	{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0018},
+	{RK_GPIO0_C4, RK3588_PMU2_IOC_REG + 0x001C},
+	{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0020},
+	{RK_GPIO0_D4, RK3588_PMU2_IOC_REG + 0x0024},
+	{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0020},
+	{RK_GPIO1_A4, RK3588_VCCIO1_4_IOC_REG + 0x0024},
+	{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0028},
+	{RK_GPIO1_B4, RK3588_VCCIO1_4_IOC_REG + 0x002C},
+	{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0030},
+	{RK_GPIO1_C4, RK3588_VCCIO1_4_IOC_REG + 0x0034},
+	{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x0038},
+	{RK_GPIO1_D4, RK3588_VCCIO1_4_IOC_REG + 0x003C},
+	{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0040},
+	{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0044},
+	{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0048},
+	{RK_GPIO2_B4, RK3588_VCCIO3_5_IOC_REG + 0x004C},
+	{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0050},
+	{RK_GPIO2_C4, RK3588_VCCIO3_5_IOC_REG + 0x0054},
+	{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x0058},
+	{RK_GPIO2_D4, RK3588_EMMC_IOC_REG + 0x005C},
+	{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0060},
+	{RK_GPIO3_A4, RK3588_VCCIO3_5_IOC_REG + 0x0064},
+	{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0068},
+	{RK_GPIO3_B4, RK3588_VCCIO3_5_IOC_REG + 0x006C},
+	{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0070},
+	{RK_GPIO3_C4, RK3588_VCCIO3_5_IOC_REG + 0x0074},
+	{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x0078},
+	{RK_GPIO3_D4, RK3588_VCCIO3_5_IOC_REG + 0x007C},
+	{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0080},
+	{RK_GPIO4_A4, RK3588_VCCIO6_IOC_REG + 0x0084},
+	{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0088},
+	{RK_GPIO4_B4, RK3588_VCCIO6_IOC_REG + 0x008C},
+	{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0090},
+	{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0090},
+	{RK_GPIO4_C4, RK3588_VCCIO3_5_IOC_REG + 0x0094},
+	{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x0098},
 };
 
 static const u32 rk3588_p_regs[][2] = {
-	{ RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0020 },
-	{ RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0024 },
-	{ RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0028 },
-	{ RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x002C },
-	{ RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0030 },
-	{ RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0110 },
-	{ RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0114 },
-	{ RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0118 },
-	{ RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x011C },
-	{ RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0120 },
-	{ RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0120 },
-	{ RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0124 },
-	{ RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0128 },
-	{ RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x012C },
-	{ RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0130 },
-	{ RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0134 },
-	{ RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0138 },
-	{ RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x013C },
-	{ RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0140 },
-	{ RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0144 },
-	{ RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0148 },
-	{ RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0148 },
-	{ RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x014C },
+	{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0020},
+	{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0024},
+	{RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0028},
+	{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x002C},
+	{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0030},
+	{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0110},
+	{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0114},
+	{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0118},
+	{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x011C},
+	{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0120},
+	{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0120},
+	{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0124},
+	{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0128},
+	{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x012C},
+	{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0130},
+	{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0134},
+	{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0138},
+	{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x013C},
+	{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0140},
+	{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0144},
+	{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0148},
+	{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0148},
+	{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x014C},
 };
 
 static const u32 rk3588_smt_regs[][2] = {
-	{ RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0030 },
-	{ RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0034 },
-	{ RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0040 },
-	{ RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0044 },
-	{ RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0048 },
-	{ RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0210 },
-	{ RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0214 },
-	{ RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0218 },
-	{ RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x021C },
-	{ RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0220 },
-	{ RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0220 },
-	{ RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0224 },
-	{ RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0228 },
-	{ RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x022C },
-	{ RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0230 },
-	{ RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0234 },
-	{ RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0238 },
-	{ RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x023C },
-	{ RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0240 },
-	{ RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0244 },
-	{ RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0248 },
-	{ RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0248 },
-	{ RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x024C },
+	{RK_GPIO0_A0, RK3588_PMU1_IOC_REG + 0x0030},
+	{RK_GPIO0_B0, RK3588_PMU1_IOC_REG + 0x0034},
+	{RK_GPIO0_B5, RK3588_PMU2_IOC_REG + 0x0040},
+	{RK_GPIO0_C0, RK3588_PMU2_IOC_REG + 0x0044},
+	{RK_GPIO0_D0, RK3588_PMU2_IOC_REG + 0x0048},
+	{RK_GPIO1_A0, RK3588_VCCIO1_4_IOC_REG + 0x0210},
+	{RK_GPIO1_B0, RK3588_VCCIO1_4_IOC_REG + 0x0214},
+	{RK_GPIO1_C0, RK3588_VCCIO1_4_IOC_REG + 0x0218},
+	{RK_GPIO1_D0, RK3588_VCCIO1_4_IOC_REG + 0x021C},
+	{RK_GPIO2_A0, RK3588_EMMC_IOC_REG + 0x0220},
+	{RK_GPIO2_A4, RK3588_VCCIO3_5_IOC_REG + 0x0220},
+	{RK_GPIO2_B0, RK3588_VCCIO3_5_IOC_REG + 0x0224},
+	{RK_GPIO2_C0, RK3588_VCCIO3_5_IOC_REG + 0x0228},
+	{RK_GPIO2_D0, RK3588_EMMC_IOC_REG + 0x022C},
+	{RK_GPIO3_A0, RK3588_VCCIO3_5_IOC_REG + 0x0230},
+	{RK_GPIO3_B0, RK3588_VCCIO3_5_IOC_REG + 0x0234},
+	{RK_GPIO3_C0, RK3588_VCCIO3_5_IOC_REG + 0x0238},
+	{RK_GPIO3_D0, RK3588_VCCIO3_5_IOC_REG + 0x023C},
+	{RK_GPIO4_A0, RK3588_VCCIO6_IOC_REG + 0x0240},
+	{RK_GPIO4_B0, RK3588_VCCIO6_IOC_REG + 0x0244},
+	{RK_GPIO4_C0, RK3588_VCCIO6_IOC_REG + 0x0248},
+	{RK_GPIO4_C2, RK3588_VCCIO3_5_IOC_REG + 0x0248},
+	{RK_GPIO4_D0, RK3588_VCCIO2_IOC_REG + 0x024C},
 };
 
 #define RK3588_PULL_BITS_PER_PIN		2
@@ -2686,7 +2988,10 @@ static int rockchip_set_drive_perpin(str
 		rmask_bits = RV1126_DRV_BITS_PER_PIN;
 		ret = strength;
 		goto config;
-	} else if (ctrl->type == RV1106 || ctrl->type == RK3568) {
+	} else if (ctrl->type == RV1106 ||
+		   ctrl->type == RK3528 ||
+		   ctrl->type == RK3562 ||
+		   ctrl->type == RK3568) {
 		rmask_bits = RK3568_DRV_BITS_PER_PIN;
 		ret = (1 << (strength + 1)) - 1;
 		goto config;
@@ -2858,6 +3163,8 @@ static int rockchip_get_pull(struct rock
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		pull_type = bank->pull_type[pin_num / 8];
@@ -2910,6 +3217,8 @@ static int rockchip_set_pull(struct rock
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		pull_type = bank->pull_type[pin_num / 8];
@@ -3020,6 +3329,7 @@ static int rockchip_get_schmitt(struct r
 
 	data >>= bit;
 	switch (ctrl->type) {
+	case RK3562:
 	case RK3568:
 		return data & ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1);
 	default:
@@ -3049,6 +3359,7 @@ static int rockchip_set_schmitt(struct r
 
 	/* enable the write to the equivalent lower bits */
 	switch (ctrl->type) {
+	case RK3562:
 	case RK3568:
 		data = ((1 << RK3568_SCHMITT_BITS_PER_PIN) - 1) << (bit + 16);
 		rmask = data | (data >> 16);
@@ -3244,6 +3555,8 @@ static bool rockchip_pinconf_pull_valid(
 	case RK3308:
 	case RK3368:
 	case RK3399:
+	case RK3528:
+	case RK3562:
 	case RK3568:
 	case RK3588:
 		return (pull != PIN_CONFIG_BIAS_PULL_PIN_DEFAULT);
@@ -4532,6 +4845,92 @@ static struct rockchip_pin_ctrl rk3399_p
 		.drv_calc_reg		= rk3399_calc_drv_reg_and_bit,
 };
 
+static struct rockchip_pin_bank rk3528_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS_OFFSET(0, 32, "gpio0",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20020, 0x20028, 0x20030, 0x20038),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x30040, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20060, 0x20068, 0x20070, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 32, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10080, 0x10088, 0x10090, 0x10098),
+};
+
+static struct rockchip_pin_ctrl rk3528_pin_ctrl __maybe_unused = {
+	.pin_banks		= rk3528_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rk3528_pin_banks),
+	.label			= "RK3528-GPIO",
+	.type			= RK3528,
+	.pull_calc_reg		= rk3528_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rk3528_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rk3528_calc_schmitt_reg_and_bit,
+};
+
+static struct rockchip_pin_bank rk3562_pin_banks[] = {
+	PIN_BANK_IOMUX_FLAGS_OFFSET(0, 32, "gpio0",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20000, 0x20008, 0x20010, 0x20018),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(1, 32, "gpio1",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0, 0x08, 0x10, 0x18),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(2, 32, "gpio2",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x20, 0, 0, 0),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(3, 32, "gpio3",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0x10040, 0x10048, 0x10050, 0x10058),
+	PIN_BANK_IOMUX_FLAGS_OFFSET(4, 16, "gpio4",
+				    IOMUX_WIDTH_4BIT,
+				    IOMUX_WIDTH_4BIT,
+				    0,
+				    0,
+				    0x10060, 0x10068, 0, 0),
+};
+
+static struct rockchip_pin_ctrl rk3562_pin_ctrl __maybe_unused = {
+	.pin_banks		= rk3562_pin_banks,
+	.nr_banks		= ARRAY_SIZE(rk3562_pin_banks),
+	.label			= "RK3562-GPIO",
+	.type			= RK3562,
+	.pull_calc_reg		= rk3562_calc_pull_reg_and_bit,
+	.drv_calc_reg		= rk3562_calc_drv_reg_and_bit,
+	.schmitt_calc_reg	= rk3562_calc_schmitt_reg_and_bit,
+};
+
 static struct rockchip_pin_bank rk3568_pin_banks[] = {
 	PIN_BANK_IOMUX_FLAGS(0, 32, "gpio0", IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,
 					     IOMUX_SOURCE_PMU | IOMUX_WIDTH_4BIT,
@@ -4662,6 +5061,14 @@ static const struct of_device_id rockchi
 	{ .compatible = "rockchip,rk3399-pinctrl",
 		.data = &rk3399_pin_ctrl },
 #endif
+#ifdef CONFIG_CPU_RK3528
+	{ .compatible = "rockchip,rk3528-pinctrl",
+		.data = &rk3528_pin_ctrl },
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{ .compatible = "rockchip,rk3562-pinctrl",
+		.data = &rk3562_pin_ctrl },
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{ .compatible = "rockchip,rk3568-pinctrl",
 		.data = &rk3568_pin_ctrl },
--- a/drivers/regulator/fan53555.c
+++ b/drivers/regulator/fan53555.c
@@ -21,22 +21,16 @@
 #include <linux/regulator/machine.h>
 #include <linux/regulator/of_regulator.h>
 #include <linux/slab.h>
-#include <linux/gpio.h>
-#include <linux/of_gpio.h>
 
 /* Voltage setting */
 #define FAN53555_VSEL0		0x00
 #define FAN53555_VSEL1		0x01
 
-#define RK860X_VSEL0		0x06
-#define RK860X_VSEL1		0x07
-#define RK860X_MAX_SET		0x08
-
-#define TCS452X_VSEL0		0x11
-#define TCS452X_VSEL1		0x10
-#define TCS452X_TIME		0x13
-#define TCS452X_COMMAND		0x14
-#define TCS452X_LIMCONF		0x16
+#define TCS4525_VSEL0		0x11
+#define TCS4525_VSEL1		0x10
+#define TCS4525_TIME		0x13
+#define TCS4525_COMMAND		0x14
+#define TCS4525_LIMCONF		0x16
 
 /* Control register */
 #define FAN53555_CONTROL	0x02
@@ -50,7 +44,6 @@
 /* VSEL bit definitions */
 #define VSEL_BUCK_EN	(1 << 7)
 #define VSEL_MODE		(1 << 6)
-#define VSEL_NSEL_MASK	0x3F
 /* Chip ID and Verison */
 #define DIE_ID		0x0F	/* ID1 */
 #define DIE_REV		0x0F	/* ID2 */
@@ -62,25 +55,20 @@
 #define CTL_MODE_VSEL0_MODE	BIT(0)
 #define CTL_MODE_VSEL1_MODE	BIT(1)
 
-#define RK_VSEL_NSEL_MASK	0xff
+#define FAN53555_NVOLTAGES	64	/* Numbers of voltages */
+#define FAN53526_NVOLTAGES	128
 
-#define TCS_VSEL_NSEL_MASK	0x7f
 #define TCS_VSEL0_MODE		(1 << 7)
 #define TCS_VSEL1_MODE		(1 << 6)
 
 #define TCS_SLEW_SHIFT		3
 #define TCS_SLEW_MASK		(0x3 < 3)
 
-#define FAN53555_NVOLTAGES_64	64	/* Numbers of voltages */
-#define FAN53555_NVOLTAGES_127	127	/* Numbers of voltages */
-#define FAN53555_NVOLTAGES_160	160	/* Numbers of voltages */
-
 enum fan53555_vendor {
 	FAN53526_VENDOR_FAIRCHILD = 0,
 	FAN53555_VENDOR_FAIRCHILD,
-	FAN53555_VENDOR_RK,
 	FAN53555_VENDOR_SILERGY,
-	FAN53555_VENDOR_TCS,
+	FAN53526_VENDOR_TCS,
 };
 
 enum {
@@ -102,6 +90,14 @@ enum {
 	FAN53555_CHIP_ID_08 = 8,
 };
 
+enum {
+	TCS4525_CHIP_ID_12 = 12,
+};
+
+enum {
+	TCS4526_CHIP_ID_00 = 0,
+};
+
 /* IC mask revision */
 enum {
 	FAN53555_CHIP_REV_00 = 0x3,
@@ -118,7 +114,6 @@ struct fan53555_device_info {
 	struct regmap *regmap;
 	struct device *dev;
 	struct regulator_desc desc;
-	struct regulator_dev *rdev;
 	struct regulator_init_data *regulator;
 	/* IC Type and Rev */
 	int chip_id;
@@ -126,24 +121,20 @@ struct fan53555_device_info {
 	/* Voltage setting register */
 	unsigned int vol_reg;
 	unsigned int sleep_reg;
-	unsigned int en_reg;
-	unsigned int sleep_en_reg;
+	/* Voltage range and step(linear) */
+	unsigned int vsel_min;
+	unsigned int vsel_step;
+	unsigned int vsel_count;
+	/* Mode */
 	unsigned int mode_reg;
-	unsigned int vol_mask;
 	unsigned int mode_mask;
+	/* Sleep voltage cache */
+	unsigned int sleep_vol_cache;
+	/* Slew rate */
 	unsigned int slew_reg;
 	unsigned int slew_mask;
 	unsigned int slew_shift;
-	/* Voltage range and step(linear) */
-	unsigned int vsel_min;
-	unsigned int vsel_step;
-	unsigned int n_voltages;
-	/* Voltage slew rate limiting */
 	unsigned int slew_rate;
-	/* Sleep voltage cache */
-	unsigned int sleep_vol_cache;
-	struct gpio_desc *vsel_gpio;
-	unsigned int sleep_vsel_id;
 };
 
 static unsigned int fan53555_map_mode(unsigned int mode)
@@ -152,26 +143,6 @@ static unsigned int fan53555_map_mode(un
 		REGULATOR_MODE_FAST : REGULATOR_MODE_NORMAL;
 }
 
-static int fan53555_get_voltage(struct regulator_dev *rdev)
-{
-	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
-	unsigned int val;
-	int ret;
-
-	if (di->vendor == FAN53555_VENDOR_RK) {
-		ret = regmap_read(di->regmap, RK860X_MAX_SET, &val);
-		if (ret < 0)
-			return ret;
-		ret = regulator_get_voltage_sel_regmap(rdev);
-		if (ret > val)
-			return val;
-	} else {
-		ret = regulator_get_voltage_sel_regmap(rdev);
-	}
-
-	return ret;
-}
-
 static int fan53555_set_suspend_voltage(struct regulator_dev *rdev, int uV)
 {
 	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
@@ -182,8 +153,8 @@ static int fan53555_set_suspend_voltage(
 	ret = regulator_map_voltage_linear(rdev, uV, uV);
 	if (ret < 0)
 		return ret;
-	ret = regmap_update_bits(di->regmap, di->sleep_reg,
-				 di->vol_mask, ret);
+	ret = regmap_update_bits(rdev->regmap, di->sleep_reg,
+				 di->desc.vsel_mask, ret);
 	if (ret < 0)
 		return ret;
 	/* Cache the sleep voltage setting.
@@ -197,7 +168,7 @@ static int fan53555_set_suspend_enable(s
 {
 	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
 
-	return regmap_update_bits(di->regmap, di->sleep_en_reg,
+	return regmap_update_bits(rdev->regmap, di->sleep_reg,
 				  VSEL_BUCK_EN, VSEL_BUCK_EN);
 }
 
@@ -205,69 +176,21 @@ static int fan53555_set_suspend_disable(
 {
 	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
 
-	return regmap_update_bits(di->regmap, di->sleep_en_reg,
-				  VSEL_BUCK_EN, 0);
-}
-
-static int fan53555_set_enable(struct regulator_dev *rdev)
-{
-	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
-
-	if (di->vsel_gpio) {
-		gpiod_set_raw_value(di->vsel_gpio, !di->sleep_vsel_id);
-		return 0;
-	}
-
-	return regmap_update_bits(di->regmap, di->en_reg,
-				  VSEL_BUCK_EN, VSEL_BUCK_EN);
-}
-
-static int fan53555_set_disable(struct regulator_dev *rdev)
-{
-	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
-
-	if (di->vsel_gpio) {
-		gpiod_set_raw_value(di->vsel_gpio, di->sleep_vsel_id);
-		return 0;
-	}
-
-	return regmap_update_bits(di->regmap, di->en_reg,
+	return regmap_update_bits(rdev->regmap, di->sleep_reg,
 				  VSEL_BUCK_EN, 0);
 }
 
-static int fan53555_is_enabled(struct regulator_dev *rdev)
-{
-	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
-	unsigned int val;
-	int ret = 0;
-
-	if (di->vsel_gpio) {
-		if (di->sleep_vsel_id)
-			return !gpiod_get_raw_value(di->vsel_gpio);
-		else
-			return gpiod_get_raw_value(di->vsel_gpio);
-	}
-
-	ret = regmap_read(di->regmap, di->en_reg, &val);
-	if (ret < 0)
-		return ret;
-	if (val & VSEL_BUCK_EN)
-		return 1;
-	else
-		return 0;
-}
-
 static int fan53555_set_mode(struct regulator_dev *rdev, unsigned int mode)
 {
 	struct fan53555_device_info *di = rdev_get_drvdata(rdev);
 
 	switch (mode) {
 	case REGULATOR_MODE_FAST:
-		regmap_update_bits(di->regmap, di->mode_reg,
+		regmap_update_bits(rdev->regmap, di->mode_reg,
 				   di->mode_mask, di->mode_mask);
 		break;
 	case REGULATOR_MODE_NORMAL:
-		regmap_update_bits(di->regmap, di->mode_reg, di->mode_mask, 0);
+		regmap_update_bits(rdev->regmap, di->vol_reg, di->mode_mask, 0);
 		break;
 	default:
 		return -EINVAL;
@@ -281,7 +204,7 @@ static unsigned int fan53555_get_mode(st
 	unsigned int val;
 	int ret = 0;
 
-	ret = regmap_read(di->regmap, di->mode_reg, &val);
+	ret = regmap_read(rdev->regmap, di->mode_reg, &val);
 	if (ret < 0)
 		return ret;
 	if (val & di->mode_mask)
@@ -316,13 +239,13 @@ static int fan53555_set_ramp(struct regu
 	int slew_rate_n;
 
 	switch (di->vendor) {
+	case FAN53526_VENDOR_FAIRCHILD:
 	case FAN53555_VENDOR_FAIRCHILD:
-	case FAN53555_VENDOR_RK:
 	case FAN53555_VENDOR_SILERGY:
 		slew_rate_t = slew_rates;
 		slew_rate_n = ARRAY_SIZE(slew_rates);
 		break;
-	case FAN53555_VENDOR_TCS:
+	case FAN53526_VENDOR_TCS:
 		slew_rate_t = tcs_slew_rates;
 		slew_rate_n = ARRAY_SIZE(tcs_slew_rates);
 		break;
@@ -342,20 +265,20 @@ static int fan53555_set_ramp(struct regu
 		return -EINVAL;
 	}
 
-	return regmap_update_bits(di->regmap, di->slew_reg,
+	return regmap_update_bits(rdev->regmap, di->slew_reg,
 				  di->slew_mask, regval << di->slew_shift);
 }
 
 static const struct regulator_ops fan53555_regulator_ops = {
 	.set_voltage_sel = regulator_set_voltage_sel_regmap,
-	.get_voltage_sel = fan53555_get_voltage,
+	.get_voltage_sel = regulator_get_voltage_sel_regmap,
 	.set_voltage_time_sel = regulator_set_voltage_time_sel,
 	.map_voltage = regulator_map_voltage_linear,
 	.list_voltage = regulator_list_voltage_linear,
 	.set_suspend_voltage = fan53555_set_suspend_voltage,
-	.enable = fan53555_set_enable,
-	.disable = fan53555_set_disable,
-	.is_enabled = fan53555_is_enabled,
+	.enable = regulator_enable_regmap,
+	.disable = regulator_disable_regmap,
+	.is_enabled = regulator_is_enabled_regmap,
 	.set_mode = fan53555_set_mode,
 	.get_mode = fan53555_get_mode,
 	.set_ramp_delay = fan53555_set_ramp,
@@ -386,7 +309,10 @@ static int fan53526_voltages_setup_fairc
 		return -EINVAL;
 	}
 
-	di->n_voltages = FAN53555_NVOLTAGES_64;
+	di->slew_reg = FAN53555_CONTROL;
+	di->slew_mask = CTL_SLEW_MASK;
+	di->slew_shift = CTL_SLEW_SHIFT;
+	di->vsel_count = FAN53526_NVOLTAGES;
 
 	return 0;
 }
@@ -428,58 +354,10 @@ static int fan53555_voltages_setup_fairc
 			"Chip ID %d not supported!\n", di->chip_id);
 		return -EINVAL;
 	}
-	di->vol_mask = VSEL_NSEL_MASK;
-	di->mode_reg = di->vol_reg;
-	di->mode_mask = VSEL_MODE;
-	di->slew_reg = FAN53555_CONTROL;
-	di->slew_mask = CTL_SLEW_MASK;
-	di->slew_shift = CTL_SLEW_SHIFT;
-	di->n_voltages = FAN53555_NVOLTAGES_64;
-
-	return 0;
-}
-
-static int fan53555_voltages_setup_rk(struct fan53555_device_info *di,
-				      struct fan53555_platform_data *pdata)
-{
-	int ret = 0, val;
-
-	if (di->sleep_vsel_id) {
-		di->sleep_reg = RK860X_VSEL1;
-		di->vol_reg = RK860X_VSEL0;
-		di->mode_reg = FAN53555_VSEL0;
-		di->en_reg = FAN53555_VSEL0;
-		di->sleep_en_reg = FAN53555_VSEL1;
-	} else {
-		di->sleep_reg = RK860X_VSEL0;
-		di->vol_reg = RK860X_VSEL1;
-		di->mode_reg = FAN53555_VSEL1;
-		di->en_reg = FAN53555_VSEL1;
-		di->sleep_en_reg = FAN53555_VSEL0;
-	}
-
-	di->mode_mask = VSEL_MODE;
-	di->vol_mask = RK_VSEL_NSEL_MASK;
 	di->slew_reg = FAN53555_CONTROL;
 	di->slew_mask = CTL_SLEW_MASK;
 	di->slew_shift = CTL_SLEW_SHIFT;
-
-	/* Init voltage range and step */
-	di->vsel_min = 500000;
-	di->vsel_step = 6250;
-	di->n_voltages = FAN53555_NVOLTAGES_160;
-
-	if (pdata->limit_volt) {
-		if (pdata->limit_volt < di->vsel_min ||
-		    pdata->limit_volt > 1500000)
-			pdata->limit_volt = 1500000;
-		val = (pdata->limit_volt - di->vsel_min) / di->vsel_step;
-		ret = regmap_write(di->regmap, RK860X_MAX_SET, val);
-		if (ret < 0) {
-			dev_err(di->dev, "Failed to set limit voltage!\n");
-			return ret;
-		}
-	}
+	di->vsel_count = FAN53555_NVOLTAGES;
 
 	return 0;
 }
@@ -498,43 +376,32 @@ static int fan53555_voltages_setup_siler
 			"Chip ID %d not supported!\n", di->chip_id);
 		return -EINVAL;
 	}
-	di->vol_mask = VSEL_NSEL_MASK;
-	di->mode_reg = di->vol_reg;
-	di->mode_mask = VSEL_MODE;
-	di->slew_reg = FAN53555_CONTROL;
 	di->slew_reg = FAN53555_CONTROL;
 	di->slew_mask = CTL_SLEW_MASK;
 	di->slew_shift = CTL_SLEW_SHIFT;
-	di->n_voltages = FAN53555_NVOLTAGES_64;
+	di->vsel_count = FAN53555_NVOLTAGES;
 
 	return 0;
 }
 
-static int fan53555_voltages_setup_tcs(struct fan53555_device_info *di)
+static int fan53526_voltages_setup_tcs(struct fan53555_device_info *di)
 {
-	if (di->sleep_vsel_id) {
-		di->sleep_reg = TCS452X_VSEL1;
-		di->vol_reg = TCS452X_VSEL0;
-		di->mode_mask = TCS_VSEL0_MODE;
-	} else {
-		di->sleep_reg = TCS452X_VSEL0;
-		di->vol_reg = TCS452X_VSEL1;
-		di->mode_mask = TCS_VSEL1_MODE;
-	}
-
-	di->mode_reg = TCS452X_COMMAND;
-	di->vol_mask = TCS_VSEL_NSEL_MASK;
-	di->slew_reg = TCS452X_TIME;
-	di->slew_mask = TCS_SLEW_MASK;
-	di->slew_shift = TCS_SLEW_MASK;
-
-	/* Init voltage range and step */
-	di->vsel_min = 600000;
-	di->vsel_step = 6250;
-	di->n_voltages = FAN53555_NVOLTAGES_127;
+	switch (di->chip_id) {
+	case TCS4525_CHIP_ID_12:
+	case TCS4526_CHIP_ID_00:
+		di->slew_reg = TCS4525_TIME;
+		di->slew_mask = TCS_SLEW_MASK;
+		di->slew_shift = TCS_SLEW_SHIFT;
 
-	di->en_reg = di->vol_reg;
-	di->sleep_en_reg = di->sleep_reg;
+		/* Init voltage range and step */
+		di->vsel_min = 600000;
+		di->vsel_step = 6250;
+		di->vsel_count = FAN53526_NVOLTAGES;
+		break;
+	default:
+		dev_err(di->dev, "Chip ID %d not supported!\n", di->chip_id);
+		return -EINVAL;
+	}
 
 	return 0;
 }
@@ -550,24 +417,45 @@ static int fan53555_device_setup(struct
 	int ret = 0;
 
 	/* Setup voltage control register */
-	switch (pdata->sleep_vsel_id) {
-	case FAN53555_VSEL_ID_0:
-		di->sleep_reg = FAN53555_VSEL0;
-		di->vol_reg = FAN53555_VSEL1;
-		break;
-	case FAN53555_VSEL_ID_1:
-		di->sleep_reg = FAN53555_VSEL1;
-		di->vol_reg = FAN53555_VSEL0;
+	switch (di->vendor) {
+	case FAN53526_VENDOR_FAIRCHILD:
+	case FAN53555_VENDOR_FAIRCHILD:
+	case FAN53555_VENDOR_SILERGY:
+		switch (pdata->sleep_vsel_id) {
+		case FAN53555_VSEL_ID_0:
+			di->sleep_reg = FAN53555_VSEL0;
+			di->vol_reg = FAN53555_VSEL1;
+			break;
+		case FAN53555_VSEL_ID_1:
+			di->sleep_reg = FAN53555_VSEL1;
+			di->vol_reg = FAN53555_VSEL0;
+			break;
+		default:
+			dev_err(di->dev, "Invalid VSEL ID!\n");
+			return -EINVAL;
+		}
+		break;
+	case FAN53526_VENDOR_TCS:
+		switch (pdata->sleep_vsel_id) {
+		case FAN53555_VSEL_ID_0:
+			di->sleep_reg = TCS4525_VSEL0;
+			di->vol_reg = TCS4525_VSEL1;
+			break;
+		case FAN53555_VSEL_ID_1:
+			di->sleep_reg = TCS4525_VSEL1;
+			di->vol_reg = TCS4525_VSEL0;
+			break;
+		default:
+			dev_err(di->dev, "Invalid VSEL ID!\n");
+			return -EINVAL;
+		}
 		break;
 	default:
-		dev_err(di->dev, "Invalid VSEL ID!\n");
+		dev_err(di->dev, "vendor %d not supported!\n", di->vendor);
 		return -EINVAL;
 	}
 
-	di->en_reg = di->vol_reg;
-	di->sleep_en_reg = di->sleep_reg;
-
-	/* Setup voltage range */
+	/* Setup mode control register */
 	switch (di->vendor) {
 	case FAN53526_VENDOR_FAIRCHILD:
 		di->mode_reg = FAN53555_CONTROL;
@@ -580,19 +468,42 @@ static int fan53555_device_setup(struct
 			di->mode_mask = CTL_MODE_VSEL0_MODE;
 			break;
 		}
+		break;
+	case FAN53555_VENDOR_FAIRCHILD:
+	case FAN53555_VENDOR_SILERGY:
+		di->mode_reg = di->vol_reg;
+		di->mode_mask = VSEL_MODE;
+		break;
+	case FAN53526_VENDOR_TCS:
+		di->mode_reg = TCS4525_COMMAND;
+
+		switch (pdata->sleep_vsel_id) {
+		case FAN53555_VSEL_ID_0:
+			di->mode_mask = TCS_VSEL1_MODE;
+			break;
+		case FAN53555_VSEL_ID_1:
+			di->mode_mask = TCS_VSEL0_MODE;
+			break;
+		}
+		break;
+	default:
+		dev_err(di->dev, "vendor %d not supported!\n", di->vendor);
+		return -EINVAL;
+	}
+
+	/* Setup voltage range */
+	switch (di->vendor) {
+	case FAN53526_VENDOR_FAIRCHILD:
 		ret = fan53526_voltages_setup_fairchild(di);
 		break;
 	case FAN53555_VENDOR_FAIRCHILD:
 		ret = fan53555_voltages_setup_fairchild(di);
 		break;
-	case FAN53555_VENDOR_RK:
-		ret = fan53555_voltages_setup_rk(di, pdata);
-		break;
 	case FAN53555_VENDOR_SILERGY:
 		ret = fan53555_voltages_setup_silergy(di);
 		break;
-	case FAN53555_VENDOR_TCS:
-		ret = fan53555_voltages_setup_tcs(di);
+	case FAN53526_VENDOR_TCS:
+		ret = fan53526_voltages_setup_tcs(di);
 		break;
 	default:
 		dev_err(di->dev, "vendor %d not supported!\n", di->vendor);
@@ -606,23 +517,23 @@ static int fan53555_regulator_register(s
 			struct regulator_config *config)
 {
 	struct regulator_desc *rdesc = &di->desc;
+	struct regulator_dev *rdev;
 
 	rdesc->name = "fan53555-reg";
 	rdesc->supply_name = "vin";
 	rdesc->ops = &fan53555_regulator_ops;
 	rdesc->type = REGULATOR_VOLTAGE;
-	rdesc->n_voltages = di->n_voltages;
-	rdesc->enable_reg = di->en_reg;
+	rdesc->n_voltages = di->vsel_count;
+	rdesc->enable_reg = di->vol_reg;
 	rdesc->enable_mask = VSEL_BUCK_EN;
 	rdesc->min_uV = di->vsel_min;
 	rdesc->uV_step = di->vsel_step;
 	rdesc->vsel_reg = di->vol_reg;
-	rdesc->vsel_mask = di->vol_mask;
+	rdesc->vsel_mask = di->vsel_count - 1;
 	rdesc->owner = THIS_MODULE;
-	rdesc->enable_time = 400;
 
-	di->rdev = devm_regulator_register(di->dev, &di->desc, config);
-	return PTR_ERR_OR_ZERO(di->rdev);
+	rdev = devm_regulator_register(di->dev, &di->desc, config);
+	return PTR_ERR_OR_ZERO(rdev);
 }
 
 static const struct regmap_config fan53555_regmap_config = {
@@ -635,7 +546,7 @@ static struct fan53555_platform_data *fa
 					      const struct regulator_desc *desc)
 {
 	struct fan53555_platform_data *pdata;
-	int ret, flag, limit_volt;
+	int ret;
 	u32 tmp;
 
 	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
@@ -643,30 +554,12 @@ static struct fan53555_platform_data *fa
 		return NULL;
 
 	pdata->regulator = of_get_regulator_init_data(dev, np, desc);
-	pdata->regulator->constraints.initial_state = PM_SUSPEND_MEM;
-
-	if (!(of_property_read_u32(np, "limit-microvolt", &limit_volt)))
-		pdata->limit_volt = limit_volt;
 
 	ret = of_property_read_u32(np, "fcs,suspend-voltage-selector",
 				   &tmp);
 	if (!ret)
 		pdata->sleep_vsel_id = tmp;
 
-	if (pdata->sleep_vsel_id)
-		flag = GPIOD_OUT_LOW;
-	else
-		flag = GPIOD_OUT_HIGH;
-
-	pdata->vsel_gpio =
-		devm_gpiod_get_index_optional(dev, "vsel", 0,
-					      flag);
-	if (IS_ERR(pdata->vsel_gpio)) {
-		ret = PTR_ERR(pdata->vsel_gpio);
-		dev_err(dev, "failed to get vesl gpio (%d)\n", ret);
-		pdata->vsel_gpio = NULL;
-	}
-
 	return pdata;
 }
 
@@ -677,15 +570,21 @@ static const struct of_device_id __maybe
 	}, {
 		.compatible = "fcs,fan53555",
 		.data = (void *)FAN53555_VENDOR_FAIRCHILD
-	},  {
+	}, {
 		.compatible = "silergy,syr827",
 		.data = (void *)FAN53555_VENDOR_SILERGY,
 	}, {
 		.compatible = "silergy,syr828",
 		.data = (void *)FAN53555_VENDOR_SILERGY,
 	}, {
-		.compatible = "tcs,tcs452x", /* tcs4525/4526 */
-		.data = (void *)FAN53555_VENDOR_TCS
+		.compatible = "tcs,tcs4525",
+		.data = (void *)FAN53526_VENDOR_TCS
+	}, {
+		.compatible = "tcs,tcs4526",
+		.data = (void *)FAN53526_VENDOR_TCS
+	}, {
+		.compatible = "tcs,tcs452x",
+		.data = (void *)FAN53526_VENDOR_TCS
 	},
 	{ }
 };
@@ -698,6 +597,7 @@ static int fan53555_regulator_probe(stru
 	struct fan53555_device_info *di;
 	struct fan53555_platform_data *pdata;
 	struct regulator_config config = { };
+	struct regmap *regmap;
 	unsigned int val;
 	int ret;
 
@@ -717,9 +617,6 @@ static int fan53555_regulator_probe(stru
 		return -ENODEV;
 	}
 
-	di->vsel_gpio = pdata->vsel_gpio;
-	di->sleep_vsel_id = pdata->sleep_vsel_id;
-
 	di->regulator = pdata->regulator;
 	if (client->dev.of_node) {
 		di->vendor =
@@ -739,22 +636,23 @@ static int fan53555_regulator_probe(stru
 		di->vendor = id->driver_data;
 	}
 
-	di->regmap = devm_regmap_init_i2c(client, &fan53555_regmap_config);
-	if (IS_ERR(di->regmap)) {
+	regmap = devm_regmap_init_i2c(client, &fan53555_regmap_config);
+	if (IS_ERR(regmap)) {
 		dev_err(&client->dev, "Failed to allocate regmap!\n");
-		return PTR_ERR(di->regmap);
+		return PTR_ERR(regmap);
 	}
+	di->regmap = regmap;
 	di->dev = &client->dev;
 	i2c_set_clientdata(client, di);
 	/* Get chip ID */
-	ret = regmap_read(di->regmap, FAN53555_ID1, &val);
+	ret = regmap_read(regmap, FAN53555_ID1, &val);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to get chip ID!\n");
 		return ret;
 	}
 	di->chip_id = val & DIE_ID;
 	/* Get chip revision */
-	ret = regmap_read(di->regmap, FAN53555_ID2, &val);
+	ret = regmap_read(regmap, FAN53555_ID2, &val);
 	if (ret < 0) {
 		dev_err(&client->dev, "Failed to get chip Rev!\n");
 		return ret;
@@ -771,7 +669,7 @@ static int fan53555_regulator_probe(stru
 	/* Register regulator */
 	config.dev = di->dev;
 	config.init_data = di->regulator;
-	config.regmap = di->regmap;
+	config.regmap = regmap;
 	config.driver_data = di;
 	config.of_node = np;
 
@@ -793,13 +691,12 @@ static void fan53555_regulator_shutdown(
 
 	switch (di->vendor) {
 	case FAN53555_VENDOR_FAIRCHILD:
-	case FAN53555_VENDOR_RK:
 	case FAN53555_VENDOR_SILERGY:
 		ret = regmap_update_bits(di->regmap, di->slew_reg,
 					 CTL_RESET, CTL_RESET);
 		break;
-	case FAN53555_VENDOR_TCS:
-		ret = regmap_update_bits(di->regmap, TCS452X_LIMCONF,
+	case FAN53526_VENDOR_TCS:
+		ret = regmap_update_bits(di->regmap, TCS4525_LIMCONF,
 					 CTL_RESET, CTL_RESET);
 		/*
 		 * the device can't return 'ack' during the reset,
@@ -833,8 +730,14 @@ static const struct i2c_device_id fan535
 		.name = "syr828",
 		.driver_data = FAN53555_VENDOR_SILERGY
 	}, {
+		.name = "tcs4525",
+		.driver_data = FAN53526_VENDOR_TCS
+	}, {
+		.name = "tcs4526",
+		.driver_data = FAN53526_VENDOR_TCS
+	}, {
 		.name = "tcs452x",
-		.driver_data = FAN53555_VENDOR_TCS
+		.driver_data = FAN53526_VENDOR_TCS
 	},
 	{ },
 };
--- a/drivers/soc/rockchip/Kconfig
+++ b/drivers/soc/rockchip/Kconfig
@@ -1,6 +1,8 @@
 # SPDX-License-Identifier: GPL-2.0-only
 if ARCH_ROCKCHIP || COMPILE_TEST
 
+menu "Rockchip SoC drivers"
+
 source "drivers/soc/rockchip/Kconfig.cpu"
 
 #
@@ -177,12 +179,9 @@ config ROCKCHIP_VENDOR_STORAGE_UPDATE_LO
 	  Say y here to enable rockchip vendor storage update loader support.
 	  The /dev/vendor_storage must set root user access only.
 
-config ROCKCHIP_FIQ_DEBUGGER
-	tristate "Rockchip FIQ Debugger"
-	depends on FIQ_DEBUGGER
-	default FIQ_DEBUGGER
-	help
-	  Say y here to enable Rockchip FIQ Debugger platform driver.
+menu "FIQ Debugger"
+source "drivers/soc/rockchip/fiq_debugger/Kconfig"
+endmenu
 
 config ROCKCHIP_DEBUG
 	tristate "Rockchip DEBUG"
@@ -230,4 +229,6 @@ config RK_MEMBLOCK_PROCFS
 	  Extend memblock procfs to show size of each memblock, and shows the
 	  result of total size by KiB format.
 
+endmenu
+
 endif
--- a/drivers/soc/rockchip/Makefile
+++ b/drivers/soc/rockchip/Makefile
@@ -10,7 +10,7 @@ obj-$(CONFIG_ROCKCHIP_HW_DECOMPRESS_USER
 obj-$(CONFIG_ROCKCHIP_IODOMAIN) += io-domain.o
 obj-$(CONFIG_ROCKCHIP_IOMUX) += iomux.o
 obj-$(CONFIG_ROCKCHIP_PM_DOMAINS) += pm_domains.o
-obj-$(CONFIG_ROCKCHIP_FIQ_DEBUGGER) += rk_fiq_debugger.o
+obj-$(CONFIG_ROCKCHIP_FIQ_DEBUGGER) += fiq_debugger/
 obj-$(CONFIG_ROCKCHIP_VENDOR_STORAGE) += rk_vendor_storage.o
 obj-$(CONFIG_ROCKCHIP_MMC_VENDOR_STORAGE) += sdmmc_vendor_storage.o
 obj-$(CONFIG_ROCKCHIP_IPA) += rockchip_ipa.o
--- a/drivers/soc/rockchip/grf.c
+++ b/drivers/soc/rockchip/grf.c
@@ -322,12 +322,14 @@ static int __init rockchip_grf_init(void
 		return 0;
 	if (!match || !match->data) {
 		pr_err("%s: missing grf data\n", __func__);
+		of_node_put(np);
 		return -EINVAL;
 	}
 
 	grf_info = match->data;
 
 	grf = syscon_node_to_regmap(np);
+	of_node_put(np);
 	if (IS_ERR(grf)) {
 		pr_err("%s: could not get grf syscon\n", __func__);
 		return PTR_ERR(grf);
--- a/drivers/soc/rockchip/io-domain.c
+++ b/drivers/soc/rockchip/io-domain.c
@@ -68,15 +68,6 @@
 
 struct rockchip_iodomain;
 
-/**
- * @supplies: voltage settings matching the register bits.
- */
-struct rockchip_iodomain_soc_data {
-	int grf_offset;
-	const char *supply_names[MAX_SUPPLIES];
-	void (*init)(struct rockchip_iodomain *iod);
-};
-
 struct rockchip_iodomain_supply {
 	struct rockchip_iodomain *iod;
 	struct regulator *reg;
@@ -84,6 +75,13 @@ struct rockchip_iodomain_supply {
 	int idx;
 };
 
+struct rockchip_iodomain_soc_data {
+	int grf_offset;
+	const char *supply_names[MAX_SUPPLIES];
+	void (*init)(struct rockchip_iodomain *iod);
+	int (*write)(struct rockchip_iodomain_supply *supply, int uV);
+};
+
 struct rockchip_iodomain {
 	struct device *dev;
 	struct regmap *grf;
@@ -92,8 +90,7 @@ struct rockchip_iodomain {
 	int (*write)(struct rockchip_iodomain_supply *supply, int uV);
 };
 
-static int rk3568_pmu_iodomain_write(struct rockchip_iodomain_supply *supply,
-				     int uV)
+static int rk3568_iodomain_write(struct rockchip_iodomain_supply *supply, int uV)
 {
 	struct rockchip_iodomain *iod = supply->iod;
 	u32 is_3v3 = uV > MAX_VOLTAGE_1_8;
@@ -504,6 +501,7 @@ static const struct rockchip_iodomain_so
 		"vccio6",
 		"vccio7",
 	},
+	.write = rk3568_iodomain_write,
 };
 
 static const struct rockchip_iodomain_soc_data soc_data_rv1108 = {
@@ -788,8 +786,8 @@ static int rockchip_iodomain_probe(struc
 	match = of_match_node(rockchip_iodomain_match, np);
 	iod->soc_data = match->data;
 
-	if (IS_ENABLED(CONFIG_CPU_RK3568) && match->data == &soc_data_rk3568_pmu)
-		iod->write = rk3568_pmu_iodomain_write;
+	if (iod->soc_data->write)
+		iod->write = iod->soc_data->write;
 	else
 		iod->write = rockchip_iodomain_write;
 
--- a/drivers/soc/rockchip/pm_domains.c
+++ b/drivers/soc/rockchip/pm_domains.c
@@ -40,6 +40,8 @@
 #include <dt-bindings/power/rk3366-power.h>
 #include <dt-bindings/power/rk3368-power.h>
 #include <dt-bindings/power/rk3399-power.h>
+#include <dt-bindings/power/rk3528-power.h>
+#include <dt-bindings/power/rk3562-power.h>
 #include <dt-bindings/power/rk3568-power.h>
 #include <dt-bindings/power/rk3588-power.h>
 
@@ -55,6 +57,9 @@ struct rockchip_domain_info {
 	int req_w_mask;
 	int mem_status_mask;
 	int repair_status_mask;
+	int clk_ungate_mask;
+	int clk_ungate_w_mask;
+	int mem_num;
 	bool keepon_startup;
 	bool always_on;
 	u32 pwr_offset;
@@ -72,6 +77,8 @@ struct rockchip_pmu_info {
 	u32 chain_status_offset;
 	u32 mem_status_offset;
 	u32 repair_status_offset;
+	u32 clk_ungate_offset;
+	u32 mem_sd_offset;
 
 	u32 core_pwrcnt_offset;
 	u32 gpu_pwrcnt_offset;
@@ -191,6 +198,37 @@ static void rockchip_pmu_unlock(struct r
 	.keepon_startup = keepon,			\
 }
 
+#define DOMAIN_M_A(pwr, status, req, idle, ack, always, wakeup, keepon)	\
+{							\
+	.pwr_w_mask = (pwr) << 16,			\
+	.pwr_mask = (pwr),				\
+	.status_mask = (status),			\
+	.req_w_mask = (req) << 16,			\
+	.req_mask = (req),				\
+	.idle_mask = (idle),				\
+	.ack_mask = (ack),				\
+	.always_on = always,				\
+	.active_wakeup = wakeup,			\
+	.keepon_startup = keepon,			\
+}
+
+#define DOMAIN_M_C_SD(_name, pwr, status, req, idle, ack, clk, mem, wakeup, keepon)	\
+{							\
+	.name = _name,					\
+	.pwr_w_mask = (pwr) << 16,			\
+	.pwr_mask = (pwr),				\
+	.status_mask = (status),			\
+	.req_w_mask = (req) << 16,			\
+	.req_mask = (req),				\
+	.idle_mask = (idle),				\
+	.ack_mask = (ack),				\
+	.clk_ungate_mask = (clk),			\
+	.clk_ungate_w_mask = (clk) << 16,		\
+	.mem_num = (mem),				\
+	.active_wakeup = wakeup,			\
+	.keepon_startup = keepon,			\
+}
+
 #define DOMAIN_M_O(_name, pwr, status, p_offset, req, idle, ack, r_offset, wakeup, keepon)	\
 {							\
 	.name = _name,					\
@@ -272,6 +310,15 @@ static void rockchip_pmu_unlock(struct r
 #define DOMAIN_RK3399_PROTECT(name, pwr, status, req, wakeup)	\
 	DOMAIN(name, pwr, status, req, req, req, wakeup, true)
 
+#define DOMAIN_RK3528(pwr, req, always, wakeup) \
+	DOMAIN_M_A(pwr, pwr, req, req, req, always, wakeup, false)
+
+#define DOMAIN_RK3562(name, pwr, req, mem, wakeup)		\
+	DOMAIN_M_C_SD(name, pwr, pwr, req, req, req, req, mem, wakeup, false)
+
+#define DOMAIN_RK3562_PROTECT(name, pwr, req, mem, wakeup)		\
+	DOMAIN_M_C_SD(name, pwr, pwr, req, req, req, req, mem, wakeup, true)
+
 #define DOMAIN_RK3568(name, pwr, req, wakeup)			\
 	DOMAIN_M(name, pwr, pwr, req, req, req, wakeup, false)
 
@@ -302,6 +349,42 @@ static unsigned int rockchip_pmu_read_ac
 	return val;
 }
 
+static int rockchip_pmu_ungate_clk(struct rockchip_pm_domain *pd, bool ungate)
+{
+	const struct rockchip_domain_info *pd_info = pd->info;
+	struct rockchip_pmu *pmu = pd->pmu;
+	unsigned int val;
+
+	if (!pd_info->clk_ungate_mask)
+		return 0;
+	if (!pmu->info->clk_ungate_offset)
+		return 0;
+
+	val = ungate ? (pd_info->clk_ungate_mask | pd_info->clk_ungate_w_mask) :
+			pd_info->clk_ungate_w_mask;
+	regmap_write(pmu->regmap, pmu->info->clk_ungate_offset, val);
+
+	return 0;
+}
+
+static int rockchip_pmu_mem_shut_down(struct rockchip_pm_domain *pd, bool sd)
+{
+	const struct rockchip_domain_info *pd_info = pd->info;
+	struct rockchip_pmu *pmu = pd->pmu;
+	unsigned int i;
+
+	if (!pd_info->mem_num)
+		return 0;
+	if (!pmu->info->mem_sd_offset)
+		return 0;
+
+	for (i = 0; i < pd_info->mem_num; i++)
+		regmap_write(pmu->regmap, pmu->info->mem_sd_offset,
+			     (sd << i) | (1 << (i + 16)));
+
+	return 0;
+}
+
 static int rockchip_pmu_set_idle_request(struct rockchip_pm_domain *pd,
 					 bool idle)
 {
@@ -695,6 +778,7 @@ static int rockchip_pd_power(struct rock
 			rockchip_pmu_unlock(pd);
 			return ret;
 		}
+		rockchip_pmu_ungate_clk(pd, true);
 
 		if (!power_on) {
 			rockchip_pmu_save_qos(pd);
@@ -707,6 +791,7 @@ static int rockchip_pd_power(struct rock
 					genpd->name);
 				goto out;
 			}
+			rockchip_pmu_mem_shut_down(pd, true);
 		}
 
 		ret = rockchip_do_pmu_set_power_domain(pd, power_on);
@@ -717,6 +802,7 @@ static int rockchip_pd_power(struct rock
 		}
 
 		if (power_on) {
+			rockchip_pmu_mem_shut_down(pd, false);
 			/* if powering up, leave idle mode */
 			ret = rockchip_pmu_set_idle_request(pd, false);
 			if (ret) {
@@ -732,6 +818,7 @@ static int rockchip_pd_power(struct rock
 		}
 
 out:
+		rockchip_pmu_ungate_clk(pd, false);
 		clk_bulk_disable(pd->num_clks, pd->clks);
 
 		if (!power_on && !IS_ERR(pd->supply))
@@ -1263,14 +1350,32 @@ late_initcall_sync(rockchip_pd_keepon_re
 
 static void __iomem *pd_base;
 
+static void dump_offset(const char *name, u32 offset)
+{
+	if (!offset)
+		return;
+
+	pr_warn("%-9s 0x%04x: ", name, offset);
+	print_hex_dump(KERN_CONT, "", DUMP_PREFIX_NONE, 16, 4, pd_base + offset, 16, false);
+}
+
 void rockchip_dump_pmu(void)
 {
-	if (pd_base) {
-		pr_warn("PMU:\n");
-		print_hex_dump(KERN_WARNING, "", DUMP_PREFIX_OFFSET,
-			       32, 4, pd_base,
-			       0x100, false);
-	}
+	if (!pd_base)
+		return;
+
+	pr_warn("PMU:\n");
+	dump_offset("pwr", g_pmu->info->pwr_offset);
+	dump_offset("status", g_pmu->info->status_offset);
+	dump_offset("req", g_pmu->info->req_offset);
+	dump_offset("idle", g_pmu->info->idle_offset);
+	dump_offset("ack", g_pmu->info->ack_offset);
+	dump_offset("mem_pwr", g_pmu->info->mem_pwr_offset);
+	dump_offset("chain_st", g_pmu->info->chain_status_offset);
+	dump_offset("mem_st", g_pmu->info->mem_status_offset);
+	dump_offset("repair_st", g_pmu->info->repair_status_offset);
+	dump_offset("clkungate", g_pmu->info->clk_ungate_offset);
+	dump_offset("mem_sd", g_pmu->info->mem_sd_offset);
 }
 EXPORT_SYMBOL_GPL(rockchip_dump_pmu);
 
@@ -1547,6 +1652,29 @@ static const struct rockchip_domain_info
 	[RK3399_PD_SDIOAUDIO]	= DOMAIN_RK3399("sdioaudio",    BIT(31), BIT(31), BIT(29), true),
 };
 
+static const struct rockchip_domain_info rk3528_pm_domains[] = {
+	[RK3528_PD_PMU]		= DOMAIN_RK3528(0, BIT(0), true, false),
+	[RK3528_PD_BUS]		= DOMAIN_RK3528(0, BIT(1), true, false),
+	[RK3528_PD_DDR]		= DOMAIN_RK3528(0, BIT(2), true, false),
+	[RK3528_PD_MSCH]	= DOMAIN_RK3528(0, BIT(3), true, false),
+	[RK3528_PD_GPU]		= DOMAIN_RK3528(BIT(0), BIT(4), true, false),
+	[RK3528_PD_RKVDEC]	= DOMAIN_RK3528(0, BIT(5), true, false),
+	[RK3528_PD_RKVENC]	= DOMAIN_RK3528(0, BIT(6), true, false),
+	[RK3528_PD_VO]		= DOMAIN_RK3528(0,  BIT(7), true, false),
+	[RK3528_PD_VPU]		= DOMAIN_RK3528(0, BIT(8), true, false),
+};
+
+static const struct rockchip_domain_info rk3562_pm_domains[] = {
+	[RK3562_PD_GPU]		= DOMAIN_RK3562("gpu",         BIT(0), BIT(1), 0, false),
+	[RK3562_PD_NPU]		= DOMAIN_RK3562("npu",         BIT(1), BIT(2), 0, false),
+	[RK3562_PD_VDPU]	= DOMAIN_RK3562("vdpu",        BIT(2), BIT(6), 0, false),
+	[RK3562_PD_VEPU]	= DOMAIN_RK3562("vepu",        BIT(3), BIT(7), 0, false),
+	[RK3562_PD_RGA]		= DOMAIN_RK3562("rga",         BIT(4), BIT(5), 0, false),
+	[RK3562_PD_VI]		= DOMAIN_RK3562("vi",          BIT(5), BIT(3), 0, false),
+	[RK3562_PD_VO]		= DOMAIN_RK3562_PROTECT("vo",  BIT(6), BIT(4), 16, false),
+	[RK3562_PD_PHP]		= DOMAIN_RK3562("php",         BIT(7), BIT(8), 0, false),
+};
+
 static const struct rockchip_domain_info rk3568_pm_domains[] = {
 	[RK3568_PD_NPU]		= DOMAIN_RK3568("npu",        BIT(1), BIT(2),  false),
 	[RK3568_PD_GPU]		= DOMAIN_RK3568("gpu",        BIT(0), BIT(1),  false),
@@ -1751,6 +1879,30 @@ static const struct rockchip_pmu_info rk
 	.domain_info = rk3399_pm_domains,
 };
 
+static const struct rockchip_pmu_info rk3528_pmu = {
+	.pwr_offset = 0x1210,
+	.status_offset = 0x1230,
+	.req_offset = 0x1110,
+	.idle_offset = 0x1128,
+	.ack_offset = 0x1120,
+
+	.num_domains = ARRAY_SIZE(rk3528_pm_domains),
+	.domain_info = rk3528_pm_domains,
+};
+
+static const struct rockchip_pmu_info rk3562_pmu = {
+	.pwr_offset = 0x210,
+	.status_offset = 0x230,
+	.req_offset = 0x110,
+	.idle_offset = 0x128,
+	.ack_offset = 0x120,
+	.clk_ungate_offset = 0x140,
+	.mem_sd_offset = 0x300,
+
+	.num_domains = ARRAY_SIZE(rk3562_pm_domains),
+	.domain_info = rk3562_pm_domains,
+};
+
 static const struct rockchip_pmu_info rk3568_pmu = {
 	.pwr_offset = 0xa0,
 	.status_offset = 0x98,
@@ -1834,6 +1986,16 @@ static const struct of_device_id rockchi
 		.compatible = "rockchip,rk3399-power-controller",
 		.data = (void *)&rk3399_pmu,
 	},
+#ifdef CONFIG_CPU_RK3528
+	{
+		.compatible = "rockchip,rk3528-power-controller",
+		.data = (void *)&rk3528_pmu,
+	},
+#endif
+	{
+		.compatible = "rockchip,rk3562-power-controller",
+		.data = (void *)&rk3562_pmu,
+	},
 	{
 		.compatible = "rockchip,rk3568-power-controller",
 		.data = (void *)&rk3568_pmu,
--- a/drivers/spi/spi-rockchip.c
+++ b/drivers/spi/spi-rockchip.c
@@ -172,6 +172,12 @@
 
 #define ROCKCHIP_SPI_REGISTER_SIZE		0x1000
 
+enum rockchip_spi_xfer_mode {
+	ROCKCHIP_SPI_DMA,
+	ROCKCHIP_SPI_IRQ,
+	ROCKCHIP_SPI_POLL,
+};
+
 struct rockchip_spi_quirks {
 	u32 max_baud_div_in_cpha;
 };
@@ -194,6 +200,7 @@ struct rockchip_spi {
 
 	atomic_t state;
 
+	u32 version;
 	/*depth of the FIFO buffer */
 	u32 fifo_len;
 	/* frequency of spiclk */
@@ -203,6 +210,8 @@ struct rockchip_spi {
 
 	u8 n_bytes;
 	u8 rsd;
+	u8 csm;
+	bool poll; /* only support transfer data by cpu polling */
 
 	bool cs_asserted[ROCKCHIP_SPI_MAX_CS_NUM];
 
@@ -227,16 +236,14 @@ static inline void spi_enable_chip(struc
 static inline void wait_for_tx_idle(struct rockchip_spi *rs, bool slave_mode)
 {
 	unsigned long timeout = jiffies + msecs_to_jiffies(5);
+	u32 busy = SR_BUSY;
+
+	if (slave_mode && rs->version == ROCKCHIP_SPI_VER2_TYPE2)
+		busy = SR_SLAVE_TX_BUSY;
 
 	do {
-		if (slave_mode) {
-			if (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_SLAVE_TX_BUSY) &&
-			    !((readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY)))
-				return;
-		} else {
-			if (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & SR_BUSY))
-				return;
-		}
+		if (!(readl_relaxed(rs->regs + ROCKCHIP_SPI_SR) & busy))
+			return;
 	} while (!time_after(jiffies, timeout));
 
 	dev_warn(rs->dev, "spi controller is in busy state!\n");
@@ -244,11 +251,7 @@ static inline void wait_for_tx_idle(stru
 
 static u32 get_fifo_len(struct rockchip_spi *rs)
 {
-	u32 ver;
-
-	ver = readl_relaxed(rs->regs + ROCKCHIP_SPI_VERSION);
-
-	switch (ver) {
+	switch (rs->version) {
 	case ROCKCHIP_SPI_VER2_TYPE1:
 	case ROCKCHIP_SPI_VER2_TYPE2:
 		return 64;
@@ -293,6 +296,11 @@ static void rockchip_spi_handle_err(stru
 {
 	struct rockchip_spi *rs = spi_controller_get_devdata(ctlr);
 
+	dev_err(rs->dev, "state=%x\n", atomic_read(&rs->state));
+	dev_err(rs->dev, "tx_left=%x\n", rs->tx_left);
+	dev_err(rs->dev, "rx_left=%x\n", rs->rx_left);
+	print_hex_dump(KERN_ERR, "regs ", DUMP_PREFIX_OFFSET, 4, 4, rs->regs, 0x4c, 0);
+
 	/* stop running spi transfer
 	 * this also flushes both rx and tx fifos
 	 */
@@ -368,7 +376,7 @@ static irqreturn_t rockchip_spi_isr(int
 	struct rockchip_spi *rs = spi_controller_get_devdata(ctlr);
 
 	/* When int_cs_inactive comes, spi slave abort */
-	if (rs->cs_inactive && readl_relaxed(rs->regs + ROCKCHIP_SPI_IMR) & INT_CS_INACTIVE) {
+	if (rs->cs_inactive && readl_relaxed(rs->regs + ROCKCHIP_SPI_ISR) & INT_CS_INACTIVE) {
 		ctlr->slave_abort(ctlr);
 		writel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);
 		writel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);
@@ -394,8 +402,6 @@ static int rockchip_spi_prepare_irq(stru
 				    struct spi_controller *ctlr,
 				    struct spi_transfer *xfer)
 {
-	rs->tx = xfer->tx_buf;
-	rs->rx = xfer->rx_buf;
 	rs->tx_left = rs->tx ? xfer->len / rs->n_bytes : 0;
 	rs->rx_left = xfer->len / rs->n_bytes;
 
@@ -428,6 +434,8 @@ static void rockchip_spi_dma_rxcb(void *
 		writel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);
 
 	spi_enable_chip(rs, false);
+	writel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);
+	writel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);
 	spi_finalize_current_transfer(ctlr);
 }
 
@@ -444,6 +452,8 @@ static void rockchip_spi_dma_txcb(void *
 	wait_for_tx_idle(rs, ctlr->slave);
 
 	spi_enable_chip(rs, false);
+	writel_relaxed(0, rs->regs + ROCKCHIP_SPI_IMR);
+	writel_relaxed(0xffffffff, rs->regs + ROCKCHIP_SPI_ICR);
 	spi_finalize_current_transfer(ctlr);
 }
 
@@ -467,9 +477,6 @@ static int rockchip_spi_prepare_dma(stru
 
 	atomic_set(&rs->state, 0);
 
-	rs->tx = xfer->tx_buf;
-	rs->rx = xfer->rx_buf;
-
 	rxdesc = NULL;
 	if (xfer->rx_buf) {
 		struct dma_slave_config rxconf = {
@@ -539,14 +546,64 @@ static int rockchip_spi_prepare_dma(stru
 	return 1;
 }
 
+static int rockchip_spi_pio_transfer(struct rockchip_spi *rs,
+		struct spi_controller *ctlr, struct spi_transfer *xfer)
+{
+	unsigned long time, timeout;
+	u32 speed_hz = xfer->speed_hz;
+	unsigned long long ms;
+	int ret = 0;
+
+	if (!speed_hz)
+		speed_hz = 100000;
+
+	ms = 8LL * 1000LL * xfer->len;
+	do_div(ms, speed_hz);
+	ms += ms + 200; /* some tolerance */
+
+	if (ms > UINT_MAX || ctlr->slave)
+		ms = UINT_MAX;
+
+	timeout = jiffies + msecs_to_jiffies(ms);
+	time = jiffies;
+	rs->tx_left = rs->tx ? xfer->len / rs->n_bytes : 0;
+	rs->rx_left = rs->rx ? xfer->len / rs->n_bytes : 0;
+
+	spi_enable_chip(rs, true);
+
+	while (rs->tx_left || rs->rx_left) {
+		if (rs->tx)
+			rockchip_spi_pio_writer(rs);
+
+		if (rs->rx)
+			rockchip_spi_pio_reader(rs);
+
+		cpu_relax();
+
+		if (time_after(time, timeout)) {
+			ret = -EIO;
+			goto out;
+		}
+	};
+
+	/* If tx, wait until the FIFO data completely. */
+	if (rs->tx)
+		wait_for_tx_idle(rs, ctlr->slave);
+
+out:
+	spi_enable_chip(rs, false);
+
+	return ret;
+}
+
 static int rockchip_spi_config(struct rockchip_spi *rs,
 		struct spi_device *spi, struct spi_transfer *xfer,
-		bool use_dma, bool slave_mode)
+		enum rockchip_spi_xfer_mode xfer_mode, bool slave_mode)
 {
 	u32 cr0 = CR0_FRF_SPI  << CR0_FRF_OFFSET
-	        | CR0_BHT_8BIT << CR0_BHT_OFFSET
-	        | CR0_SSD_ONE  << CR0_SSD_OFFSET
-	        | CR0_EM_BIG   << CR0_EM_OFFSET;
+		| CR0_BHT_8BIT << CR0_BHT_OFFSET
+		| CR0_SSD_ONE  << CR0_SSD_OFFSET
+		| CR0_EM_BIG   << CR0_EM_OFFSET;
 	u32 cr1;
 	u32 dmacr = 0;
 
@@ -555,18 +612,30 @@ static int rockchip_spi_config(struct ro
 	rs->slave_abort = false;
 
 	cr0 |= rs->rsd << CR0_RSD_OFFSET;
+	cr0 |= rs->csm << CR0_CSM_OFFSET;
 	cr0 |= (spi->mode & 0x3U) << CR0_SCPH_OFFSET;
 	if (spi->mode & SPI_LSB_FIRST)
 		cr0 |= CR0_FBM_LSB << CR0_FBM_OFFSET;
 	if (spi->mode & SPI_CS_HIGH)
 		cr0 |= BIT(spi->chip_select) << CR0_SOI_OFFSET;
 
-	if (xfer->rx_buf && xfer->tx_buf)
+	if (xfer->rx_buf && xfer->tx_buf) {
 		cr0 |= CR0_XFM_TR << CR0_XFM_OFFSET;
-	else if (xfer->rx_buf)
+	} else if (xfer->rx_buf) {
 		cr0 |= CR0_XFM_RO << CR0_XFM_OFFSET;
-	else if (use_dma)
-		cr0 |= CR0_XFM_TO << CR0_XFM_OFFSET;
+	} else if (xfer->tx_buf) {
+		/*
+		 * Use the water line of rx fifo in full duplex mode to trigger
+		 * the interruption of tx irq transmission completion.
+		 */
+		if (xfer_mode == ROCKCHIP_SPI_IRQ)
+			cr0 |= CR0_XFM_TR << CR0_XFM_OFFSET;
+		else
+			cr0 |= CR0_XFM_TO << CR0_XFM_OFFSET;
+	} else {
+		dev_err(rs->dev, "no transmission buffer\n");
+		return -EINVAL;
+	}
 
 	switch (xfer->bits_per_word) {
 	case 4:
@@ -591,7 +660,7 @@ static int rockchip_spi_config(struct ro
 		return -EINVAL;
 	}
 
-	if (use_dma) {
+	if (xfer_mode == ROCKCHIP_SPI_DMA) {
 		if (xfer->tx_buf)
 			dmacr |= TF_DMA_EN;
 		if (xfer->rx_buf)
@@ -692,7 +761,6 @@ static int rockchip_spi_slave_abort(stru
 				*(u16 *)rs->rx = (u16)rxw;
 			rs->rx += rs->n_bytes;
 		}
-
 		rs->xfer->len = (unsigned int)(rs->rx - rs->xfer->rx_buf);
 	}
 
@@ -717,6 +785,7 @@ static int rockchip_spi_transfer_one(
 	struct rockchip_spi *rs = spi_controller_get_devdata(ctlr);
 	int ret;
 	bool use_dma;
+	enum rockchip_spi_xfer_mode xfer_mode;
 
 	/* Zero length transfers won't trigger an interrupt on completion */
 	if (!xfer->len) {
@@ -739,16 +808,31 @@ static int rockchip_spi_transfer_one(
 
 	rs->n_bytes = xfer->bits_per_word <= 8 ? 1 : 2;
 	rs->xfer = xfer;
-	use_dma = ctlr->can_dma ? ctlr->can_dma(ctlr, spi, xfer) : false;
+	if (rs->poll) {
+		xfer_mode = ROCKCHIP_SPI_POLL;
+	} else {
+		use_dma = ctlr->can_dma ? ctlr->can_dma(ctlr, spi, xfer) : false;
+		if (use_dma)
+			xfer_mode = ROCKCHIP_SPI_DMA;
+		else
+			xfer_mode = ROCKCHIP_SPI_IRQ;
+	}
 
-	ret = rockchip_spi_config(rs, spi, xfer, use_dma, ctlr->slave);
+	ret = rockchip_spi_config(rs, spi, xfer, xfer_mode, ctlr->slave);
 	if (ret)
 		return ret;
 
-	if (use_dma)
-		return rockchip_spi_prepare_dma(rs, ctlr, xfer);
+	rs->tx = xfer->tx_buf;
+	rs->rx = xfer->rx_buf;
 
-	return rockchip_spi_prepare_irq(rs, ctlr, xfer);
+	switch (xfer_mode) {
+	case ROCKCHIP_SPI_POLL:
+		return rockchip_spi_pio_transfer(rs, ctlr, xfer);
+	case ROCKCHIP_SPI_DMA:
+		return rockchip_spi_prepare_dma(rs, ctlr, xfer);
+	default:
+		return rockchip_spi_prepare_irq(rs, ctlr, xfer);
+	}
 }
 
 static bool rockchip_spi_can_dma(struct spi_controller *ctlr,
@@ -851,7 +935,7 @@ static int rockchip_spi_probe(struct pla
 	struct spi_controller *ctlr;
 	struct resource *mem;
 	struct device_node *np = pdev->dev.of_node;
-	u32 rsd_nsecs, num_cs;
+	u32 rsd_nsecs, num_cs, csm;
 	bool slave_mode;
 	struct pinctrl *pinctrl = NULL;
 	const struct rockchip_spi_quirks *quirks_cfg;
@@ -961,6 +1045,16 @@ static int rockchip_spi_probe(struct pla
 		rs->rsd = rsd;
 	}
 
+	if (!device_property_read_u32(&pdev->dev, "csm", &csm)) {
+		if (csm > CR0_CSM_ONE)	{
+			dev_warn(rs->dev, "The csm value %u exceeds the limit, clamping at %u\n",
+				 csm, CR0_CSM_ONE);
+			csm = CR0_CSM_ONE;
+		}
+		rs->csm = csm;
+	}
+
+	rs->version = readl_relaxed(rs->regs + ROCKCHIP_SPI_VERSION);
 	rs->fifo_len = get_fifo_len(rs);
 	if (!rs->fifo_len) {
 		dev_err(&pdev->dev, "Failed to get fifo length\n");
@@ -1030,11 +1124,13 @@ static int rockchip_spi_probe(struct pla
 		ctlr->can_dma = rockchip_spi_can_dma;
 	}
 
-	switch (readl_relaxed(rs->regs + ROCKCHIP_SPI_VERSION)) {
+	rs->poll = device_property_read_bool(&pdev->dev, "rockchip,poll-only");
+
+	switch (rs->version) {
 	case ROCKCHIP_SPI_VER2_TYPE2:
 		rs->cs_high_supported = true;
 		ctlr->mode_bits |= SPI_CS_HIGH;
-		if (ctlr->can_dma && slave_mode)
+		if (slave_mode)
 			rs->cs_inactive = true;
 		else
 			rs->cs_inactive = false;
@@ -1075,6 +1171,8 @@ static int rockchip_spi_probe(struct pla
 			dev_info(&pdev->dev, "register misc device %s\n", misc_name);
 	}
 
+	dev_info(rs->dev, "probed, poll=%d, rsd=%d\n", rs->poll, rs->rsd);
+
 	return 0;
 
 err_free_dma_rx:
--- a/drivers/thermal/rockchip_thermal.c
+++ b/drivers/thermal/rockchip_thermal.c
@@ -91,6 +91,7 @@ struct chip_tsadc_table {
  * @chn_id: array of sensor ids of chip corresponding to the channel
  * @chn_num: the channel number of tsadc chip
  * @conversion_time: the conversion time of tsadc
+ * @trim_slope: use to conversion trim code to trim temp
  * @tshut_temp: the hardware-controlled shutdown temperature value
  * @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)
  * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
@@ -102,7 +103,6 @@ struct chip_tsadc_table {
  * @set_tshut_temp: set the hardware-controlled shutdown temperature
  * @set_tshut_mode: set the hardware-controlled shutdown mode
  * @get_trim_code: get the trim code by otp value
- * @trim_temp: get trim temp by trim code
  * @set_clk_rate: set clock rate
  * @table: the chip-specific conversion table
  */
@@ -114,6 +114,9 @@ struct rockchip_tsadc_chip {
 	/* The sensor electrical characteristics */
 	int conversion_time;
 
+	/* Use to conversion trim code to trim temp */
+	int trim_slope;
+
 	/* The hardware-controlled tshut property */
 	int tshut_temp;
 	enum tshut_mode tshut_mode;
@@ -134,9 +137,8 @@ struct rockchip_tsadc_chip {
 			      int chn, void __iomem *reg, int temp);
 	void (*set_tshut_mode)(struct regmap *grf, int chn,
 			       void __iomem *reg, enum tshut_mode m);
-	int (*get_trim_code)(struct platform_device *pdev,
-			     int code, int trim_base);
-	int (*trim_temp)(struct platform_device *pdev);
+	int (*get_trim_code)(const struct chip_tsadc_table *table,
+			     int code, int trim_base, int trim_base_frac);
 	int (*set_clk_rate)(struct platform_device *pdev);
 
 	/* Per-table methods */
@@ -148,11 +150,15 @@ struct rockchip_tsadc_chip {
  * @thermal:  pointer to the platform/configuration data
  * @tzd: pointer to a thermal zone
  * @id: identifier of the thermal sensor
+ * @trim_temp: the trim temp of the thermal sensor
+ * @tshut_temp: the hardware-controlled shutdown temperature value
  */
 struct rockchip_thermal_sensor {
 	struct rockchip_thermal_data *thermal;
 	struct thermal_zone_device *tzd;
 	int id;
+	int trim_temp;
+	int tshut_temp;
 };
 
 /**
@@ -165,8 +171,6 @@ struct rockchip_thermal_sensor {
  * @num_clks: the number of tsadc clks
  * @grf: the general register file will be used to do static set by software
  * @regs: the base address of tsadc controller
- * @tshut_temp: the hardware-controlled shutdown temperature value
- * @trim: trimmed value
  * @tshut_mode: the hardware-controlled shutdown mode (0:CRU 1:GPIO)
  * @tshut_polarity: the hardware-controlled active polarity (0:LOW 1:HIGH)
  * @pinctrl: the pinctrl of tsadc
@@ -187,8 +191,6 @@ struct rockchip_thermal_data {
 	struct regmap *grf;
 	void __iomem *regs;
 
-	int tshut_temp;
-	int trim;
 	enum tshut_mode tshut_mode;
 	enum tshut_polarity tshut_polarity;
 	struct pinctrl *pinctrl;
@@ -241,6 +243,7 @@ struct rockchip_thermal_data {
 #define TSADCV2_AUTO_TSHUT_POLARITY_MASK	BIT(24)
 
 #define TSADCV3_AUTO_Q_SEL_EN			BIT(1)
+#define TSADCV3_AUTO_Q_SEL_EN_MASK		BIT(17)
 
 #define TSADCV2_INT_SRC_EN(chn)			BIT(chn)
 #define TSADCV2_INT_SRC_EN_MASK(chn)		BIT(16 + (chn))
@@ -254,6 +257,7 @@ struct rockchip_thermal_data {
 #define TSADCV2_DATA_MASK			0xfff
 #define TSADCV3_DATA_MASK			0x3ff
 #define TSADCV4_DATA_MASK			0x1ff
+#define TSADCV5_DATA_MASK			0x7ff
 
 #define TSADCV2_HIGHT_INT_DEBOUNCE_COUNT	4
 #define TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT	4
@@ -265,6 +269,12 @@ struct rockchip_thermal_data {
 #define TSADCV5_AUTO_PERIOD_HT_TIME		1622 /* 2.5ms */
 #define TSADCV6_AUTO_PERIOD_TIME		5000 /* 2.5ms */
 #define TSADCV6_AUTO_PERIOD_HT_TIME		5000 /* 2.5ms */
+#define TSADCV7_AUTO_PERIOD_TIME		3000 /* 2.5ms */
+#define TSADCV7_AUTO_PERIOD_HT_TIME		3000 /* 2.5ms */
+#define TSADCV12_AUTO_PERIOD_TIME		3000 /* 2.5ms */
+#define TSADCV12_AUTO_PERIOD_HT_TIME		3000 /* 2.5ms */
+#define TSADCV3_Q_MAX_VAL			0x7ff /* 11bit 2047 */
+#define TSADCV12_Q_MAX_VAL			0xfff /* 12bit 4095 */
 
 #define TSADCV2_USER_INTER_PD_SOC		0x340 /* 13 clocks */
 #define TSADCV5_USER_INTER_PD_SOC		0xfc0 /* 97us, at least 90us */
@@ -282,6 +292,10 @@ struct rockchip_thermal_data {
 
 #define RK1808_BUS_GRF_SOC_CON0			0x0400
 
+#define RK3528_GRF_TSADC_CON			0x40030
+
+#define RK3562_GRF_TSADC_CON			0x0580
+
 #define RK3568_GRF_TSADC_CON			0x0600
 #define RK3568_GRF_TSADC_ANA_REG0		(0x10001 << 0)
 #define RK3568_GRF_TSADC_ANA_REG1		(0x10001 << 1)
@@ -308,10 +322,10 @@ struct rockchip_thermal_data {
 #define PX30S_TSADC_TDC_MODE			(0x10001 << 4)
 #define PX30S_TSADC_TRIM			(0xf0007 << 0)
 
-#define MIN_TEMP				(-40000)
-#define LOWEST_TEMP				(-273000)
-#define MAX_TEMP				(125000)
-#define MAX_ENV_TEMP				(85000)
+
+/* -40 to 125 is reliable, outside the range existed unreliability */
+#define MIN_TEMP				(-60000)
+#define MAX_TEMP				(180000)
 
 /**
  * struct tsadc_table - code to temperature conversion table
@@ -329,16 +343,19 @@ struct tsadc_table {
 };
 
 static const struct tsadc_table rv1106_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{363, MIN_TEMP},
 	{396, -40000},
 	{504, 25000},
 	{605, 85000},
 	{673, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{758, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rv1108_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{342, MIN_TEMP},
 	{374, -40000},
 	{382, -35000},
 	{389, -30000},
@@ -373,11 +390,13 @@ static const struct tsadc_table rv1108_t
 	{618, 115000},
 	{626, 120000},
 	{634, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{722, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk1808_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{3423, MIN_TEMP},
 	{3455, -40000},
 	{3463, -35000},
 	{3471, -30000},
@@ -412,11 +431,13 @@ static const struct tsadc_table rk1808_c
 	{3709, 115000},
 	{3718, 120000},
 	{3726, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{3820, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3228_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{568, MIN_TEMP},
 	{588, -40000},
 	{593, -35000},
 	{598, -30000},
@@ -451,11 +472,13 @@ static const struct tsadc_table rk3228_c
 	{749, 115000},
 	{754, 120000},
 	{760, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{821, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3288_code_table[] = {
-	{TSADCV2_DATA_MASK, -40000},
+	{TSADCV2_DATA_MASK, MIN_TEMP},
+	{3833, MIN_TEMP},
 	{3800, -40000},
 	{3792, -35000},
 	{3783, -30000},
@@ -490,11 +513,15 @@ static const struct tsadc_table rk3288_c
 	{3452, 115000},
 	{3437, 120000},
 	{3421, 125000},
-	{0, 125000},
+	{3350, 145000},
+	{3270, 165000},
+	{3195, MAX_TEMP},
+	{0, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3328_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{261, MIN_TEMP},
 	{296, -40000},
 	{304, -35000},
 	{313, -30000},
@@ -528,11 +555,15 @@ static const struct tsadc_table rk3328_c
 	{644, 115000},
 	{659, 120000},
 	{675, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{745, 145000},
+	{825, 165000},
+	{900, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3368_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{98, MIN_TEMP},
 	{106, -40000},
 	{108, -35000},
 	{110, -30000},
@@ -567,11 +598,13 @@ static const struct tsadc_table rk3368_c
 	{167, 115000},
 	{169, 120000},
 	{171, 125000},
-	{TSADCV3_DATA_MASK, 125000},
+	{193, MAX_TEMP},
+	{TSADCV3_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3399_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{368, MIN_TEMP},
 	{402, -40000},
 	{410, -35000},
 	{419, -30000},
@@ -606,11 +639,95 @@ static const struct tsadc_table rk3399_c
 	{668, 115000},
 	{677, 120000},
 	{685, 125000},
-	{TSADCV3_DATA_MASK, 125000},
+	{782, MAX_TEMP},
+	{TSADCV3_DATA_MASK, MAX_TEMP},
+};
+
+static const struct tsadc_table rk3528_code_table[] = {
+	{0, MIN_TEMP},
+	{1386, MIN_TEMP},
+	{1419, -40000},
+	{1427, -35000},
+	{1435, -30000},
+	{1443, -25000},
+	{1452, -20000},
+	{1460, -15000},
+	{1468, -10000},
+	{1477, -5000},
+	{1486, 0},
+	{1494, 5000},
+	{1502, 10000},
+	{1510, 15000},
+	{1519, 20000},
+	{1527, 25000},
+	{1535, 30000},
+	{1544, 35000},
+	{1552, 40000},
+	{1561, 45000},
+	{1569, 50000},
+	{1578, 55000},
+	{1586, 60000},
+	{1594, 65000},
+	{1603, 70000},
+	{1612, 75000},
+	{1620, 80000},
+	{1628, 85000},
+	{1637, 90000},
+	{1646, 95000},
+	{1654, 100000},
+	{1662, 105000},
+	{1671, 110000},
+	{1679, 115000},
+	{1688, 120000},
+	{1696, 125000},
+	{1790, MAX_TEMP},
+	{TSADCV5_DATA_MASK, MAX_TEMP},
+};
+
+static const struct tsadc_table rk3562_code_table[] = {
+	{0, MIN_TEMP},
+	{1385, MIN_TEMP},
+	{1419, -40000},
+	{1428, -35000},
+	{1436, -30000},
+	{1445, -25000},
+	{1453, -20000},
+	{1462, -15000},
+	{1470, -10000},
+	{1479, -5000},
+	{1487, 0},
+	{1496, 5000},
+	{1504, 10000},
+	{1512, 15000},
+	{1521, 20000},
+	{1529, 25000},
+	{1538, 30000},
+	{1546, 35000},
+	{1555, 40000},
+	{1563, 45000},
+	{1572, 50000},
+	{1580, 55000},
+	{1589, 60000},
+	{1598, 65000},
+	{1606, 70000},
+	{1615, 75000},
+	{1623, 80000},
+	{1632, 85000},
+	{1640, 90000},
+	{1648, 95000},
+	{1657, 100000},
+	{1666, 105000},
+	{1674, 110000},
+	{1682, 115000},
+	{1691, 120000},
+	{1699, 125000},
+	{1793, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3568_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{1448, MIN_TEMP},
 	{1584, -40000},
 	{1620, -35000},
 	{1652, -30000},
@@ -645,16 +762,19 @@ static const struct tsadc_table rk3568_c
 	{2636, 115000},
 	{2672, 120000},
 	{2704, 125000},
-	{TSADCV2_DATA_MASK, 125000},
+	{3076, MAX_TEMP},
+	{TSADCV2_DATA_MASK, MAX_TEMP},
 };
 
 static const struct tsadc_table rk3588_code_table[] = {
-	{0, -40000},
+	{0, MIN_TEMP},
+	{194, MIN_TEMP},
 	{215, -40000},
 	{285, 25000},
 	{350, 85000},
 	{395, 125000},
-	{TSADCV4_DATA_MASK, 125000},
+	{455, MAX_TEMP},
+	{TSADCV4_DATA_MASK, MAX_TEMP},
 };
 
 static u32 rk_tsadcv2_temp_to_code(const struct chip_tsadc_table *table,
@@ -1030,6 +1150,68 @@ static void rk_tsadcv10_initialize(struc
 	}
 }
 
+static void rk_tsadcv11_initialize(struct regmap *grf, void __iomem *regs,
+				  enum tshut_polarity tshut_polarity)
+{
+	writel_relaxed(TSADCV7_AUTO_PERIOD_TIME, regs + TSADCV3_AUTO_PERIOD);
+	writel_relaxed(TSADCV7_AUTO_PERIOD_HT_TIME,
+		       regs + TSADCV3_AUTO_PERIOD_HT);
+	writel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,
+		       regs + TSADCV3_HIGHT_INT_DEBOUNCE);
+	writel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,
+		       regs + TSADCV3_HIGHT_TSHUT_DEBOUNCE);
+	writel_relaxed(TSADCV3_Q_MAX_VAL, regs + TSADCV9_Q_MAX);
+	writel_relaxed(TSADCV3_AUTO_Q_SEL_EN | TSADCV3_AUTO_Q_SEL_EN_MASK,
+		       regs + TSADCV2_AUTO_CON);
+	if (tshut_polarity == TSHUT_HIGH_ACTIVE)
+		writel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_HIGH |
+			       TSADCV2_AUTO_TSHUT_POLARITY_MASK,
+			       regs + TSADCV2_AUTO_CON);
+	else
+		writel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_MASK,
+			       regs + TSADCV2_AUTO_CON);
+
+	if (!IS_ERR(grf)) {
+		regmap_write(grf, RK3528_GRF_TSADC_CON, RK3568_GRF_TSADC_TSEN);
+		udelay(15);
+		regmap_write(grf, RK3528_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG0);
+		regmap_write(grf, RK3528_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG1);
+		regmap_write(grf, RK3528_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG2);
+		usleep_range(100, 200);
+	}
+}
+
+static void rk_tsadcv12_initialize(struct regmap *grf, void __iomem *regs,
+				   enum tshut_polarity tshut_polarity)
+{
+	writel_relaxed(TSADCV12_AUTO_PERIOD_TIME, regs + TSADCV3_AUTO_PERIOD);
+	writel_relaxed(TSADCV12_AUTO_PERIOD_HT_TIME,
+		       regs + TSADCV3_AUTO_PERIOD_HT);
+	writel_relaxed(TSADCV2_HIGHT_INT_DEBOUNCE_COUNT,
+		       regs + TSADCV3_HIGHT_INT_DEBOUNCE);
+	writel_relaxed(TSADCV2_HIGHT_TSHUT_DEBOUNCE_COUNT,
+		       regs + TSADCV3_HIGHT_TSHUT_DEBOUNCE);
+	writel_relaxed(TSADCV12_Q_MAX_VAL, regs + TSADCV9_Q_MAX);
+	writel_relaxed(TSADCV3_AUTO_Q_SEL_EN | TSADCV3_AUTO_Q_SEL_EN_MASK,
+		       regs + TSADCV2_AUTO_CON);
+	if (tshut_polarity == TSHUT_HIGH_ACTIVE)
+		writel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_HIGH |
+			       TSADCV2_AUTO_TSHUT_POLARITY_MASK,
+			       regs + TSADCV2_AUTO_CON);
+	else
+		writel_relaxed(TSADCV2_AUTO_TSHUT_POLARITY_MASK,
+			       regs + TSADCV2_AUTO_CON);
+
+	if (!IS_ERR(grf)) {
+		regmap_write(grf, RK3562_GRF_TSADC_CON, RK3568_GRF_TSADC_TSEN);
+		udelay(15);
+		regmap_write(grf, RK3562_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG0);
+		regmap_write(grf, RK3562_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG1);
+		regmap_write(grf, RK3562_GRF_TSADC_CON, RK3568_GRF_TSADC_ANA_REG2);
+		usleep_range(100, 200);
+	}
+}
+
 static void rk_tsadcv2_irq_ack(void __iomem *regs)
 {
 	u32 val;
@@ -1282,25 +1464,22 @@ static void rk_tsadcv4_tshut_mode(struct
 	writel_relaxed(val_cru, regs + TSADCV3_HSHUT_CRU_INT_EN);
 }
 
-static int rk_tsadcv1_get_trim_code(struct platform_device *pdev,
-				    int code, int trim_base)
+static int rk_tsadcv1_get_trim_code(const struct chip_tsadc_table *table,
+				    int code, int trim_base, int trim_base_frac)
 {
-	struct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);
-	const struct chip_tsadc_table *table = &thermal->chip->table;
-	u32 base_code;
-	int trim_code;
+	u32 base_code = (trim_base * table->kNum +
+			 trim_base_frac * table->kNum / 10) / 1000 + table->bNum;
 
-	base_code = trim_base * table->kNum / 1000 + table->bNum;
-	trim_code = code - base_code - 10;
-
-	return trim_code;
+	return code - base_code;
 }
 
-static int rk_tsadcv1_trim_temp(struct platform_device *pdev)
+static int rk_tsadcv2_get_trim_code(const struct chip_tsadc_table *table,
+				    int code, int trim_base, int trim_base_frac)
 {
-	struct rockchip_thermal_data *thermal = platform_get_drvdata(pdev);
+	int temp = trim_base * 1000 + trim_base_frac * 100;
+	u32 base_code = rk_tsadcv2_temp_to_code(table, temp);
 
-	return thermal->trim * 500;
+	return code - base_code;
 }
 
 static int rk_tsadcv1_set_clk_rate(struct platform_device *pdev)
@@ -1435,7 +1614,7 @@ static const struct rockchip_tsadc_chip
 	.set_tshut_temp = rk_tsadcv2_tshut_temp,
 	.set_tshut_mode = rk_tsadcv3_tshut_mode,
 	.get_trim_code = rk_tsadcv1_get_trim_code,
-	.trim_temp = rk_tsadcv1_trim_temp,
+	.trim_slope = 500,
 
 	.table = {
 		.kNum = 2263,
@@ -1666,6 +1845,54 @@ static const struct rockchip_tsadc_chip
 	},
 };
 
+static const struct rockchip_tsadc_chip rk3528_tsadc_data = {
+	.chn_id[SENSOR_CPU] = 0, /* cpu sensor is channel 0 */
+	.chn_num = 1, /* one channels for tsadc */
+
+	.tshut_mode = TSHUT_MODE_OTP, /* default TSHUT via GPIO give PMIC */
+	.tshut_polarity = TSHUT_LOW_ACTIVE, /* default TSHUT LOW ACTIVE */
+	.tshut_temp = 95000,
+
+	.initialize = rk_tsadcv11_initialize,
+	.irq_ack = rk_tsadcv4_irq_ack,
+	.control = rk_tsadcv4_control,
+	.get_temp = rk_tsadcv4_get_temp,
+	.set_alarm_temp = rk_tsadcv3_alarm_temp,
+	.set_tshut_temp = rk_tsadcv3_tshut_temp,
+	.set_tshut_mode = rk_tsadcv4_tshut_mode,
+
+	.table = {
+		.id = rk3528_code_table,
+		.length = ARRAY_SIZE(rk3528_code_table),
+		.data_mask = TSADCV2_DATA_MASK,
+		.mode = ADC_INCREMENT,
+	},
+};
+
+static const struct rockchip_tsadc_chip rk3562_tsadc_data = {
+	.chn_id[SENSOR_CPU] = 0, /* cpu sensor is channel 0 */
+	.chn_num = 1, /* one channels for tsadc */
+
+	.tshut_mode = TSHUT_MODE_OTP, /* default TSHUT via GPIO give PMIC */
+	.tshut_polarity = TSHUT_LOW_ACTIVE, /* default TSHUT LOW ACTIVE */
+	.tshut_temp = 95000,
+
+	.initialize = rk_tsadcv12_initialize,
+	.irq_ack = rk_tsadcv4_irq_ack,
+	.control = rk_tsadcv4_control,
+	.get_temp = rk_tsadcv4_get_temp,
+	.set_alarm_temp = rk_tsadcv3_alarm_temp,
+	.set_tshut_temp = rk_tsadcv3_tshut_temp,
+	.set_tshut_mode = rk_tsadcv4_tshut_mode,
+
+	.table = {
+		.id = rk3562_code_table,
+		.length = ARRAY_SIZE(rk3562_code_table),
+		.data_mask = TSADCV2_DATA_MASK,
+		.mode = ADC_INCREMENT,
+	},
+};
+
 static const struct rockchip_tsadc_chip rk3568_tsadc_data = {
 	.chn_id[SENSOR_CPU] = 0, /* cpu sensor is channel 0 */
 	.chn_id[SENSOR_GPU] = 1, /* gpu sensor is channel 1 */
@@ -1682,6 +1909,8 @@ static const struct rockchip_tsadc_chip
 	.set_alarm_temp = rk_tsadcv2_alarm_temp,
 	.set_tshut_temp = rk_tsadcv2_tshut_temp,
 	.set_tshut_mode = rk_tsadcv2_tshut_mode,
+	.get_trim_code = rk_tsadcv2_get_trim_code,
+	.trim_slope = 147,
 
 	.table = {
 		.id = rk3568_code_table,
@@ -1792,6 +2021,18 @@ static const struct of_device_id of_rock
 		.data = (void *)&rk3399_tsadc_data,
 	},
 #endif
+#ifdef CONFIG_CPU_RK3528
+	{
+		.compatible = "rockchip,rk3528-tsadc",
+		.data = (void *)&rk3528_tsadc_data,
+	},
+#endif
+#ifdef CONFIG_CPU_RK3562
+	{
+		.compatible = "rockchip,rk3562-tsadc",
+		.data = (void *)&rk3562_tsadc_data,
+	},
+#endif
 #ifdef CONFIG_CPU_RK3568
 	{
 		.compatible = "rockchip,rk3568-tsadc",
@@ -1844,8 +2085,7 @@ static int rockchip_thermal_set_trips(vo
 	dev_dbg(&thermal->pdev->dev, "%s: sensor %d: low: %d, high %d\n",
 		__func__, sensor->id, low, high);
 
-	if (tsadc->trim_temp)
-		high += tsadc->trim_temp(thermal->pdev);
+	high += sensor->trim_temp;
 
 	return tsadc->set_alarm_temp(&tsadc->table,
 				     sensor->id, thermal->regs, high);
@@ -1860,8 +2100,7 @@ static int rockchip_thermal_get_temp(voi
 
 	retval = tsadc->get_temp(&tsadc->table,
 				 sensor->id, thermal->regs, out_temp);
-	if (tsadc->trim_temp)
-		*out_temp -= tsadc->trim_temp(thermal->pdev);
+	*out_temp -= sensor->trim_temp;
 	dev_dbg(&thermal->pdev->dev, "sensor %d - temp: %d, retval: %d\n",
 		sensor->id, *out_temp, retval);
 
@@ -1912,27 +2151,103 @@ static int rockchip_get_efuse_value(stru
 	return 0;
 }
 
+static int rockchip_get_trim_configure(struct device *dev,
+				       struct device_node *np,
+				       struct rockchip_thermal_data *thermal)
+{
+	const struct rockchip_tsadc_chip *tsadc = thermal->chip;
+	struct device_node *node;
+	int trim_base = 0, trim_base_frac = 0, trim_l = 0, trim_h = 0;
+	int trim_temp, trim_code;
+	int i, id;
+
+	if (!tsadc->get_trim_code)
+		return 0;
+	/*
+	 * The tsadc won't to handle the error in here
+	 * since some SoCs didn't need this property.
+	 */
+	if (rockchip_get_efuse_value(np, "trim_base", &trim_base)) {
+		dev_info(dev, "Missing trim_base property\n");
+		return 0;
+	}
+	if (!trim_base)
+		return 0;
+	rockchip_get_efuse_value(np, "trim_base_frac", &trim_base_frac);
+	/*
+	 * If the tsadc node contains trim_h and trim_l property,
+	 * all channels use the common trim configure, otherwise,
+	 * get trim configure from child nodes.
+	 */
+	if (!rockchip_get_efuse_value(np, "trim_l", &trim_l) &&
+	    !rockchip_get_efuse_value(np, "trim_h", &trim_h)) {
+		if (!trim_l && !trim_h)
+			return 0;
+		trim_code = tsadc->get_trim_code(&tsadc->table,
+						 (trim_h << 8) | trim_l,
+						 trim_base, trim_base_frac);
+		trim_temp = thermal->chip->trim_slope * trim_code;
+		for (i = 0; i < thermal->chip->chn_num; i++) {
+			thermal->sensors[i].trim_temp = trim_temp;
+			thermal->sensors[i].tshut_temp += trim_temp;
+			if (thermal->sensors[i].tshut_temp > MAX_TEMP)
+				thermal->sensors[i].tshut_temp = MAX_TEMP;
+		}
+	} else {
+		for_each_available_child_of_node(np, node) {
+			if (of_property_read_u32(node, "reg", &id)) {
+				dev_info(dev, "Missing tsadc id property\n");
+				continue;
+			}
+			if (id >= SOC_MAX_SENSORS)
+				continue;
+			if (rockchip_get_efuse_value(node, "trim_l", &trim_l)) {
+				dev_info(dev, "ch%d Missing trim_l property\n",
+					 id);
+				continue;
+			}
+			if (rockchip_get_efuse_value(node, "trim_h", &trim_h)) {
+				dev_info(dev, "ch%d Missing trim_h property\n",
+					 id);
+				continue;
+			}
+			if (!trim_l && !trim_h)
+				continue;
+			trim_code = tsadc->get_trim_code(&tsadc->table,
+							 (trim_h << 8) | trim_l,
+							 trim_base,
+							 trim_base_frac);
+			trim_temp = thermal->chip->trim_slope * trim_code;
+			thermal->sensors[id].trim_temp = trim_temp;
+			thermal->sensors[id].tshut_temp += trim_temp;
+			if (thermal->sensors[id].tshut_temp > MAX_TEMP)
+				thermal->sensors[id].tshut_temp = MAX_TEMP;
+		}
+	}
+
+	return 0;
+}
+
 static int rockchip_configure_from_dt(struct device *dev,
 				      struct device_node *np,
 				      struct rockchip_thermal_data *thermal)
 {
-	const struct rockchip_tsadc_chip *tsadc = thermal->chip;
 	u32 shut_temp, tshut_mode, tshut_polarity;
-	int trim_l = 0, trim_h = 0, trim_bsae = 0;
+	int i;
 
 	if (of_property_read_u32(np, "rockchip,hw-tshut-temp", &shut_temp)) {
 		dev_warn(dev,
 			 "Missing tshut temp property, using default %d\n",
 			 thermal->chip->tshut_temp);
-		thermal->tshut_temp = thermal->chip->tshut_temp;
-	} else {
-		if (shut_temp > INT_MAX) {
-			dev_err(dev, "Invalid tshut temperature specified: %d\n",
-				shut_temp);
-			return -ERANGE;
-		}
-		thermal->tshut_temp = shut_temp;
+		shut_temp = thermal->chip->tshut_temp;
+	}
+	if (shut_temp > INT_MAX) {
+		dev_err(dev, "Invalid tshut temperature specified: %d\n",
+			shut_temp);
+		return -ERANGE;
 	}
+	for (i = 0; i < thermal->chip->chn_num; i++)
+		thermal->sensors[i].tshut_temp = shut_temp;
 
 	if (of_property_read_u32(np, "rockchip,hw-tshut-mode", &tshut_mode)) {
 		dev_warn(dev,
@@ -1974,28 +2289,7 @@ static int rockchip_configure_from_dt(st
 	if (IS_ERR(thermal->grf))
 		dev_warn(dev, "Missing rockchip,grf property\n");
 
-	if (tsadc->trim_temp && tsadc->get_trim_code) {
-		/* The tsadc won't to handle the error in here
-		 * since some SoCs didn't need this property.
-		 * rv1126 need trim tsadc.
-		 */
-		if (rockchip_get_efuse_value(np, "trim_l", &trim_l))
-			dev_warn(dev, "Missing trim_l property\n");
-		if (rockchip_get_efuse_value(np, "trim_h", &trim_h))
-			dev_warn(dev, "Missing trim_h property\n");
-		if (rockchip_get_efuse_value(np, "trim_base", &trim_bsae))
-			dev_warn(dev, "Missing trim_base property\n");
-
-		if (trim_l && trim_h && trim_bsae) {
-			thermal->trim = tsadc->get_trim_code(thermal->pdev,
-							     (trim_h << 8) |
-							     trim_l,
-							     trim_bsae);
-			dev_info(dev, "tsadc trimmed value = %d\n",
-				 thermal->trim);
-			thermal->tshut_temp += tsadc->trim_temp(thermal->pdev);
-		}
-	}
+	rockchip_get_trim_configure(dev, np, thermal);
 
 	return 0;
 }
@@ -2013,10 +2307,10 @@ rockchip_thermal_register_sensor(struct
 			      thermal->tshut_mode);
 
 	error = tsadc->set_tshut_temp(&tsadc->table, id, thermal->regs,
-			      thermal->tshut_temp);
+				      sensor->tshut_temp);
 	if (error)
 		dev_err(&pdev->dev, "%s: invalid tshut=%d, error=%d\n",
-			__func__, thermal->tshut_temp, error);
+			__func__, sensor->tshut_temp, error);
 
 	sensor->thermal = thermal;
 	sensor->id = id;
@@ -2297,16 +2591,17 @@ static int __maybe_unused rockchip_therm
 
 	for (i = 0; i < thermal->chip->chn_num; i++) {
 		int id = thermal->sensors[i].id;
+		int tshut_temp = thermal->sensors[i].tshut_temp;
 
 		thermal->chip->set_tshut_mode(thermal->grf, id, thermal->regs,
 					      thermal->tshut_mode);
 
 		error = thermal->chip->set_tshut_temp(&thermal->chip->table,
-					      id, thermal->regs,
-					      thermal->tshut_temp);
+						      id, thermal->regs,
+						      tshut_temp);
 		if (error)
 			dev_err(dev, "%s: invalid tshut=%d, error=%d\n",
-				__func__, thermal->tshut_temp, error);
+				__func__, tshut_temp, error);
 	}
 
 	thermal->chip->control(thermal->regs, true);
@@ -2337,7 +2632,17 @@ static struct platform_driver rockchip_t
 	.shutdown = rockchip_thermal_shutdown,
 };
 
-module_platform_driver(rockchip_thermal_driver);
+static int __init rockchip_thermal_driver_init(void)
+{
+	return platform_driver_register(&rockchip_thermal_driver);
+}
+rootfs_initcall(rockchip_thermal_driver_init);
+
+static void __exit rockchip_thermal_driver_exit(void)
+{
+	platform_driver_unregister(&rockchip_thermal_driver);
+}
+module_exit(rockchip_thermal_driver_exit);
 
 MODULE_DESCRIPTION("ROCKCHIP THERMAL Driver");
 MODULE_AUTHOR("Rockchip, Inc.");
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -169,8 +169,13 @@ static void __dwc3_set_mode(struct work_
 		break;
 	}
 
-	/* For DRD host or device mode only */
-	if (dwc->desired_dr_role != DWC3_GCTL_PRTCAP_OTG) {
+	/*
+	 * When current_dr_role is not set, there's no role switching.
+	 * Only perform GCTL.CoreSoftReset when there's DRD role switching.
+	 */
+	if (dwc->current_dr_role && ((DWC3_IP_IS(DWC3) ||
+			DWC3_VER_IS_PRIOR(DWC31, 190A)) &&
+			dwc->desired_dr_role != DWC3_GCTL_PRTCAP_OTG)) {
 		reg = dwc3_readl(dwc->regs, DWC3_GCTL);
 		reg |= DWC3_GCTL_CORESOFTRESET;
 		dwc3_writel(dwc->regs, DWC3_GCTL, reg);
@@ -342,7 +347,8 @@ int dwc3_core_soft_reset(struct dwc3 *dw
 
 	reg = dwc3_readl(dwc->regs, DWC3_DCTL);
 	reg |= DWC3_DCTL_CSFTRST;
-	dwc3_writel(dwc->regs, DWC3_DCTL, reg);
+	reg &= ~DWC3_DCTL_RUN_STOP;
+	dwc3_gadget_dctl_write_safe(dwc, reg);
 
 	/*
 	 * For DWC_usb31 controller 1.90a and later, the DCTL.CSFRST bit
@@ -793,15 +799,16 @@ static void dwc3_core_exit(struct dwc3 *
 {
 	dwc3_event_buffers_cleanup(dwc);
 
+	usb_phy_set_suspend(dwc->usb2_phy, 1);
+	usb_phy_set_suspend(dwc->usb3_phy, 1);
+	phy_power_off(dwc->usb2_generic_phy);
+	phy_power_off(dwc->usb3_generic_phy);
+
 	usb_phy_shutdown(dwc->usb2_phy);
 	usb_phy_shutdown(dwc->usb3_phy);
 	phy_exit(dwc->usb2_generic_phy);
 	phy_exit(dwc->usb3_generic_phy);
 
-	usb_phy_set_suspend(dwc->usb2_phy, 1);
-	usb_phy_set_suspend(dwc->usb3_phy, 1);
-	phy_power_off(dwc->usb2_generic_phy);
-	phy_power_off(dwc->usb3_generic_phy);
 	clk_bulk_disable_unprepare(dwc->num_clks, dwc->clks);
 	reset_control_assert(dwc->reset);
 }
@@ -1320,10 +1327,10 @@ static void dwc3_get_properties(struct d
 	u8			lpm_nyet_threshold;
 	u8			tx_de_emphasis;
 	u8			hird_threshold;
-	u8			rx_thr_num_pkt_prd;
-	u8			rx_max_burst_prd;
-	u8			tx_thr_num_pkt_prd;
-	u8			tx_max_burst_prd;
+	u8			rx_thr_num_pkt_prd = 0;
+	u8			rx_max_burst_prd = 0;
+	u8			tx_thr_num_pkt_prd = 0;
+	u8			tx_max_burst_prd = 0;
 	u8			tx_fifo_resize_max_num;
 	const char		*usb_psy_name;
 	int			ret;
@@ -1715,16 +1722,16 @@ err5:
 	dwc3_debugfs_exit(dwc);
 	dwc3_event_buffers_cleanup(dwc);
 
-	usb_phy_shutdown(dwc->usb2_phy);
-	usb_phy_shutdown(dwc->usb3_phy);
-	phy_exit(dwc->usb2_generic_phy);
-	phy_exit(dwc->usb3_generic_phy);
-
 	usb_phy_set_suspend(dwc->usb2_phy, 1);
 	usb_phy_set_suspend(dwc->usb3_phy, 1);
 	phy_power_off(dwc->usb2_generic_phy);
 	phy_power_off(dwc->usb3_generic_phy);
 
+	usb_phy_shutdown(dwc->usb2_phy);
+	usb_phy_shutdown(dwc->usb3_phy);
+	phy_exit(dwc->usb2_generic_phy);
+	phy_exit(dwc->usb3_generic_phy);
+
 	dwc3_ulpi_exit(dwc);
 
 err4:
--- a/drivers/usb/dwc3/drd.c
+++ b/drivers/usb/dwc3/drd.c
@@ -595,16 +595,15 @@ int dwc3_drd_init(struct dwc3 *dwc)
 {
 	int ret, irq;
 
+	if (ROLE_SWITCH &&
+	    device_property_read_bool(dwc->dev, "usb-role-switch"))
+		return dwc3_setup_role_switch(dwc);
+
 	dwc->edev = dwc3_get_extcon(dwc);
 	if (IS_ERR(dwc->edev))
 		return PTR_ERR(dwc->edev);
 
-	if (ROLE_SWITCH &&
-	    device_property_read_bool(dwc->dev, "usb-role-switch")) {
-		ret = dwc3_setup_role_switch(dwc);
-		if (ret < 0)
-			return ret;
-	} else if (dwc->edev) {
+	if (dwc->edev) {
 		dwc->edev_nb.notifier_call = dwc3_drd_notifier;
 		ret = extcon_register_notifier(dwc->edev, EXTCON_USB_HOST,
 					       &dwc->edev_nb);
--- a/drivers/usb/dwc3/gadget.c
+++ b/drivers/usb/dwc3/gadget.c
@@ -292,7 +292,8 @@ int dwc3_send_gadget_ep_cmd(struct dwc3_
 	 *
 	 * DWC_usb3 3.30a and DWC_usb31 1.90a programming guide section 3.2.2
 	 */
-	if (dwc->gadget->speed <= USB_SPEED_HIGH) {
+	if (dwc->gadget->speed <= USB_SPEED_HIGH ||
+	    DWC3_DEPCMD_CMD(cmd) == DWC3_DEPCMD_ENDTRANSFER) {
 		reg = dwc3_readl(dwc->regs, DWC3_GUSB2PHYCFG(0));
 		if (unlikely(reg & DWC3_GUSB2PHYCFG_SUSPHY)) {
 			saved_config |= DWC3_GUSB2PHYCFG_SUSPHY;
@@ -332,9 +333,17 @@ int dwc3_send_gadget_ep_cmd(struct dwc3_
 		}
 	}
 
-	dwc3_writel(dep->regs, DWC3_DEPCMDPAR0, params->param0);
-	dwc3_writel(dep->regs, DWC3_DEPCMDPAR1, params->param1);
-	dwc3_writel(dep->regs, DWC3_DEPCMDPAR2, params->param2);
+	/*
+	 * For some commands such as Update Transfer command, DEPCMDPARn
+	 * registers are reserved. Since the driver often sends Update Transfer
+	 * command, don't write to DEPCMDPARn to avoid register write delays and
+	 * improve performance.
+	 */
+	if (DWC3_DEPCMD_CMD(cmd) != DWC3_DEPCMD_UPDATETRANSFER) {
+		dwc3_writel(dep->regs, DWC3_DEPCMDPAR0, params->param0);
+		dwc3_writel(dep->regs, DWC3_DEPCMDPAR1, params->param1);
+		dwc3_writel(dep->regs, DWC3_DEPCMDPAR2, params->param2);
+	}
 
 	/*
 	 * Synopsys Databook 2.60a states in section 6.3.2.5.6 of that if we're
@@ -1158,13 +1167,7 @@ static int __dwc3_gadget_ep_disable(stru
 	reg &= ~DWC3_DALEPENA_EP(dep->number);
 	dwc3_writel(dwc->regs, DWC3_DALEPENA, reg);
 
-	/* Clear out the ep descriptors for non-ep0 */
-	if (dep->number > 1) {
-		dep->endpoint.comp_desc = NULL;
-		dep->endpoint.desc = NULL;
-	}
-
-	dwc3_remove_requests(dwc, dep, -ECONNRESET);
+	dwc3_remove_requests(dwc, dep, -ESHUTDOWN);
 
 	dep->stream_capable = false;
 	dep->type = 0;
@@ -1178,6 +1181,12 @@ static int __dwc3_gadget_ep_disable(stru
 		mask |= (DWC3_EP_DELAY_STOP | DWC3_EP_TRANSFER_STARTED);
 	dep->flags &= mask;
 
+	/* Clear out the ep descriptors for non-ep0 */
+	if (dep->number > 1) {
+		dep->endpoint.comp_desc = NULL;
+		dep->endpoint.desc = NULL;
+	}
+
 	return 0;
 }
 
@@ -1333,17 +1342,49 @@ static u32 dwc3_calc_trbs_left(struct dw
 	return trbs_left;
 }
 
-static void __dwc3_prepare_one_trb(struct dwc3_ep *dep, struct dwc3_trb *trb,
-		dma_addr_t dma, unsigned int length, unsigned int chain,
-		unsigned int node, unsigned int stream_id,
-		unsigned int short_not_ok, unsigned int no_interrupt,
-		unsigned int is_last, bool must_interrupt)
+/**
+ * dwc3_prepare_one_trb - setup one TRB from one request
+ * @dep: endpoint for which this request is prepared
+ * @req: dwc3_request pointer
+ * @trb_length: buffer size of the TRB
+ * @chain: should this TRB be chained to the next?
+ * @node: only for isochronous endpoints. First TRB needs different type.
+ * @use_bounce_buffer: set to use bounce buffer
+ * @must_interrupt: set to interrupt on TRB completion
+ */
+static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
+		struct dwc3_request *req, unsigned int trb_length,
+		unsigned int chain, unsigned int node, bool use_bounce_buffer,
+		bool must_interrupt)
 {
+	struct dwc3_trb		*trb;
+	dma_addr_t		dma;
+	unsigned int		stream_id = req->request.stream_id;
+	unsigned int		short_not_ok = req->request.short_not_ok;
+	unsigned int		no_interrupt = req->request.no_interrupt;
+	unsigned int		is_last = req->request.is_last;
 	struct dwc3		*dwc = dep->dwc;
 	struct usb_gadget	*gadget = dwc->gadget;
 	enum usb_device_speed	speed = gadget->speed;
 
-	trb->size = DWC3_TRB_SIZE_LENGTH(length);
+	if (use_bounce_buffer)
+		dma = dep->dwc->bounce_addr;
+	else if (req->request.num_sgs > 0)
+		dma = sg_dma_address(req->start_sg);
+	else
+		dma = req->request.dma;
+
+	trb = &dep->trb_pool[dep->trb_enqueue];
+
+	if (!req->trb) {
+		dwc3_gadget_move_started_request(req);
+		req->trb = trb;
+		req->trb_dma = dwc3_trb_dma_offset(dep, trb);
+	}
+
+	req->num_trbs++;
+
+	trb->size = DWC3_TRB_SIZE_LENGTH(trb_length);
 	trb->bpl = lower_32_bits(dma);
 	trb->bph = upper_32_bits(dma);
 
@@ -1383,10 +1424,10 @@ static void __dwc3_prepare_one_trb(struc
 				unsigned int mult = 2;
 				unsigned int maxp = usb_endpoint_maxp(ep->desc);
 
-				if (length <= (2 * maxp))
+				if (req->request.length <= (2 * maxp))
 					mult--;
 
-				if (length <= maxp)
+				if (req->request.length <= maxp)
 					mult--;
 
 				trb->size |= DWC3_TRB_SIZE_PCM1(mult);
@@ -1395,8 +1436,8 @@ static void __dwc3_prepare_one_trb(struc
 			trb->ctrl = DWC3_TRBCTL_ISOCHRONOUS;
 		}
 
-		/* always enable Interrupt on Missed ISOC */
-		trb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;
+		if (!no_interrupt && !chain)
+			trb->ctrl |= DWC3_TRB_CTRL_ISP_IMI;
 		break;
 
 	case USB_ENDPOINT_XFER_BULK:
@@ -1455,50 +1496,6 @@ static void __dwc3_prepare_one_trb(struc
 	trace_dwc3_prepare_trb(dep, trb);
 }
 
-/**
- * dwc3_prepare_one_trb - setup one TRB from one request
- * @dep: endpoint for which this request is prepared
- * @req: dwc3_request pointer
- * @trb_length: buffer size of the TRB
- * @chain: should this TRB be chained to the next?
- * @node: only for isochronous endpoints. First TRB needs different type.
- * @use_bounce_buffer: set to use bounce buffer
- * @must_interrupt: set to interrupt on TRB completion
- */
-static void dwc3_prepare_one_trb(struct dwc3_ep *dep,
-		struct dwc3_request *req, unsigned int trb_length,
-		unsigned int chain, unsigned int node, bool use_bounce_buffer,
-		bool must_interrupt)
-{
-	struct dwc3_trb		*trb;
-	dma_addr_t		dma;
-	unsigned int		stream_id = req->request.stream_id;
-	unsigned int		short_not_ok = req->request.short_not_ok;
-	unsigned int		no_interrupt = req->request.no_interrupt;
-	unsigned int		is_last = req->request.is_last;
-
-	if (use_bounce_buffer)
-		dma = dep->dwc->bounce_addr;
-	else if (req->request.num_sgs > 0)
-		dma = sg_dma_address(req->start_sg);
-	else
-		dma = req->request.dma;
-
-	trb = &dep->trb_pool[dep->trb_enqueue];
-
-	if (!req->trb) {
-		dwc3_gadget_move_started_request(req);
-		req->trb = trb;
-		req->trb_dma = dwc3_trb_dma_offset(dep, trb);
-	}
-
-	req->num_trbs++;
-
-	__dwc3_prepare_one_trb(dep, trb, dma, trb_length, chain, node,
-			stream_id, short_not_ok, no_interrupt, is_last,
-			must_interrupt);
-}
-
 static bool dwc3_needs_extra_trb(struct dwc3_ep *dep, struct dwc3_request *req)
 {
 	unsigned int maxp = usb_endpoint_maxp(dep->endpoint.desc);
@@ -2132,13 +2129,11 @@ static int __dwc3_gadget_ep_queue(struct
 	 * errors which will force us issue EndTransfer command.
 	 */
 	if (usb_endpoint_xfer_isoc(dep->endpoint.desc)) {
-		if (!(dep->flags & DWC3_EP_PENDING_REQUEST) &&
-				!(dep->flags & DWC3_EP_TRANSFER_STARTED))
-			return 0;
-
-		if ((dep->flags & DWC3_EP_PENDING_REQUEST)) {
-			if (!(dep->flags & DWC3_EP_TRANSFER_STARTED))
+		if (!(dep->flags & DWC3_EP_TRANSFER_STARTED)) {
+			if ((dep->flags & DWC3_EP_PENDING_REQUEST))
 				return __dwc3_gadget_start_isoc(dep);
+
+			return 0;
 		}
 	}
 
@@ -3185,8 +3180,8 @@ static const struct usb_gadget_ops dwc3_
 	.udc_set_ssp_rate	= dwc3_gadget_set_ssp_rate,
 	.get_config_params	= dwc3_gadget_config_params,
 	.vbus_draw		= dwc3_gadget_vbus_draw,
-	//.check_config		= dwc3_gadget_check_config,
-	//.udc_async_callbacks	= dwc3_gadget_async_callbacks,
+	.check_config		= dwc3_gadget_check_config,
+	.udc_async_callbacks	= dwc3_gadget_async_callbacks,
 };
 
 /* -------------------------------------------------------------------------- */
@@ -3211,6 +3206,7 @@ static int dwc3_gadget_init_in_endpoint(
 	struct dwc3 *dwc = dep->dwc;
 	u32 mdwidth;
 	int size;
+	int maxpacket;
 
 	mdwidth = dwc3_mdwidth(dwc);
 
@@ -3223,21 +3219,24 @@ static int dwc3_gadget_init_in_endpoint(
 	else
 		size = DWC31_GTXFIFOSIZ_TXFDEP(size);
 
-	/* FIFO Depth is in MDWDITH bytes. Multiply */
-	size *= mdwidth;
-
 	/*
-	 * To meet performance requirement, a minimum TxFIFO size of 3x
-	 * MaxPacketSize is recommended for endpoints that support burst and a
-	 * minimum TxFIFO size of 2x MaxPacketSize for endpoints that don't
-	 * support burst. Use those numbers and we can calculate the max packet
-	 * limit as below.
+	 * maxpacket size is determined as part of the following, after assuming
+	 * a mult value of one maxpacket:
+	 * DWC3 revision 280A and prior:
+	 * fifo_size = mult * (max_packet / mdwidth) + 1;
+	 * maxpacket = mdwidth * (fifo_size - 1);
+	 *
+	 * DWC3 revision 290A and onwards:
+	 * fifo_size = mult * ((max_packet + mdwidth)/mdwidth + 1) + 1
+	 * maxpacket = mdwidth * ((fifo_size - 1) - 1) - mdwidth;
 	 */
-	if (dwc->maximum_speed >= USB_SPEED_SUPER)
-		size /= 3;
+	if (DWC3_VER_IS_PRIOR(DWC3, 290A))
+		maxpacket = mdwidth * (size - 1);
 	else
-		size /= 2;
+		maxpacket = mdwidth * ((size - 1) - 1) - mdwidth;
 
+	/* Functionally, space for one max packet is sufficient */
+	size = min_t(int, maxpacket, 1024);
 	/*
 	 * If enable tx fifos resize, set each in ep maxpacket
 	 * to 1024, it can avoid being dependent on the default
@@ -3245,7 +3244,6 @@ static int dwc3_gadget_init_in_endpoint(
 	 */
 	if (dwc->do_fifo_resize)
 		size = 1024;
-
 	usb_ep_set_maxpacket_limit(&dep->endpoint, size);
 
 	dep->endpoint.max_streams = 16;
@@ -3472,6 +3470,10 @@ static int dwc3_gadget_ep_reclaim_comple
 	if (event->status & DEPEVT_STATUS_SHORT && !chain)
 		return 1;
 
+	if ((trb->ctrl & DWC3_TRB_CTRL_ISP_IMI) &&
+	    DWC3_TRB_SIZE_TRBSTS(trb->size) == DWC3_TRBSTS_MISSED_ISOC)
+		return 1;
+
 	if ((trb->ctrl & DWC3_TRB_CTRL_IOC) ||
 	    (trb->ctrl & DWC3_TRB_CTRL_LST))
 		return 1;
@@ -3525,6 +3527,7 @@ static int dwc3_gadget_ep_cleanup_comple
 		struct dwc3_request *req, int status)
 {
 	struct dwc3 *dwc = dep->dwc;
+	int request_status;
 	int ret;
 
 	if (req->request.num_mapped_sgs)
@@ -3567,7 +3570,35 @@ static int dwc3_gadget_ep_cleanup_comple
 		goto out;
 	}
 
-	dwc3_gadget_giveback(dep, req, status);
+	/*
+	 * The event status only reflects the status of the TRB with IOC set.
+	 * For the requests that don't set interrupt on completion, the driver
+	 * needs to check and return the status of the completed TRBs associated
+	 * with the request. Use the status of the last TRB of the request.
+	 */
+	if (req->request.no_interrupt) {
+		struct dwc3_trb *trb;
+
+		trb = dwc3_ep_prev_trb(dep, dep->trb_dequeue);
+		switch (DWC3_TRB_SIZE_TRBSTS(trb->size)) {
+		case DWC3_TRBSTS_MISSED_ISOC:
+			/* Isoc endpoint only */
+			request_status = -EXDEV;
+			break;
+		case DWC3_TRB_STS_XFER_IN_PROG:
+			/* Applicable when End Transfer with ForceRM=0 */
+		case DWC3_TRBSTS_SETUP_PENDING:
+			/* Control endpoint only */
+		case DWC3_TRBSTS_OK:
+		default:
+			request_status = 0;
+			break;
+		}
+	} else {
+		request_status = status;
+	}
+
+	dwc3_gadget_giveback(dep, req, request_status);
 
 out:
 	return ret;
@@ -4509,7 +4540,6 @@ static irqreturn_t dwc3_process_event_bu
 	struct dwc3 *dwc = evt->dwc;
 	irqreturn_t ret = IRQ_NONE;
 	int left;
-	u32 reg;
 
 	left = evt->count;
 
@@ -4537,19 +4567,20 @@ static irqreturn_t dwc3_process_event_bu
 	}
 
 	evt->count = 0;
-	evt->flags &= ~DWC3_EVENT_PENDING;
 	ret = IRQ_HANDLED;
 
 	/* Unmask interrupt */
-	reg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));
-	reg &= ~DWC3_GEVNTSIZ_INTMASK;
-	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);
+	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0),
+		    DWC3_GEVNTSIZ_SIZE(evt->length));
 
 	if (dwc->imod_interval) {
 		dwc3_writel(dwc->regs, DWC3_GEVNTCOUNT(0), DWC3_GEVNTCOUNT_EHB);
 		dwc3_writel(dwc->regs, DWC3_DEV_IMOD(0), dwc->imod_interval);
 	}
 
+	/* Keep the clearing of DWC3_EVENT_PENDING at the end */
+	evt->flags &= ~DWC3_EVENT_PENDING;
+
 	return ret;
 }
 
@@ -4574,7 +4605,6 @@ static irqreturn_t dwc3_check_event_buf(
 	struct dwc3 *dwc = evt->dwc;
 	u32 amount;
 	u32 count;
-	u32 reg;
 
 	if (pm_runtime_suspended(dwc->dev)) {
 		dwc->pending_events = true;
@@ -4606,9 +4636,8 @@ static irqreturn_t dwc3_check_event_buf(
 	evt->flags |= DWC3_EVENT_PENDING;
 
 	/* Mask interrupt */
-	reg = dwc3_readl(dwc->regs, DWC3_GEVNTSIZ(0));
-	reg |= DWC3_GEVNTSIZ_INTMASK;
-	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0), reg);
+	dwc3_writel(dwc->regs, DWC3_GEVNTSIZ(0),
+		    DWC3_GEVNTSIZ_INTMASK | DWC3_GEVNTSIZ_SIZE(evt->length));
 
 	amount = min(count, evt->length - evt->lpos);
 	memcpy(evt->cache + evt->lpos, evt->buf + evt->lpos, amount);
--- a/drivers/usb/host/ehci-platform.c
+++ b/drivers/usb/host/ehci-platform.c
@@ -56,6 +56,25 @@ struct ehci_platform_priv {
 
 static const char hcd_name[] = "ehci-platform";
 
+#define USIC_MICROFRAME_OFFSET	0x90
+#define USIC_SCALE_DOWN_OFFSET	0xa0
+#define USIC_ENABLE_OFFSET	0xb0
+#define USIC_ENABLE		BIT(0)
+#define USIC_SCALE_DOWN		BIT(2)
+#define USIC_MICROFRAME_COUNT	0x1d4d
+
+static void ehci_usic_init(struct usb_hcd *hcd)
+{
+	struct ehci_hcd *ehci = hcd_to_ehci(hcd);
+
+	ehci_writel(ehci, USIC_ENABLE,
+		    hcd->regs + USIC_ENABLE_OFFSET);
+	ehci_writel(ehci, USIC_MICROFRAME_COUNT,
+		    hcd->regs + USIC_MICROFRAME_OFFSET);
+	ehci_writel(ehci, USIC_SCALE_DOWN,
+		    hcd->regs + USIC_SCALE_DOWN_OFFSET);
+}
+
 static int ehci_platform_reset(struct usb_hcd *hcd)
 {
 	struct platform_device *pdev = to_platform_device(hcd->self.controller);
@@ -244,6 +263,8 @@ static int ehci_platform_probe(struct pl
 	struct ehci_platform_priv *priv;
 	struct ehci_hcd *ehci;
 	int err, irq, clk = 0;
+	struct device *companion_dev;
+	struct device_link *link;
 
 	if (usb_disabled())
 		return -ENODEV;
@@ -375,6 +396,25 @@ static int ehci_platform_probe(struct pl
 	if (err)
 		goto err_power;
 
+	if (of_usb_get_phy_mode(dev->dev.of_node) == USBPHY_INTERFACE_MODE_HSIC)
+		ehci_usic_init(hcd);
+
+	if (of_device_is_compatible(dev->dev.of_node,
+				    "rockchip,rk3588-ehci")) {
+		companion_dev = usb_of_get_companion_dev(hcd->self.controller);
+		if (companion_dev) {
+			link = device_link_add(companion_dev, hcd->self.controller,
+					       DL_FLAG_STATELESS);
+			put_device(companion_dev);
+			if (!link) {
+				dev_err(&dev->dev, "Unable to link %s\n",
+					dev_name(companion_dev));
+				err = -EINVAL;
+				goto err_power;
+			}
+		}
+	}
+
 	device_wakeup_enable(hcd->self.controller);
 	device_enable_async_suspend(hcd->self.controller);
 	platform_set_drvdata(dev, hcd);
@@ -406,11 +446,21 @@ static int ehci_platform_remove(struct p
 	struct usb_hcd *hcd = platform_get_drvdata(dev);
 	struct usb_ehci_pdata *pdata = dev_get_platdata(&dev->dev);
 	struct ehci_platform_priv *priv = hcd_to_ehci_priv(hcd);
+	struct device *companion_dev;
 	int clk;
 
 	if (priv->quirk_poll)
 		quirk_poll_end(priv);
 
+	if (of_device_is_compatible(dev->dev.of_node,
+				    "rockchip,rk3588-ehci")) {
+		companion_dev = usb_of_get_companion_dev(hcd->self.controller);
+		if (companion_dev) {
+			device_link_remove(companion_dev, hcd->self.controller);
+			put_device(companion_dev);
+		}
+	}
+
 	usb_remove_hcd(hcd);
 
 	if (pdata->power_off)
--- a/include/dt-bindings/soc/rockchip,boot-mode.h
+++ b/include/dt-bindings/soc/rockchip,boot-mode.h
@@ -20,5 +20,7 @@
 #define BOOT_CHARGING		(REBOOT_FLAG + 11)
 /* enter usb mass storage mode */
 #define BOOT_UMS		(REBOOT_FLAG + 12)
+/* reboot system quiescent */
+#define BOOT_QUIESCENT		(REBOOT_FLAG + 14)
 
 #endif
--- a/include/linux/dma-buf.h
+++ b/include/linux/dma-buf.h
@@ -355,7 +355,7 @@ struct dma_buf_ops {
 	int (*get_flags)(struct dma_buf *dmabuf, unsigned long *flags);
 };
 
-#ifdef CONFIG_NO_GKI
+#ifdef CONFIG_DMABUF_CACHE
 /**
  * dma_buf_destructor - dma-buf destructor function
  * @dmabuf:	[in]	pointer to dma-buf
@@ -435,9 +435,10 @@ struct dma_buf {
 		struct dma_buf *dmabuf;
 	} *sysfs_entry;
 #endif
-#ifdef CONFIG_NO_GKI
+#ifdef CONFIG_DMABUF_CACHE
 	dma_buf_destructor dtor;
 	void *dtor_data;
+	struct mutex cache_lock;
 #endif
 };
 
@@ -632,7 +633,7 @@ long dma_buf_set_name(struct dma_buf *dm
 int dma_buf_get_flags(struct dma_buf *dmabuf, unsigned long *flags);
 int dma_buf_get_uuid(struct dma_buf *dmabuf, uuid_t *uuid);
 
-#ifdef CONFIG_NO_GKI
+#ifdef CONFIG_DMABUF_CACHE
 /**
  * dma_buf_set_destructor - set the dma-buf's destructor
  * @dmabuf:		[in]	pointer to dma-buf
--- a/include/linux/irqchip/arm-gic-v4.h
+++ b/include/linux/irqchip/arm-gic-v4.h
@@ -39,6 +39,8 @@ struct its_vpe {
 	irq_hw_number_t		vpe_db_lpi;
 	/* VPE resident */
 	bool			resident;
+	/* VPT parse complete */
+	bool			ready;
 	union {
 		/* GICv4.0 implementations */
 		struct {
@@ -104,6 +106,7 @@ enum its_vcpu_info_cmd_type {
 	PROP_UPDATE_AND_INV_VLPI,
 	SCHEDULE_VPE,
 	DESCHEDULE_VPE,
+	COMMIT_VPE,
 	INVALL_VPE,
 	PROP_UPDATE_VSGI,
 };
@@ -129,6 +132,7 @@ int its_alloc_vcpu_irqs(struct its_vm *v
 void its_free_vcpu_irqs(struct its_vm *vm);
 int its_make_vpe_resident(struct its_vpe *vpe, bool g0en, bool g1en);
 int its_make_vpe_non_resident(struct its_vpe *vpe, bool db);
+int its_commit_vpe(struct its_vpe *vpe);
 int its_invall_vpe(struct its_vpe *vpe);
 int its_map_vlpi(int irq, struct its_vlpi_map *map);
 int its_get_vlpi(int irq, struct its_vlpi_map *map);
--- a/include/linux/regulator/fan53555.h
+++ b/include/linux/regulator/fan53555.h
@@ -52,8 +52,6 @@ struct fan53555_platform_data {
 	unsigned int slew_rate;
 	/* Sleep VSEL ID */
 	unsigned int sleep_vsel_id;
-	int limit_volt;
-	struct gpio_desc *vsel_gpio;
 };
 
 #endif /* __FAN53555_H__ */
--- a/include/media/videobuf2-core.h
+++ b/include/media/videobuf2-core.h
@@ -19,7 +19,7 @@
 #include <linux/bitops.h>
 #include <media/media-request.h>
 
-#define VB2_MAX_FRAME	(32)
+#define VB2_MAX_FRAME	(64)
 #define VB2_MAX_PLANES	(8)
 
 /**
@@ -1177,6 +1177,22 @@ vb2_plane_size(struct vb2_buffer *vb, un
 	return 0;
 }
 
+#if defined(CONFIG_ARCH_ROCKCHIP) && IS_ENABLED(CONFIG_USB_F_UVC)
+/**
+ * vb2_plane_data_offset() - return plane data_offset in bytes.
+ * @vb:		pointer to &struct vb2_buffer to which the plane in
+ *		question belongs to.
+ * @plane_no:	plane number for which size should be returned.
+ */
+static inline unsigned long
+vb2_plane_data_offset(struct vb2_buffer *vb, unsigned int plane_no)
+{
+	if (plane_no < vb->num_planes)
+		return vb->planes[plane_no].data_offset;
+	return 0;
+}
+#endif
+
 /**
  * vb2_start_streaming_called() - return streaming status of driver.
  * @q:		pointer to &struct vb2_queue with videobuf2 queue.
--- a/include/uapi/linux/videodev2.h
+++ b/include/uapi/linux/videodev2.h
@@ -70,7 +70,7 @@
  * Common stuff for both V4L1 and V4L2
  * Moved from videodev.h
  */
-#define VIDEO_MAX_FRAME               32
+#define VIDEO_MAX_FRAME               64
 #define VIDEO_MAX_PLANES               8
 
 /*
@@ -689,6 +689,7 @@ struct v4l2_pix_format {
 #define V4L2_PIX_FMT_JPEG     v4l2_fourcc('J', 'P', 'E', 'G') /* JFIF JPEG     */
 #define V4L2_PIX_FMT_DV       v4l2_fourcc('d', 'v', 's', 'd') /* 1394          */
 #define V4L2_PIX_FMT_MPEG     v4l2_fourcc('M', 'P', 'E', 'G') /* MPEG-1/2/4 Multiplexed */
+#define V4L2_PIX_FMT_H265     v4l2_fourcc('H', '2', '6', '5') /* H265 with start codes */
 #define V4L2_PIX_FMT_H264     v4l2_fourcc('H', '2', '6', '4') /* H264 with start codes */
 #define V4L2_PIX_FMT_H264_NO_SC v4l2_fourcc('A', 'V', 'C', '1') /* H264 without start codes */
 #define V4L2_PIX_FMT_H264_MVC v4l2_fourcc('M', '2', '6', '4') /* H264 MVC */
@@ -993,6 +996,7 @@ struct v4l2_plane {
 		__s32		fd;
 	} m;
 	__u32			data_offset;
+	/* reserved fields used by few userspace clients and drivers */
 	__u32			reserved[11];
 };
 
@@ -1778,6 +1782,16 @@ enum v4l2_ctrl_type {
 	V4L2_CTRL_TYPE_U16	     = 0x0101,
 	V4L2_CTRL_TYPE_U32	     = 0x0102,
 	V4L2_CTRL_TYPE_AREA          = 0x0106,
+
+	V4L2_CTRL_TYPE_HDR10_CLL_INFO		= 0x0110,
+	V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY	= 0x0111,
+
+	V4L2_CTRL_TYPE_H264_SPS             = 0x0200,
+	V4L2_CTRL_TYPE_H264_PPS		    = 0x0201,
+	V4L2_CTRL_TYPE_H264_SCALING_MATRIX  = 0x0202,
+	V4L2_CTRL_TYPE_H264_SLICE_PARAMS    = 0x0203,
+	V4L2_CTRL_TYPE_H264_DECODE_PARAMS   = 0x0204,
+	V4L2_CTRL_TYPE_H264_PRED_WEIGHTS    = 0x0205,
 };
 
 /*  Used in the VIDIOC_QUERYCTRL ioctl for querying controls */
