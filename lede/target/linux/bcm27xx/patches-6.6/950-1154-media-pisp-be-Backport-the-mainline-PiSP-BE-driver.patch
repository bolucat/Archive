From c75989589bf77530f4013e0bc799169504c69937 Mon Sep 17 00:00:00 2001
From: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
Date: Thu, 27 Jun 2024 11:41:22 +0200
Subject: [PATCH 1154/1215] media: pisp-be: Backport the mainline PiSP BE
 driver

Backport to rpi-6.6.y the mainline version of the PiSP BE driver.

The backported version of the driver corresponds to the one available
at:
https://lore.kernel.org/all/20240626181440.195137-1-jacopo.mondi@ideasonboard.com/

Signed-off-by: Jacopo Mondi <jacopo.mondi@ideasonboard.com>
---
 .../platform/raspberrypi/pisp_be/Kconfig      |    4 +-
 .../platform/raspberrypi/pisp_be/pisp_be.c    | 1288 +++++++----------
 .../raspberrypi/pisp_be/pisp_be_config.h      |  533 -------
 .../raspberrypi/pisp_be/pisp_be_formats.h     |   44 +-
 4 files changed, 572 insertions(+), 1297 deletions(-)
 delete mode 100644 drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h

--- a/drivers/media/platform/raspberrypi/pisp_be/Kconfig
+++ b/drivers/media/platform/raspberrypi/pisp_be/Kconfig
@@ -1,10 +1,10 @@
 config VIDEO_RASPBERRYPI_PISP_BE
 	tristate "Raspberry Pi PiSP Backend (BE) ISP driver"
-	depends on VIDEO_DEV && PM
+	depends on V4L_PLATFORM_DRIVERS
+	depends on VIDEO_DEV
 	select VIDEO_V4L2_SUBDEV_API
 	select MEDIA_CONTROLLER
 	select VIDEOBUF2_DMA_CONTIG
-	select V4L2_FWNODE
 	help
 	  Say Y here to enable support for the PiSP Backend (BE) ISP driver.
 
--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
+++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be.c
@@ -1,12 +1,14 @@
 // SPDX-License-Identifier: GPL-2.0
 /*
  * PiSP Back End driver.
- * Copyright (c) 2021-2022 Raspberry Pi Limited.
+ * Copyright (c) 2021-2024 Raspberry Pi Limited.
  *
  */
 #include <linux/clk.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/lockdep.h>
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
@@ -15,49 +17,39 @@
 #include <media/videobuf2-dma-contig.h>
 #include <media/videobuf2-vmalloc.h>
 
-#include "pisp_be_config.h"
-#include "pisp_be_formats.h"
-
-MODULE_DESCRIPTION("PiSP Back End driver");
-MODULE_AUTHOR("David Plowman <david.plowman@raspberrypi.com>");
-MODULE_AUTHOR("Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>");
-MODULE_LICENSE("GPL v2");
+#include <uapi/linux/media/raspberrypi/pisp_be_config.h>
 
-/* Offset to use when registering the /dev/videoX node */
-#define PISPBE_VIDEO_NODE_OFFSET 20
+#include "pisp_be_formats.h"
 
 /* Maximum number of config buffers possible */
 #define PISP_BE_NUM_CONFIG_BUFFERS VB2_MAX_FRAME
 
-/*
- * We want to support 2 independent instances allowing 2 simultaneous users
- * of the ISP-BE (of course they share hardware, platform resources and mutex).
- * Each such instance comprises a group of device nodes representing input
- * and output queues, and a media controller device node to describe them.
- */
-#define PISPBE_NUM_NODE_GROUPS 2
-
 #define PISPBE_NAME "pispbe"
 
 /* Some ISP-BE registers */
-#define PISP_BE_VERSION_OFFSET (0x0)
-#define PISP_BE_CONTROL_OFFSET (0x4)
-#define PISP_BE_TILE_ADDR_LO_OFFSET (0x8)
-#define PISP_BE_TILE_ADDR_HI_OFFSET (0xc)
-#define PISP_BE_STATUS_OFFSET (0x10)
-#define PISP_BE_BATCH_STATUS_OFFSET (0x14)
-#define PISP_BE_INTERRUPT_EN_OFFSET (0x18)
-#define PISP_BE_INTERRUPT_STATUS_OFFSET (0x1c)
-#define PISP_BE_AXI_OFFSET (0x20)
-#define PISP_BE_CONFIG_BASE_OFFSET (0x40)
-#define PISP_BE_IO_INPUT_ADDR0_LO_OFFSET (PISP_BE_CONFIG_BASE_OFFSET)
-#define PISP_BE_GLOBAL_BAYER_ENABLE_OFFSET (PISP_BE_CONFIG_BASE_OFFSET + 0x70)
-#define PISP_BE_GLOBAL_RGB_ENABLE_OFFSET (PISP_BE_CONFIG_BASE_OFFSET + 0x74)
-#define N_HW_ADDRESSES 14
-#define N_HW_ENABLES 2
+#define PISP_BE_VERSION_REG		0x0
+#define PISP_BE_CONTROL_REG		0x4
+#define PISP_BE_CONTROL_COPY_CONFIG	BIT(1)
+#define PISP_BE_CONTROL_QUEUE_JOB	BIT(0)
+#define PISP_BE_CONTROL_NUM_TILES(n)	((n) << 16)
+#define PISP_BE_TILE_ADDR_LO_REG	0x8
+#define PISP_BE_TILE_ADDR_HI_REG	0xc
+#define PISP_BE_STATUS_REG		0x10
+#define PISP_BE_STATUS_QUEUED		BIT(0)
+#define PISP_BE_BATCH_STATUS_REG	0x14
+#define PISP_BE_INTERRUPT_EN_REG	0x18
+#define PISP_BE_INTERRUPT_STATUS_REG	0x1c
+#define PISP_BE_AXI_REG			0x20
+#define PISP_BE_CONFIG_BASE_REG		0x40
+#define PISP_BE_IO_ADDR_LOW(n)		(PISP_BE_CONFIG_BASE_REG + 8 * (n))
+#define PISP_BE_IO_ADDR_HIGH(n)		(PISP_BE_IO_ADDR_LOW((n)) + 4)
+#define PISP_BE_GLOBAL_BAYER_ENABLE	0xb0
+#define PISP_BE_GLOBAL_RGB_ENABLE	0xb4
+#define N_HW_ADDRESSES			13
+#define N_HW_ENABLES			2
 
-#define PISP_BE_VERSION_2712C1 0x02252700
-#define PISP_BE_VERSION_MINOR_BITS 0xF
+#define PISP_BE_VERSION_2712		0x02252700
+#define PISP_BE_VERSION_MINOR_BITS	0xf
 
 /*
  * This maps our nodes onto the inputs/outputs of the actual PiSP Back End.
@@ -65,11 +57,10 @@ MODULE_LICENSE("GPL v2");
  * context it means an input to the hardware (source image or metadata).
  * Elsewhere it means an output from the hardware.
  */
-enum node_ids {
+enum pispbe_node_ids {
 	MAIN_INPUT_NODE,
 	TDN_INPUT_NODE,
 	STITCH_INPUT_NODE,
-	HOG_OUTPUT_NODE,
 	OUTPUT0_NODE,
 	OUTPUT1_NODE,
 	TDN_OUTPUT_NODE,
@@ -78,13 +69,13 @@ enum node_ids {
 	PISPBE_NUM_NODES
 };
 
-struct node_description {
+struct pispbe_node_description {
 	const char *ent_name;
 	enum v4l2_buf_type buf_type;
 	unsigned int caps;
 };
 
-static const struct node_description node_desc[PISPBE_NUM_NODES] = {
+static const struct pispbe_node_description node_desc[PISPBE_NUM_NODES] = {
 	/* MAIN_INPUT_NODE */
 	{
 		.ent_name = PISPBE_NAME "-input",
@@ -103,12 +94,6 @@ static const struct node_description nod
 		.buf_type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE,
 		.caps = V4L2_CAP_VIDEO_OUTPUT_MPLANE,
 	},
-	/* HOG_OUTPUT_NODE */
-	{
-		.ent_name = PISPBE_NAME "-hog_output",
-		.buf_type = V4L2_BUF_TYPE_META_CAPTURE,
-		.caps = V4L2_CAP_META_CAPTURE,
-	},
 	/* OUTPUT0_NODE */
 	{
 		.ent_name = PISPBE_NAME "-output0",
@@ -147,14 +132,12 @@ static const struct node_description nod
 	((desc)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))
 
 #define NODE_IS_META(node) ( \
-	((node)->buf_type == V4L2_BUF_TYPE_META_OUTPUT) || \
-	((node)->buf_type == V4L2_BUF_TYPE_META_CAPTURE))
+	((node)->buf_type == V4L2_BUF_TYPE_META_OUTPUT))
 #define NODE_IS_OUTPUT(node) ( \
 	((node)->buf_type == V4L2_BUF_TYPE_META_OUTPUT) || \
 	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT) || \
 	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE))
 #define NODE_IS_CAPTURE(node) ( \
-	((node)->buf_type == V4L2_BUF_TYPE_META_CAPTURE) || \
 	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE) || \
 	((node)->buf_type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE))
 #define NODE_IS_MPLANE(node) ( \
@@ -173,9 +156,12 @@ struct pispbe_node {
 	struct media_pad pad;
 	struct media_intf_devnode *intf_devnode;
 	struct media_link *intf_link;
-	struct pispbe_node_group *node_group;
+	struct pispbe_dev *pispbe;
+	/* Video device lock */
 	struct mutex node_lock;
+	/* vb2_queue lock */
 	struct mutex queue_lock;
+	/* Protect pispbe_node->ready_queue and pispbe_buffer->ready_list */
 	spinlock_t ready_lock;
 	struct list_head ready_queue;
 	struct vb2_queue queue;
@@ -186,29 +172,10 @@ struct pispbe_node {
 /* For logging only, use the entity name with "pispbe" and separator removed */
 #define NODE_NAME(node) \
 		(node_desc[(node)->id].ent_name + sizeof(PISPBE_NAME))
-#define NODE_GET_V4L2(node) ((node)->node_group->v4l2_dev)
-
-/*
- * Node group structure, which comprises all the input and output nodes that a
- * single PiSP client will need, along with its own v4l2 and media devices.
- */
-struct pispbe_node_group {
-	unsigned int id;
-	struct v4l2_device v4l2_dev;
-	struct v4l2_subdev sd;
-	struct pispbe_dev *pispbe;
-	struct media_device mdev;
-	struct pispbe_node node[PISPBE_NUM_NODES];
-	u32 streaming_map; /* bitmap of which nodes are streaming */
-	struct media_pad pad[PISPBE_NUM_NODES]; /* output pads first */
-	struct pisp_be_tiles_config *config;
-	dma_addr_t config_dma_addr;
-	unsigned int sequence;
-};
 
 /* Records details of the jobs currently running or queued on the h/w. */
 struct pispbe_job {
-	struct pispbe_node_group *node_group;
+	bool valid;
 	/*
 	 * An array of buffer pointers - remember it's source buffers first,
 	 * then captures, then metadata last.
@@ -216,85 +183,66 @@ struct pispbe_job {
 	struct pispbe_buffer *buf[PISPBE_NUM_NODES];
 };
 
+struct pispbe_hw_enables {
+	u32 bayer_enables;
+	u32 rgb_enables;
+};
+
+/* Records a job configuration and memory addresses. */
+struct pispbe_job_descriptor {
+	dma_addr_t hw_dma_addrs[N_HW_ADDRESSES];
+	struct pisp_be_tiles_config *config;
+	struct pispbe_hw_enables hw_enables;
+	dma_addr_t tiles;
+};
+
 /*
  * Structure representing the entire PiSP Back End device, comprising several
- * node groups which share platform resources and a mutex for the actual HW.
+ * nodes which share platform resources and a mutex for the actual HW.
  */
 struct pispbe_dev {
 	struct device *dev;
-	struct pispbe_node_group node_group[PISPBE_NUM_NODE_GROUPS];
-	int hw_busy; /* non-zero if a job is queued or is being started */
-	struct pispbe_job queued_job, running_job;
+	struct pispbe_dev *pispbe;
+	struct pisp_be_tiles_config *config;
 	void __iomem *be_reg_base;
 	struct clk *clk;
+	struct v4l2_device v4l2_dev;
+	struct v4l2_subdev sd;
+	struct media_device mdev;
+	struct media_pad pad[PISPBE_NUM_NODES]; /* output pads first */
+	struct pispbe_node node[PISPBE_NUM_NODES];
+	dma_addr_t config_dma_addr;
+	unsigned int sequence;
+	u32 streaming_map;
+	struct pispbe_job queued_job, running_job;
+	spinlock_t hw_lock; /* protects "hw_busy" flag and streaming_map */
+	bool hw_busy; /* non-zero if a job is queued or is being started */
 	int irq;
 	u32 hw_version;
 	u8 done, started;
-	spinlock_t hw_lock; /* protects "hw_busy" flag and streaming_map */
 };
 
-static inline u32 read_reg(struct pispbe_dev *pispbe, unsigned int offset)
+static u32 pispbe_rd(struct pispbe_dev *pispbe, unsigned int offset)
 {
 	return readl(pispbe->be_reg_base + offset);
 }
 
-static inline void write_reg(struct pispbe_dev *pispbe, unsigned int offset,
-			     u32 val)
+static void pispbe_wr(struct pispbe_dev *pispbe, unsigned int offset, u32 val)
 {
 	writel(val, pispbe->be_reg_base + offset);
 }
 
-/* Check and initialize hardware. */
-static int hw_init(struct pispbe_dev *pispbe)
-{
-	u32 u;
-
-	/* Check the HW is present and has a known version */
-	u = read_reg(pispbe, PISP_BE_VERSION_OFFSET);
-	dev_info(pispbe->dev, "pispbe_probe: HW version:  0x%08x", u);
-	pispbe->hw_version = u;
-	if ((u & ~PISP_BE_VERSION_MINOR_BITS) != PISP_BE_VERSION_2712C1)
-		return -ENODEV;
-
-	/* Clear leftover interrupts */
-	write_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET, 0xFFFFFFFFu);
-	u = read_reg(pispbe, PISP_BE_BATCH_STATUS_OFFSET);
-	dev_info(pispbe->dev, "pispbe_probe: BatchStatus: 0x%08x", u);
-	pispbe->done = (uint8_t)u;
-	pispbe->started = (uint8_t)(u >> 8);
-	u = read_reg(pispbe, PISP_BE_STATUS_OFFSET);
-	dev_info(pispbe->dev, "pispbe_probe: Status:      0x%08x", u);
-	if (u != 0 || pispbe->done != pispbe->started) {
-		dev_err(pispbe->dev, "pispbe_probe: HW is stuck or busy\n");
-		return -EBUSY;
-	}
-	/*
-	 * AXI QOS=0, CACHE=4'b0010, PROT=3'b011
-	 * Also set "chicken bits" 22:20 which enable sub-64-byte bursts
-	 * and AXI AWID/BID variability (on versions which support this).
-	 */
-	write_reg(pispbe, PISP_BE_AXI_OFFSET, 0x32703200u);
-
-	/* Enable both interrupt flags */
-	write_reg(pispbe, PISP_BE_INTERRUPT_EN_OFFSET, 0x00000003u);
-	return 0;
-}
-
 /*
  * Queue a job to the h/w. If the h/w is idle it will begin immediately.
  * Caller must ensure it is "safe to queue", i.e. we don't already have a
  * queued, unstarted job.
  */
-static void hw_queue_job(struct pispbe_dev *pispbe,
-			 dma_addr_t hw_dma_addrs[N_HW_ADDRESSES],
-			 u32 hw_enables[N_HW_ENABLES],
-			 struct pisp_be_config *config, dma_addr_t tiles,
-			 unsigned int num_tiles)
+static void pispbe_queue_job(struct pispbe_dev *pispbe,
+			     struct pispbe_job_descriptor *job)
 {
 	unsigned int begin, end;
-	unsigned int u;
 
-	if (read_reg(pispbe, PISP_BE_STATUS_OFFSET) & 1)
+	if (pispbe_rd(pispbe, PISP_BE_STATUS_REG) & PISP_BE_STATUS_QUEUED)
 		dev_err(pispbe->dev, "ERROR: not safe to queue new job!\n");
 
 	/*
@@ -303,51 +251,49 @@ static void hw_queue_job(struct pispbe_d
 	 * and we don't want to modify (or be vulnerable to modifications of)
 	 * the mmap'd buffer.
 	 */
-	for (u = 0; u < N_HW_ADDRESSES; ++u) {
-		write_reg(pispbe, PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u,
-			  (u32)(hw_dma_addrs[u]));
-		write_reg(pispbe, PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u + 4,
-			  (u32)(hw_dma_addrs[u] >> 32));
-	}
-	write_reg(pispbe, PISP_BE_GLOBAL_BAYER_ENABLE_OFFSET, hw_enables[0]);
-	write_reg(pispbe, PISP_BE_GLOBAL_RGB_ENABLE_OFFSET, hw_enables[1]);
+	for (unsigned int u = 0; u < N_HW_ADDRESSES; ++u) {
+		pispbe_wr(pispbe, PISP_BE_IO_ADDR_LOW(u),
+			  lower_32_bits(job->hw_dma_addrs[u]));
+		pispbe_wr(pispbe, PISP_BE_IO_ADDR_HIGH(u),
+			  upper_32_bits(job->hw_dma_addrs[u]));
+	}
+	pispbe_wr(pispbe, PISP_BE_GLOBAL_BAYER_ENABLE,
+		  job->hw_enables.bayer_enables);
+	pispbe_wr(pispbe, PISP_BE_GLOBAL_RGB_ENABLE,
+		  job->hw_enables.rgb_enables);
 
-	/*
-	 * Everything else is as supplied by the user. XXX Buffer sizes not
-	 * checked!
-	 */
+	/* Everything else is as supplied by the user. */
 	begin =	offsetof(struct pisp_be_config, global.bayer_order) /
-								sizeof(u32);
-	end = offsetof(struct pisp_be_config, axi) / sizeof(u32);
-	for (u = begin; u < end; u++) {
-		unsigned int val = ((u32 *)config)[u];
-
-		write_reg(pispbe, PISP_BE_CONFIG_BASE_OFFSET + 4 * u, val);
-	}
+		sizeof(u32);
+	end = sizeof(struct pisp_be_config) / sizeof(u32);
+	for (unsigned int u = begin; u < end; u++)
+		pispbe_wr(pispbe, PISP_BE_CONFIG_BASE_REG + sizeof(u32) * u,
+			  ((u32 *)job->config)[u]);
 
 	/* Read back the addresses -- an error here could be fatal */
-	for (u = 0; u < N_HW_ADDRESSES; ++u) {
-		unsigned int offset = PISP_BE_IO_INPUT_ADDR0_LO_OFFSET + 8 * u;
-		u64 along = read_reg(pispbe, offset);
-
-		along += ((u64)read_reg(pispbe, offset + 4)) << 32;
-		if (along != (u64)(hw_dma_addrs[u])) {
-			dev_err(pispbe->dev,
+	for (unsigned int u = 0; u < N_HW_ADDRESSES; ++u) {
+		unsigned int offset = PISP_BE_IO_ADDR_LOW(u);
+		u64 along = pispbe_rd(pispbe, offset);
+
+		along += ((u64)pispbe_rd(pispbe, offset + 4)) << 32;
+		if (along != (u64)(job->hw_dma_addrs[u])) {
+			dev_dbg(pispbe->dev,
 				"ISP BE config error: check if ISP RAMs enabled?\n");
 			return;
 		}
 	}
 
 	/*
-	 * Write tile pointer to hardware. XXX Tile offsets and sizes not
-	 * checked (and even if checked, the user could subsequently modify
-	 * them)!
+	 * Write tile pointer to hardware. The IOMMU should prevent
+	 * out-of-bounds offsets reaching non-ISP buffers.
 	 */
-	write_reg(pispbe, PISP_BE_TILE_ADDR_LO_OFFSET, (u32)tiles);
-	write_reg(pispbe, PISP_BE_TILE_ADDR_HI_OFFSET, (u32)(tiles >> 32));
+	pispbe_wr(pispbe, PISP_BE_TILE_ADDR_LO_REG, lower_32_bits(job->tiles));
+	pispbe_wr(pispbe, PISP_BE_TILE_ADDR_HI_REG, upper_32_bits(job->tiles));
 
 	/* Enqueue the job */
-	write_reg(pispbe, PISP_BE_CONTROL_OFFSET, 3 + 65536 * num_tiles);
+	pispbe_wr(pispbe, PISP_BE_CONTROL_REG,
+		  PISP_BE_CONTROL_COPY_CONFIG | PISP_BE_CONTROL_QUEUE_JOB |
+		  PISP_BE_CONTROL_NUM_TILES(job->config->num_tiles));
 }
 
 struct pispbe_buffer {
@@ -356,8 +302,8 @@ struct pispbe_buffer {
 	unsigned int config_index;
 };
 
-static int get_addr_3(dma_addr_t addr[3], struct pispbe_buffer *buf,
-		      struct pispbe_node *node)
+static int pispbe_get_planes_addr(dma_addr_t addr[3], struct pispbe_buffer *buf,
+				  struct pispbe_node *node)
 {
 	unsigned int num_planes = node->format.fmt.pix_mp.num_planes;
 	unsigned int plane_factor = 0;
@@ -367,22 +313,20 @@ static int get_addr_3(dma_addr_t addr[3]
 	if (!buf || !node->pisp_format)
 		return 0;
 
-	WARN_ON(!NODE_IS_MPLANE(node));
-
 	/*
 	 * Determine the base plane size. This will not be the same
 	 * as node->format.fmt.pix_mp.plane_fmt[0].sizeimage for a single
 	 * plane buffer in an mplane format.
 	 */
 	size = node->format.fmt.pix_mp.plane_fmt[0].bytesperline *
-					node->format.fmt.pix_mp.height;
+	       node->format.fmt.pix_mp.height;
 
-	for (p = 0; p < num_planes && p < 3; p++) {
+	for (p = 0; p < num_planes && p < PISPBE_MAX_PLANES; p++) {
 		addr[p] = vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, p);
 		plane_factor += node->pisp_format->plane_factor[p];
 	}
 
-	for (; p < MAX_PLANES && node->pisp_format->plane_factor[p]; p++) {
+	for (; p < PISPBE_MAX_PLANES && node->pisp_format->plane_factor[p]; p++) {
 		/*
 		 * Calculate the address offset of this plane as needed
 		 * by the hardware. This is specifically for non-mplane
@@ -396,41 +340,41 @@ static int get_addr_3(dma_addr_t addr[3]
 	return num_planes;
 }
 
-static dma_addr_t get_addr(struct pispbe_buffer *buf)
+static dma_addr_t pispbe_get_addr(struct pispbe_buffer *buf)
 {
 	if (buf)
 		return vb2_dma_contig_plane_dma_addr(&buf->vb.vb2_buf, 0);
+
 	return 0;
 }
 
-static void
-fixup_addrs_enables(dma_addr_t addrs[N_HW_ADDRESSES],
-		    u32 hw_enables[N_HW_ENABLES],
-		    struct pisp_be_tiles_config *config,
-		    struct pispbe_buffer *buf[PISPBE_NUM_NODES],
-		    struct pispbe_node_group *node_group)
-{
-	int ret, i;
+static void pispbe_xlate_addrs(struct pispbe_dev *pispbe,
+			       struct pispbe_job_descriptor *job,
+			       struct pispbe_buffer *buf[PISPBE_NUM_NODES])
+{
+	struct pispbe_hw_enables *hw_en = &job->hw_enables;
+	struct pisp_be_tiles_config *config = job->config;
+	dma_addr_t *addrs = job->hw_dma_addrs;
+	int ret;
 
 	/* Take a copy of the "enable" bitmaps so we can modify them. */
-	hw_enables[0] = config->config.global.bayer_enables;
-	hw_enables[1] = config->config.global.rgb_enables;
+	hw_en->bayer_enables = config->config.global.bayer_enables;
+	hw_en->rgb_enables = config->config.global.rgb_enables;
 
 	/*
 	 * Main input first. There are 3 address pointers, corresponding to up
 	 * to 3 planes.
 	 */
-	ret = get_addr_3(addrs, buf[MAIN_INPUT_NODE],
-			 &node_group->node[MAIN_INPUT_NODE]);
+	ret = pispbe_get_planes_addr(addrs, buf[MAIN_INPUT_NODE],
+				     &pispbe->node[MAIN_INPUT_NODE]);
 	if (ret <= 0) {
 		/*
 		 * This shouldn't happen; pispbe_schedule_internal should insist
 		 * on an input.
 		 */
-		dev_warn(node_group->pispbe->dev,
-			"ISP-BE missing input\n");
-		hw_enables[0] = 0;
-		hw_enables[1] = 0;
+		dev_warn(pispbe->dev, "ISP-BE missing input\n");
+		hw_en->bayer_enables = 0;
+		hw_en->rgb_enables = 0;
 		return;
 	}
 
@@ -439,118 +383,114 @@ fixup_addrs_enables(dma_addr_t addrs[N_H
 	 * used with Bayer input. Input enables must match the requirements
 	 * of the processing stages, otherwise the hardware can lock up!
 	 */
-	if (hw_enables[0] & PISP_BE_BAYER_ENABLE_INPUT) {
-		addrs[3] = get_addr(buf[TDN_INPUT_NODE]);
+	if (hw_en->bayer_enables & PISP_BE_BAYER_ENABLE_INPUT) {
+		addrs[3] = pispbe_get_addr(buf[TDN_INPUT_NODE]);
 		if (addrs[3] == 0 ||
-		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_TDN_INPUT) ||
-		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_TDN) ||
+		    !(hw_en->bayer_enables & PISP_BE_BAYER_ENABLE_TDN_INPUT) ||
+		    !(hw_en->bayer_enables & PISP_BE_BAYER_ENABLE_TDN) ||
 		    (config->config.tdn.reset & 1)) {
-			hw_enables[0] &= ~(PISP_BE_BAYER_ENABLE_TDN_INPUT |
-					   PISP_BE_BAYER_ENABLE_TDN_DECOMPRESS);
+			hw_en->bayer_enables &=
+				~(PISP_BE_BAYER_ENABLE_TDN_INPUT |
+				  PISP_BE_BAYER_ENABLE_TDN_DECOMPRESS);
 			if (!(config->config.tdn.reset & 1))
-				hw_enables[0] &= ~PISP_BE_BAYER_ENABLE_TDN;
+				hw_en->bayer_enables &=
+					~PISP_BE_BAYER_ENABLE_TDN;
 		}
 
-		addrs[4] = get_addr(buf[STITCH_INPUT_NODE]);
+		addrs[4] = pispbe_get_addr(buf[STITCH_INPUT_NODE]);
 		if (addrs[4] == 0 ||
-		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_STITCH_INPUT) ||
-		    !(hw_enables[0] & PISP_BE_BAYER_ENABLE_STITCH)) {
-			hw_enables[0] &=
+		    !(hw_en->bayer_enables & PISP_BE_BAYER_ENABLE_STITCH_INPUT) ||
+		    !(hw_en->bayer_enables & PISP_BE_BAYER_ENABLE_STITCH)) {
+			hw_en->bayer_enables &=
 				~(PISP_BE_BAYER_ENABLE_STITCH_INPUT |
 				  PISP_BE_BAYER_ENABLE_STITCH_DECOMPRESS |
 				  PISP_BE_BAYER_ENABLE_STITCH);
 		}
 
-		addrs[5] = get_addr(buf[TDN_OUTPUT_NODE]);
+		addrs[5] = pispbe_get_addr(buf[TDN_OUTPUT_NODE]);
 		if (addrs[5] == 0)
-			hw_enables[0] &= ~(PISP_BE_BAYER_ENABLE_TDN_COMPRESS |
-					   PISP_BE_BAYER_ENABLE_TDN_OUTPUT);
+			hw_en->bayer_enables &=
+				~(PISP_BE_BAYER_ENABLE_TDN_COMPRESS |
+				  PISP_BE_BAYER_ENABLE_TDN_OUTPUT);
 
-		addrs[6] = get_addr(buf[STITCH_OUTPUT_NODE]);
+		addrs[6] = pispbe_get_addr(buf[STITCH_OUTPUT_NODE]);
 		if (addrs[6] == 0)
-			hw_enables[0] &=
+			hw_en->bayer_enables &=
 				~(PISP_BE_BAYER_ENABLE_STITCH_COMPRESS |
 				  PISP_BE_BAYER_ENABLE_STITCH_OUTPUT);
 	} else {
 		/* No Bayer input? Disable entire Bayer pipe (else lockup) */
-		hw_enables[0] = 0;
+		hw_en->bayer_enables = 0;
 	}
 
 	/* Main image output channels. */
-	for (i = 0; i < PISP_BACK_END_NUM_OUTPUTS; i++) {
-		ret = get_addr_3(addrs + 7 + 3 * i, buf[OUTPUT0_NODE + i],
-				 &node_group->node[OUTPUT0_NODE + i]);
+	for (unsigned int i = 0; i < PISP_BACK_END_NUM_OUTPUTS; i++) {
+		ret = pispbe_get_planes_addr(addrs + 7 + 3 * i,
+					     buf[OUTPUT0_NODE + i],
+					     &pispbe->node[OUTPUT0_NODE + i]);
 		if (ret <= 0)
-			hw_enables[1] &= ~(PISP_BE_RGB_ENABLE_OUTPUT0 << i);
+			hw_en->rgb_enables &= ~(PISP_BE_RGB_ENABLE_OUTPUT0 << i);
 	}
-
-	/* HoG output (always single plane). */
-	addrs[13] = get_addr(buf[HOG_OUTPUT_NODE]);
-	if (addrs[13] == 0)
-		hw_enables[1] &= ~PISP_BE_RGB_ENABLE_HOG;
 }
 
 /*
- * Internal function. Called from pispbe_schedule_one/all. Returns non-zero if
- * we started a job.
+ * Prepare a job description to be submitted to the HW.
+ *
+ * To schedule a job, we need all streaming nodes (apart from Output0,
+ * Output1, Tdn and Stitch) to have a buffer ready, which must
+ * include at least a config buffer and a main input image.
  *
- * Warning: needs to be called with hw_lock taken, and releases it if it
- * schedules a job.
+ * For Output0, Output1, Tdn and Stitch, a buffer only needs to be
+ * available if the blocks are enabled in the config.
+ *
+ * Needs to be called with hw_lock held.
+ *
+ * Returns 0 if a job has been successfully prepared, < 0 otherwise.
  */
-static int pispbe_schedule_internal(struct pispbe_node_group *node_group,
-				    unsigned long flags)
+static int pispbe_prepare_job(struct pispbe_dev *pispbe,
+			      struct pispbe_job_descriptor *job)
 {
-	struct pisp_be_tiles_config *config_tiles_buffer;
-	struct pispbe_dev *pispbe = node_group->pispbe;
-	struct pispbe_buffer *buf[PISPBE_NUM_NODES];
-	dma_addr_t hw_dma_addrs[N_HW_ADDRESSES];
-	dma_addr_t tiles;
-	u32 hw_enables[N_HW_ENABLES];
-	struct pispbe_node *node;
-	unsigned long flags1;
+	struct pispbe_buffer *buf[PISPBE_NUM_NODES] = {};
 	unsigned int config_index;
-	int i;
+	struct pispbe_node *node;
+	unsigned long flags;
+
+	lockdep_assert_held(&pispbe->hw_lock);
+
+	memset(job, 0, sizeof(struct pispbe_job_descriptor));
 
-	/*
-	 * To schedule a job, we need all streaming nodes (apart from Output0,
-	 * Output1, Tdn and Stitch) to have a buffer ready, which must
-	 * include at least a config buffer and a main input image.
-	 *
-	 * For Output0, Output1, Tdn and Stitch, a buffer only needs to be
-	 * available if the blocks are enabled in the config.
-	 *
-	 * (Note that streaming_map is protected by hw_lock, which is held.)
-	 */
 	if (((BIT(CONFIG_NODE) | BIT(MAIN_INPUT_NODE)) &
-		node_group->streaming_map) !=
-			(BIT(CONFIG_NODE) | BIT(MAIN_INPUT_NODE))) {
-		dev_dbg(pispbe->dev, "Nothing to do\n");
-		return 0;
-	}
+		pispbe->streaming_map) !=
+			(BIT(CONFIG_NODE) | BIT(MAIN_INPUT_NODE)))
+		return -ENODEV;
 
-	node = &node_group->node[CONFIG_NODE];
-	spin_lock_irqsave(&node->ready_lock, flags1);
-	buf[CONFIG_NODE] =
-	   list_first_entry_or_null(&node->ready_queue, struct pispbe_buffer,
-				    ready_list);
-	spin_unlock_irqrestore(&node->ready_lock, flags1);
+	node = &pispbe->node[CONFIG_NODE];
+	spin_lock_irqsave(&node->ready_lock, flags);
+	buf[CONFIG_NODE] = list_first_entry_or_null(&node->ready_queue,
+						    struct pispbe_buffer,
+						    ready_list);
+	if (buf[CONFIG_NODE]) {
+		list_del(&buf[CONFIG_NODE]->ready_list);
+		pispbe->queued_job.buf[CONFIG_NODE] = buf[CONFIG_NODE];
+	}
+	spin_unlock_irqrestore(&node->ready_lock, flags);
 
 	/* Exit early if no config buffer has been queued. */
 	if (!buf[CONFIG_NODE])
-		return 0;
+		return -ENODEV;
 
 	config_index = buf[CONFIG_NODE]->vb.vb2_buf.index;
-	config_tiles_buffer = &node_group->config[config_index];
-	tiles = (dma_addr_t)node_group->config_dma_addr +
-			config_index * sizeof(struct pisp_be_tiles_config) +
-			offsetof(struct pisp_be_tiles_config, tiles);
+	job->config = &pispbe->config[config_index];
+	job->tiles = pispbe->config_dma_addr +
+		     config_index * sizeof(struct pisp_be_tiles_config) +
+		     offsetof(struct pisp_be_tiles_config, tiles);
 
 	/* remember: srcimages, captures then metadata */
-	for (i = 0; i < PISPBE_NUM_NODES; i++) {
+	for (unsigned int i = 0; i < PISPBE_NUM_NODES; i++) {
 		unsigned int bayer_en =
-			config_tiles_buffer->config.global.bayer_enables;
+			job->config->config.global.bayer_enables;
 		unsigned int rgb_en =
-			config_tiles_buffer->config.global.rgb_enables;
+			job->config->config.global.rgb_enables;
 		bool ignore_buffers = false;
 
 		/* Config node is handled outside the loop above. */
@@ -558,7 +498,7 @@ static int pispbe_schedule_internal(stru
 			continue;
 
 		buf[i] = NULL;
-		if (!(node_group->streaming_map & BIT(i)))
+		if (!(pispbe->streaming_map & BIT(i)))
 			continue;
 
 		if ((!(rgb_en & PISP_BE_RGB_ENABLE_OUTPUT0) &&
@@ -578,119 +518,103 @@ static int pispbe_schedule_internal(stru
 			 * global enables aren't set for these blocks. If a
 			 * buffer has been provided, we dequeue it back to the
 			 * user with the other in-use buffers.
-			 *
 			 */
 			ignore_buffers = true;
 		}
 
-		node = &node_group->node[i];
+		node = &pispbe->node[i];
 
-		spin_lock_irqsave(&node->ready_lock, flags1);
+		/* Pull a buffer from each V4L2 queue to form the queued job */
+		spin_lock_irqsave(&node->ready_lock, flags);
 		buf[i] = list_first_entry_or_null(&node->ready_queue,
 						  struct pispbe_buffer,
 						  ready_list);
-		spin_unlock_irqrestore(&node->ready_lock, flags1);
-		if (!buf[i] && !ignore_buffers) {
-			dev_dbg(pispbe->dev, "Nothing to do\n");
-			return 0;
-		}
-	}
-
-	/* Pull a buffer from each V4L2 queue to form the queued job */
-	for (i = 0; i < PISPBE_NUM_NODES; i++) {
 		if (buf[i]) {
-			node = &node_group->node[i];
-
-			spin_lock_irqsave(&node->ready_lock, flags1);
 			list_del(&buf[i]->ready_list);
-			spin_unlock_irqrestore(&node->ready_lock,
-					       flags1);
+			pispbe->queued_job.buf[i] = buf[i];
 		}
-		pispbe->queued_job.buf[i] = buf[i];
+		spin_unlock_irqrestore(&node->ready_lock, flags);
+
+		if (!buf[i] && !ignore_buffers)
+			goto err_return_buffers;
 	}
 
-	pispbe->queued_job.node_group = node_group;
-	pispbe->hw_busy = 1;
-	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
-
-	/*
-	 * We can kick the job off without the hw_lock, as this can
-	 * never run again until hw_busy is cleared, which will happen
-	 * only when the following job has been queued.
-	 */
-	dev_dbg(pispbe->dev, "Have buffers - starting hardware\n");
+	pispbe->queued_job.valid = true;
 
 	/* Convert buffers to DMA addresses for the hardware */
-	fixup_addrs_enables(hw_dma_addrs, hw_enables,
-			    config_tiles_buffer, buf, node_group);
-	/*
-	 * This could be a spot to fill in the
-	 * buf[i]->vb.vb2_buf.planes[j].bytesused fields?
-	 */
-	i = config_tiles_buffer->num_tiles;
-	if (i <= 0 || i > PISP_BACK_END_NUM_TILES ||
-	    !((hw_enables[0] | hw_enables[1]) &
-	      PISP_BE_BAYER_ENABLE_INPUT)) {
-		/*
-		 * Bad job. We can't let it proceed as it could lock up
-		 * the hardware, or worse!
-		 *
-		 * XXX How to deal with this most cleanly? For now, just
-		 * force num_tiles to 0, which causes the H/W to do
-		 * something bizarre but survivable. It increments
-		 * (started,done) counters by more than 1, but we seem
-		 * to survive...
-		 */
-		dev_err(pispbe->dev, "PROBLEM: Bad job");
-		i = 0;
-	}
-	hw_queue_job(pispbe, hw_dma_addrs, hw_enables,
-		     &config_tiles_buffer->config, tiles, i);
+	pispbe_xlate_addrs(pispbe, job, buf);
 
-	return 1;
-}
+	return 0;
 
-/* Try and schedule a job for just a single node group. */
-static void pispbe_schedule_one(struct pispbe_node_group *node_group)
-{
-	struct pispbe_dev *pispbe = node_group->pispbe;
-	unsigned long flags;
-	int ret;
+err_return_buffers:
+	for (unsigned int i = 0; i < PISPBE_NUM_NODES; i++) {
+		struct pispbe_node *n =  &pispbe->node[i];
 
-	spin_lock_irqsave(&pispbe->hw_lock, flags);
-	if (pispbe->hw_busy) {
-		spin_unlock_irqrestore(&pispbe->hw_lock, flags);
-		return;
+		if (!buf[i])
+			continue;
+
+		/* Return the buffer to the ready_list queue */
+		spin_lock_irqsave(&n->ready_lock, flags);
+		list_add(&buf[i]->ready_list, &n->ready_queue);
+		spin_unlock_irqrestore(&n->ready_lock, flags);
 	}
 
-	/* A non-zero return means the lock was released. */
-	ret = pispbe_schedule_internal(node_group, flags);
-	if (!ret)
-		spin_unlock_irqrestore(&pispbe->hw_lock, flags);
+	memset(&pispbe->queued_job, 0, sizeof(pispbe->queued_job));
+
+	return -ENODEV;
 }
 
-/* Try and schedule a job for any of the node groups. */
-static void pispbe_schedule_any(struct pispbe_dev *pispbe, int clear_hw_busy)
+static void pispbe_schedule(struct pispbe_dev *pispbe, bool clear_hw_busy)
 {
+	struct pispbe_job_descriptor job;
 	unsigned long flags;
+	int ret;
 
 	spin_lock_irqsave(&pispbe->hw_lock, flags);
 
 	if (clear_hw_busy)
-		pispbe->hw_busy = 0;
-	if (pispbe->hw_busy == 0) {
-		unsigned int i;
+		pispbe->hw_busy = false;
 
-		for (i = 0; i < PISPBE_NUM_NODE_GROUPS; i++) {
-			/*
-			 * A non-zero return from pispbe_schedule_internal means
-			 * the lock was released.
-			 */
-			if (pispbe_schedule_internal(&pispbe->node_group[i],
-						     flags))
-				return;
-		}
+	if (pispbe->hw_busy)
+		goto unlock_and_return;
+
+	ret = pispbe_prepare_job(pispbe, &job);
+	if (ret)
+		goto unlock_and_return;
+
+	/*
+	 * We can kick the job off without the hw_lock, as this can
+	 * never run again until hw_busy is cleared, which will happen
+	 * only when the following job has been queued and an interrupt
+	 * is rised.
+	 */
+	pispbe->hw_busy = true;
+	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
+
+	if (job.config->num_tiles <= 0 ||
+	    job.config->num_tiles > PISP_BACK_END_NUM_TILES ||
+	    !((job.hw_enables.bayer_enables | job.hw_enables.rgb_enables) &
+	      PISP_BE_BAYER_ENABLE_INPUT)) {
+		/*
+		 * Bad job. We can't let it proceed as it could lock up
+		 * the hardware, or worse!
+		 *
+		 * For now, just force num_tiles to 0, which causes the
+		 * H/W to do something bizarre but survivable. It
+		 * increments (started,done) counters by more than 1,
+		 * but we seem to survive...
+		 */
+		dev_dbg(pispbe->dev, "Bad job: invalid number of tiles: %u\n",
+			job.config->num_tiles);
+		job.config->num_tiles = 0;
 	}
+
+	pispbe_queue_job(pispbe, &job);
+
+	return;
+
+unlock_and_return:
+	/* No job has been queued, just release the lock and return. */
 	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
 }
 
@@ -699,62 +623,53 @@ static void pispbe_isr_jobdone(struct pi
 {
 	struct pispbe_buffer **buf = job->buf;
 	u64 ts = ktime_get_ns();
-	int i;
 
-	for (i = 0; i < PISPBE_NUM_NODES; i++) {
+	for (unsigned int i = 0; i < PISPBE_NUM_NODES; i++) {
 		if (buf[i]) {
 			buf[i]->vb.vb2_buf.timestamp = ts;
-			buf[i]->vb.sequence = job->node_group->sequence;
+			buf[i]->vb.sequence = pispbe->sequence;
 			vb2_buffer_done(&buf[i]->vb.vb2_buf,
 					VB2_BUF_STATE_DONE);
 		}
 	}
 
-	job->node_group->sequence++;
+	pispbe->sequence++;
 }
 
 static irqreturn_t pispbe_isr(int irq, void *dev)
 {
 	struct pispbe_dev *pispbe = (struct pispbe_dev *)dev;
+	bool can_queue_another = false;
 	u8 started, done;
-	int can_queue_another = 0;
 	u32 u;
 
-	u = read_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET);
+	u = pispbe_rd(pispbe, PISP_BE_INTERRUPT_STATUS_REG);
 	if (u == 0)
 		return IRQ_NONE;
 
-	write_reg(pispbe, PISP_BE_INTERRUPT_STATUS_OFFSET, u);
-	dev_dbg(pispbe->dev, "Hardware interrupt\n");
-	u = read_reg(pispbe, PISP_BE_BATCH_STATUS_OFFSET);
+	pispbe_wr(pispbe, PISP_BE_INTERRUPT_STATUS_REG, u);
+	u = pispbe_rd(pispbe, PISP_BE_BATCH_STATUS_REG);
 	done = (uint8_t)u;
 	started = (uint8_t)(u >> 8);
-	dev_dbg(pispbe->dev,
-		"H/W started %d done %d, previously started %d done %d\n",
-		(int)started, (int)done, (int)pispbe->started,
-		(int)pispbe->done);
 
 	/*
 	 * Be aware that done can go up by 2 and started by 1 when: a job that
 	 * we previously saw "start" now finishes, and we then queued a new job
 	 * which we see both start and finish "simultaneously".
 	 */
-	if (pispbe->running_job.node_group && pispbe->done != done) {
+	if (pispbe->running_job.valid && pispbe->done != done) {
 		pispbe_isr_jobdone(pispbe, &pispbe->running_job);
 		memset(&pispbe->running_job, 0, sizeof(pispbe->running_job));
 		pispbe->done++;
-		dev_dbg(pispbe->dev, "Job done (1)\n");
 	}
 
 	if (pispbe->started != started) {
 		pispbe->started++;
 		can_queue_another = 1;
-		dev_dbg(pispbe->dev, "Job started\n");
 
-		if (pispbe->done != done && pispbe->queued_job.node_group) {
+		if (pispbe->done != done && pispbe->queued_job.valid) {
 			pispbe_isr_jobdone(pispbe, &pispbe->queued_job);
 			pispbe->done++;
-			dev_dbg(pispbe->dev, "Job done (2)\n");
 		} else {
 			pispbe->running_job = pispbe->queued_job;
 		}
@@ -763,74 +678,81 @@ static irqreturn_t pispbe_isr(int irq, v
 	}
 
 	if (pispbe->done != done || pispbe->started != started) {
-		dev_err(pispbe->dev, "PROBLEM: counters not matching!\n");
+		dev_dbg(pispbe->dev,
+			"Job counters not matching: done = %u, expected %u - started = %u, expected %u\n",
+			pispbe->done, done, pispbe->started, started);
 		pispbe->started = started;
 		pispbe->done = done;
 	}
 
 	/* check if there's more to do before going to sleep */
-	pispbe_schedule_any(pispbe, can_queue_another);
+	pispbe_schedule(pispbe, can_queue_another);
 
 	return IRQ_HANDLED;
 }
 
-static int pisp_be_validate_config(struct pispbe_node_group *node_group,
+static int pisp_be_validate_config(struct pispbe_dev *pispbe,
 				   struct pisp_be_tiles_config *config)
 {
 	u32 bayer_enables = config->config.global.bayer_enables;
 	u32 rgb_enables = config->config.global.rgb_enables;
-	struct device *dev = node_group->pispbe->dev;
+	struct device *dev = pispbe->dev;
 	struct v4l2_format *fmt;
-	unsigned int bpl, size, i, j;
+	unsigned int bpl, size;
 
 	if (!(bayer_enables & PISP_BE_BAYER_ENABLE_INPUT) ==
 	    !(rgb_enables & PISP_BE_RGB_ENABLE_INPUT)) {
-		dev_err(dev, "%s: Not one input enabled\n", __func__);
+		dev_dbg(dev, "%s: Not one input enabled\n", __func__);
 		return -EIO;
 	}
 
 	/* Ensure output config strides and buffer sizes match the V4L2 formats. */
-	fmt = &node_group->node[TDN_OUTPUT_NODE].format;
+	fmt = &pispbe->node[TDN_OUTPUT_NODE].format;
 	if (bayer_enables & PISP_BE_BAYER_ENABLE_TDN_OUTPUT) {
 		bpl = config->config.tdn_output_format.stride;
 		size = bpl * config->config.tdn_output_format.height;
+
 		if (fmt->fmt.pix_mp.plane_fmt[0].bytesperline < bpl) {
-			dev_err(dev, "%s: bpl mismatch on tdn_output\n",
+			dev_dbg(dev, "%s: bpl mismatch on tdn_output\n",
 				__func__);
 			return -EINVAL;
 		}
+
 		if (fmt->fmt.pix_mp.plane_fmt[0].sizeimage < size) {
-			dev_err(dev, "%s: size mismatch on tdn_output\n",
+			dev_dbg(dev, "%s: size mismatch on tdn_output\n",
 				__func__);
 			return -EINVAL;
 		}
 	}
 
-	fmt = &node_group->node[STITCH_OUTPUT_NODE].format;
+	fmt = &pispbe->node[STITCH_OUTPUT_NODE].format;
 	if (bayer_enables & PISP_BE_BAYER_ENABLE_STITCH_OUTPUT) {
 		bpl = config->config.stitch_output_format.stride;
 		size = bpl * config->config.stitch_output_format.height;
+
 		if (fmt->fmt.pix_mp.plane_fmt[0].bytesperline < bpl) {
-			dev_err(dev, "%s: bpl mismatch on stitch_output\n",
+			dev_dbg(dev, "%s: bpl mismatch on stitch_output\n",
 				__func__);
 			return -EINVAL;
 		}
+
 		if (fmt->fmt.pix_mp.plane_fmt[0].sizeimage < size) {
-			dev_err(dev, "%s: size mismatch on stitch_output\n",
+			dev_dbg(dev, "%s: size mismatch on stitch_output\n",
 				__func__);
 			return -EINVAL;
 		}
 	}
 
-	for (j = 0; j < PISP_BACK_END_NUM_OUTPUTS; j++) {
+	for (unsigned int j = 0; j < PISP_BACK_END_NUM_OUTPUTS; j++) {
 		if (!(rgb_enables & PISP_BE_RGB_ENABLE_OUTPUT(j)))
 			continue;
+
 		if (config->config.output_format[j].image.format &
 		    PISP_IMAGE_FORMAT_WALLPAPER_ROLL)
 			continue; /* TODO: Size checks for wallpaper formats */
 
-		fmt = &node_group->node[OUTPUT0_NODE + j].format;
-		for (i = 0; i < fmt->fmt.pix_mp.num_planes; i++) {
+		fmt = &pispbe->node[OUTPUT0_NODE + j].format;
+		for (unsigned int i = 0; i < fmt->fmt.pix_mp.num_planes; i++) {
 			bpl = !i ? config->config.output_format[j].image.stride
 			    : config->config.output_format[j].image.stride2;
 			size = bpl * config->config.output_format[j].image.height;
@@ -838,13 +760,15 @@ static int pisp_be_validate_config(struc
 			if (config->config.output_format[j].image.format &
 						PISP_IMAGE_FORMAT_SAMPLING_420)
 				size >>= 1;
+
 			if (fmt->fmt.pix_mp.plane_fmt[i].bytesperline < bpl) {
-				dev_err(dev, "%s: bpl mismatch on output %d\n",
+				dev_dbg(dev, "%s: bpl mismatch on output %d\n",
 					__func__, j);
 				return -EINVAL;
 			}
+
 			if (fmt->fmt.pix_mp.plane_fmt[i].sizeimage < size) {
-				dev_err(dev, "%s: size mismatch on output\n",
+				dev_dbg(dev, "%s: size mismatch on output\n",
 					__func__);
 				return -EINVAL;
 			}
@@ -859,32 +783,32 @@ static int pispbe_node_queue_setup(struc
 				   struct device *alloc_devs[])
 {
 	struct pispbe_node *node = vb2_get_drv_priv(q);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
+	unsigned int num_planes = NODE_IS_MPLANE(node) ?
+				  node->format.fmt.pix_mp.num_planes : 1;
 
-	*nplanes = 1;
-	if (NODE_IS_MPLANE(node)) {
-		unsigned int i;
-
-		*nplanes = node->format.fmt.pix_mp.num_planes;
-		for (i = 0; i < *nplanes; i++) {
-			unsigned int size =
-				node->format.fmt.pix_mp.plane_fmt[i].sizeimage;
-			if (sizes[i] && sizes[i] < size) {
-				dev_err(pispbe->dev, "%s: size %u < %u\n",
-					__func__, sizes[i], size);
+	if (*nplanes) {
+		if (*nplanes != num_planes)
+			return -EINVAL;
+
+		for (unsigned int i = 0; i < *nplanes; i++) {
+			unsigned int size = NODE_IS_MPLANE(node) ?
+				node->format.fmt.pix_mp.plane_fmt[i].sizeimage :
+				node->format.fmt.meta.buffersize;
+
+			if (sizes[i] < size)
 				return -EINVAL;
-			}
-			sizes[i] = size;
 		}
-	} else if (NODE_IS_META(node)) {
-		sizes[0] = node->format.fmt.meta.buffersize;
-		/*
-		 * Limit the config node buffer count to the number of internal
-		 * buffers allocated.
-		 */
-		if (node->id == CONFIG_NODE)
-			*nbuffers = min_t(unsigned int, *nbuffers,
-					  PISP_BE_NUM_CONFIG_BUFFERS);
+
+		return 0;
+	}
+
+	*nplanes = num_planes;
+	for (unsigned int i = 0; i < *nplanes; i++) {
+		unsigned int size = NODE_IS_MPLANE(node) ?
+				node->format.fmt.pix_mp.plane_fmt[i].sizeimage :
+				node->format.fmt.meta.buffersize;
+		sizes[i] = size;
 	}
 
 	dev_dbg(pispbe->dev,
@@ -897,19 +821,17 @@ static int pispbe_node_queue_setup(struc
 static int pispbe_node_buffer_prepare(struct vb2_buffer *vb)
 {
 	struct pispbe_node *node = vb2_get_drv_priv(vb->vb2_queue);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	unsigned long size = 0;
+	struct pispbe_dev *pispbe = node->pispbe;
 	unsigned int num_planes = NODE_IS_MPLANE(node) ?
-					node->format.fmt.pix_mp.num_planes : 1;
-	unsigned int i;
+				  node->format.fmt.pix_mp.num_planes : 1;
 
-	for (i = 0; i < num_planes; i++) {
-		size = NODE_IS_MPLANE(node)
-			? node->format.fmt.pix_mp.plane_fmt[i].sizeimage
-			: node->format.fmt.meta.buffersize;
+	for (unsigned int i = 0; i < num_planes; i++) {
+		unsigned long size = NODE_IS_MPLANE(node) ?
+				node->format.fmt.pix_mp.plane_fmt[i].sizeimage :
+				node->format.fmt.meta.buffersize;
 
 		if (vb2_plane_size(vb, i) < size) {
-			dev_err(pispbe->dev,
+			dev_dbg(pispbe->dev,
 				"data will not fit into plane %d (%lu < %lu)\n",
 				i, vb2_plane_size(vb, i), size);
 			return -EINVAL;
@@ -919,11 +841,12 @@ static int pispbe_node_buffer_prepare(st
 	}
 
 	if (node->id == CONFIG_NODE) {
-		void *dst = &node->node_group->config[vb->index];
+		void *dst = &node->pispbe->config[vb->index];
 		void *src = vb2_plane_vaddr(vb, 0);
 
 		memcpy(dst, src, sizeof(struct pisp_be_tiles_config));
-		return pisp_be_validate_config(node->node_group, dst);
+
+		return pisp_be_validate_config(pispbe, dst);
 	}
 
 	return 0;
@@ -936,8 +859,7 @@ static void pispbe_node_buffer_queue(str
 	struct pispbe_buffer *buffer =
 		container_of(vbuf, struct pispbe_buffer, vb);
 	struct pispbe_node *node = vb2_get_drv_priv(buf->vb2_queue);
-	struct pispbe_node_group *node_group = node->node_group;
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 	unsigned long flags;
 
 	dev_dbg(pispbe->dev, "%s: for node %s\n", __func__, NODE_NAME(node));
@@ -947,44 +869,53 @@ static void pispbe_node_buffer_queue(str
 
 	/*
 	 * Every time we add a buffer, check if there's now some work for the hw
-	 * to do, but only for this client.
+	 * to do.
 	 */
-	pispbe_schedule_one(node_group);
+	pispbe_schedule(pispbe, false);
 }
 
 static int pispbe_node_start_streaming(struct vb2_queue *q, unsigned int count)
 {
-	unsigned long flags;
 	struct pispbe_node *node = vb2_get_drv_priv(q);
-	struct pispbe_node_group *node_group = node->node_group;
-	struct pispbe_dev *pispbe = node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
+	struct pispbe_buffer *buf, *tmp;
+	unsigned long flags;
 	int ret;
 
 	ret = pm_runtime_resume_and_get(pispbe->dev);
 	if (ret < 0)
-		return ret;
+		goto err_return_buffers;
 
 	spin_lock_irqsave(&pispbe->hw_lock, flags);
-	node->node_group->streaming_map |=  BIT(node->id);
-	node->node_group->sequence = 0;
+	node->pispbe->streaming_map |=  BIT(node->id);
+	node->pispbe->sequence = 0;
 	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
 
 	dev_dbg(pispbe->dev, "%s: for node %s (count %u)\n",
 		__func__, NODE_NAME(node), count);
-	dev_dbg(pispbe->dev, "Nodes streaming for this group now 0x%x\n",
-		node->node_group->streaming_map);
+	dev_dbg(pispbe->dev, "Nodes streaming now 0x%x\n",
+		node->pispbe->streaming_map);
 
 	/* Maybe we're ready to run. */
-	pispbe_schedule_one(node_group);
+	pispbe_schedule(pispbe, false);
 
 	return 0;
+
+err_return_buffers:
+	spin_lock_irqsave(&pispbe->hw_lock, flags);
+	list_for_each_entry_safe(buf, tmp, &node->ready_queue, ready_list) {
+		list_del(&buf->ready_list);
+		vb2_buffer_done(&buf->vb.vb2_buf, VB2_BUF_STATE_QUEUED);
+	}
+	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
+
+	return ret;
 }
 
 static void pispbe_node_stop_streaming(struct vb2_queue *q)
 {
 	struct pispbe_node *node = vb2_get_drv_priv(q);
-	struct pispbe_node_group *node_group = node->node_group;
-	struct pispbe_dev *pispbe = node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 	struct pispbe_buffer *buf;
 	unsigned long flags;
 
@@ -994,7 +925,8 @@ static void pispbe_node_stop_streaming(s
 	 * partial set of buffers was queued and cannot be run. For now, just
 	 * cancel all buffers stuck in the "ready queue", then wait for any
 	 * running job.
-	 * XXX This may return buffers out of order.
+	 *
+	 * This may return buffers out of order.
 	 */
 	dev_dbg(pispbe->dev, "%s: for node %s\n", __func__, NODE_NAME(node));
 	spin_lock_irqsave(&pispbe->hw_lock, flags);
@@ -1016,14 +948,14 @@ static void pispbe_node_stop_streaming(s
 	vb2_wait_for_all_buffers(&node->queue);
 
 	spin_lock_irqsave(&pispbe->hw_lock, flags);
-	node_group->streaming_map &= ~BIT(node->id);
+	pispbe->streaming_map &= ~BIT(node->id);
 	spin_unlock_irqrestore(&pispbe->hw_lock, flags);
 
 	pm_runtime_mark_last_busy(pispbe->dev);
 	pm_runtime_put_autosuspend(pispbe->dev);
 
-	dev_dbg(pispbe->dev, "Nodes streaming for this group now 0x%x\n",
-		node_group->streaming_map);
+	dev_dbg(pispbe->dev, "Nodes streaming now 0x%x\n",
+		pispbe->streaming_map);
 }
 
 static const struct vb2_ops pispbe_node_queue_ops = {
@@ -1047,22 +979,15 @@ static int pispbe_node_querycap(struct f
 				struct v4l2_capability *cap)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	strscpy(cap->driver, PISPBE_NAME, sizeof(cap->driver));
 	strscpy(cap->card, PISPBE_NAME, sizeof(cap->card));
-	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s",
-		 dev_name(pispbe->dev));
-
-	cap->capabilities = V4L2_CAP_VIDEO_CAPTURE_MPLANE |
-			    V4L2_CAP_VIDEO_OUTPUT_MPLANE |
-			    V4L2_CAP_STREAMING | V4L2_CAP_DEVICE_CAPS |
-			    V4L2_CAP_META_OUTPUT | V4L2_CAP_META_CAPTURE;
-	cap->device_caps = node->vfd.device_caps;
 
 	dev_dbg(pispbe->dev, "Caps for node %s: %x and %x (dev %x)\n",
 		NODE_NAME(node), cap->capabilities, cap->device_caps,
 		node->vfd.device_caps);
+
 	return 0;
 }
 
@@ -1070,17 +995,19 @@ static int pispbe_node_g_fmt_vid_cap(str
 				     struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (!NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot get capture fmt for output node %s\n",
 			NODE_NAME(node));
 		return -EINVAL;
 	}
+
 	*f = node->format;
 	dev_dbg(pispbe->dev, "Get capture format for node %s\n",
 		NODE_NAME(node));
+
 	return 0;
 }
 
@@ -1088,17 +1015,19 @@ static int pispbe_node_g_fmt_vid_out(str
 				     struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot get capture fmt for output node %s\n",
 			 NODE_NAME(node));
 		return -EINVAL;
 	}
+
 	*f = node->format;
 	dev_dbg(pispbe->dev, "Get output format for node %s\n",
 		NODE_NAME(node));
+
 	return 0;
 }
 
@@ -1106,98 +1035,42 @@ static int pispbe_node_g_fmt_meta_out(st
 				      struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (!NODE_IS_META(node) || NODE_IS_CAPTURE(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot get capture fmt for meta output node %s\n",
 			NODE_NAME(node));
 		return -EINVAL;
 	}
-	*f = node->format;
-	dev_dbg(pispbe->dev, "Get output format for meta node %s\n",
-		NODE_NAME(node));
-	return 0;
-}
 
-static int pispbe_node_g_fmt_meta_cap(struct file *file, void *priv,
-				      struct v4l2_format *f)
-{
-	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-
-	if (!NODE_IS_META(node) || NODE_IS_OUTPUT(node)) {
-		dev_err(pispbe->dev,
-			"Cannot get capture fmt for meta output node %s\n",
-			NODE_NAME(node));
-		return -EINVAL;
-	}
 	*f = node->format;
 	dev_dbg(pispbe->dev, "Get output format for meta node %s\n",
 		NODE_NAME(node));
-	return 0;
-}
-
-static int verify_be_pix_format(const struct v4l2_format *f,
-				struct pispbe_node *node)
-{
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	unsigned int nplanes = f->fmt.pix_mp.num_planes;
-	unsigned int i;
-
-	if (f->fmt.pix_mp.width == 0 || f->fmt.pix_mp.height == 0) {
-		dev_err(pispbe->dev, "Details incorrect for output node %s\n",
-			NODE_NAME(node));
-		return -EINVAL;
-	}
-
-	if (nplanes == 0 || nplanes > MAX_PLANES) {
-		dev_err(pispbe->dev,
-			"Bad number of planes for output node %s, req =%d\n",
-			NODE_NAME(node), nplanes);
-		return -EINVAL;
-	}
-
-	for (i = 0; i < nplanes; i++) {
-		const struct v4l2_plane_pix_format *p;
-
-		p = &f->fmt.pix_mp.plane_fmt[i];
-		if (p->bytesperline == 0 || p->sizeimage == 0) {
-			dev_err(pispbe->dev,
-				"Invalid plane %d for output node %s\n",
-				i, NODE_NAME(node));
-			return -EINVAL;
-		}
-	}
 
 	return 0;
 }
 
-static const struct pisp_be_format *find_format(unsigned int fourcc)
+static const struct pisp_be_format *pispbe_find_fmt(unsigned int fourcc)
 {
-	const struct pisp_be_format *fmt;
-	unsigned int i;
-
-	for (i = 0; i < ARRAY_SIZE(supported_formats); i++) {
-		fmt = &supported_formats[i];
-		if (fmt->fourcc == fourcc)
-			return fmt;
+	for (unsigned int i = 0; i < ARRAY_SIZE(supported_formats); i++) {
+		if (supported_formats[i].fourcc == fourcc)
+			return &supported_formats[i];
 	}
 
 	return NULL;
 }
 
-static void set_plane_params(struct v4l2_format *f,
-			     const struct pisp_be_format *fmt)
+static void pispbe_set_plane_params(struct v4l2_format *f,
+				    const struct pisp_be_format *fmt)
 {
 	unsigned int nplanes = f->fmt.pix_mp.num_planes;
 	unsigned int total_plane_factor = 0;
-	unsigned int i;
 
-	for (i = 0; i < MAX_PLANES; i++)
+	for (unsigned int i = 0; i < PISPBE_MAX_PLANES; i++)
 		total_plane_factor += fmt->plane_factor[i];
 
-	for (i = 0; i < nplanes; i++) {
+	for (unsigned int i = 0; i < nplanes; i++) {
 		struct v4l2_plane_pix_format *p = &f->fmt.pix_mp.plane_fmt[i];
 		unsigned int bpl, plane_size;
 
@@ -1217,28 +1090,25 @@ static void set_plane_params(struct v4l2
 	}
 }
 
-static int try_format(struct v4l2_format *f, struct pispbe_node *node)
+static void pispbe_try_format(struct v4l2_format *f, struct pispbe_node *node)
 {
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
+	u32 pixfmt = f->fmt.pix_mp.pixelformat;
 	const struct pisp_be_format *fmt;
-	unsigned int i;
 	bool is_rgb;
-	u32 pixfmt = f->fmt.pix_mp.pixelformat;
 
 	dev_dbg(pispbe->dev,
-		"%s: [%s] req %ux%u " V4L2_FOURCC_CONV ", planes %d\n",
+		"%s: [%s] req %ux%u %p4cc, planes %d\n",
 		__func__, NODE_NAME(node), f->fmt.pix_mp.width,
-		f->fmt.pix_mp.height, V4L2_FOURCC_CONV_ARGS(pixfmt),
+		f->fmt.pix_mp.height, &pixfmt,
 		f->fmt.pix_mp.num_planes);
 
-	if (pixfmt == V4L2_PIX_FMT_RPI_BE)
-		return verify_be_pix_format(f, node);
-
-	fmt = find_format(pixfmt);
+	fmt = pispbe_find_fmt(pixfmt);
 	if (!fmt) {
-		dev_dbg(pispbe->dev, "%s: [%s] Format not found, defaulting to YUV420\n",
+		dev_dbg(pispbe->dev,
+			"%s: [%s] Format not found, defaulting to YUV420\n",
 			__func__, NODE_NAME(node));
-		fmt = find_format(V4L2_PIX_FMT_YUV420);
+		fmt = pispbe_find_fmt(V4L2_PIX_FMT_YUV420);
 	}
 
 	f->fmt.pix_mp.pixelformat = fmt->fourcc;
@@ -1254,7 +1124,8 @@ static int try_format(struct v4l2_format
 	 * not supported. This also catches the case when the "default"
 	 * colour space was requested (as that's never in the mask).
 	 */
-	if (!(V4L2_COLORSPACE_MASK(f->fmt.pix_mp.colorspace) & fmt->colorspace_mask))
+	if (!(V4L2_COLORSPACE_MASK(f->fmt.pix_mp.colorspace) &
+	    fmt->colorspace_mask))
 		f->fmt.pix_mp.colorspace = fmt->colorspace_default;
 
 	/* In all cases, we only support the defaults for these: */
@@ -1269,9 +1140,9 @@ static int try_format(struct v4l2_format
 					      f->fmt.pix_mp.ycbcr_enc);
 
 	/* Set plane size and bytes/line for each plane. */
-	set_plane_params(f, fmt);
+	pispbe_set_plane_params(f, fmt);
 
-	for (i = 0; i < f->fmt.pix_mp.num_planes; i++) {
+	for (unsigned int i = 0; i < f->fmt.pix_mp.num_planes; i++) {
 		dev_dbg(pispbe->dev,
 			"%s: [%s] calc plane %d, %ux%u, depth %u, bpl %u size %u\n",
 			__func__, NODE_NAME(node), i, f->fmt.pix_mp.width,
@@ -1279,27 +1150,22 @@ static int try_format(struct v4l2_format
 			f->fmt.pix_mp.plane_fmt[i].bytesperline,
 			f->fmt.pix_mp.plane_fmt[i].sizeimage);
 	}
-
-	return 0;
 }
 
 static int pispbe_node_try_fmt_vid_cap(struct file *file, void *priv,
 				       struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (!NODE_IS_CAPTURE(node) || NODE_IS_META(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot set capture fmt for output node %s\n",
 			NODE_NAME(node));
 		return -EINVAL;
 	}
 
-	ret = try_format(f, node);
-	if (ret < 0)
-		return ret;
+	pispbe_try_format(f, node);
 
 	return 0;
 }
@@ -1308,19 +1174,16 @@ static int pispbe_node_try_fmt_vid_out(s
 				       struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (!NODE_IS_OUTPUT(node) || NODE_IS_META(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot set capture fmt for output node %s\n",
 			NODE_NAME(node));
 		return -EINVAL;
 	}
 
-	ret = try_format(f, node);
-	if (ret < 0)
-		return ret;
+	pispbe_try_format(f, node);
 
 	return 0;
 }
@@ -1329,10 +1192,10 @@ static int pispbe_node_try_fmt_meta_out(
 					struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (!NODE_IS_META(node) || NODE_IS_CAPTURE(node)) {
-		dev_err(pispbe->dev,
+		dev_dbg(pispbe->dev,
 			"Cannot set capture fmt for meta output node %s\n",
 			NODE_NAME(node));
 		return -EINVAL;
@@ -1344,43 +1207,26 @@ static int pispbe_node_try_fmt_meta_out(
 	return 0;
 }
 
-static int pispbe_node_try_fmt_meta_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
-{
-	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-
-	if (!NODE_IS_META(node) || NODE_IS_OUTPUT(node)) {
-		dev_err(pispbe->dev,
-			"Cannot set capture fmt for meta output node %s\n",
-			NODE_NAME(node));
-		return -EINVAL;
-	}
-
-	f->fmt.meta.dataformat = V4L2_PIX_FMT_RPI_BE;
-	if (!f->fmt.meta.buffersize)
-		f->fmt.meta.buffersize = BIT(20);
-
-	return 0;
-}
-
 static int pispbe_node_s_fmt_vid_cap(struct file *file, void *priv,
 				     struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret = pispbe_node_try_fmt_vid_cap(file, priv, f);
+	struct pispbe_dev *pispbe = node->pispbe;
+	int ret;
 
+	ret = pispbe_node_try_fmt_vid_cap(file, priv, f);
 	if (ret < 0)
 		return ret;
 
+	if (vb2_is_busy(&node->queue))
+		return -EBUSY;
+
 	node->format = *f;
-	node->pisp_format = find_format(f->fmt.pix_mp.pixelformat);
+	node->pisp_format = pispbe_find_fmt(f->fmt.pix_mp.pixelformat);
+
+	dev_dbg(pispbe->dev, "Set capture format for node %s to %p4cc\n",
+		NODE_NAME(node), &f->fmt.pix_mp.pixelformat);
 
-	dev_dbg(pispbe->dev,
-		"Set capture format for node %s to " V4L2_FOURCC_CONV "\n",
-		NODE_NAME(node),
-		V4L2_FOURCC_CONV_ARGS(f->fmt.pix_mp.pixelformat));
 	return 0;
 }
 
@@ -1388,19 +1234,22 @@ static int pispbe_node_s_fmt_vid_out(str
 				     struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret = pispbe_node_try_fmt_vid_out(file, priv, f);
+	struct pispbe_dev *pispbe = node->pispbe;
+	int ret;
 
+	ret = pispbe_node_try_fmt_vid_out(file, priv, f);
 	if (ret < 0)
 		return ret;
 
+	if (vb2_is_busy(&node->queue))
+		return -EBUSY;
+
 	node->format = *f;
-	node->pisp_format = find_format(f->fmt.pix_mp.pixelformat);
+	node->pisp_format = pispbe_find_fmt(f->fmt.pix_mp.pixelformat);
+
+	dev_dbg(pispbe->dev, "Set output format for node %s to %p4cc\n",
+		NODE_NAME(node), &f->fmt.pix_mp.pixelformat);
 
-	dev_dbg(pispbe->dev,
-		"Set output format for node %s to " V4L2_FOURCC_CONV "\n",
-		NODE_NAME(node),
-		V4L2_FOURCC_CONV_ARGS(f->fmt.pix_mp.pixelformat));
 	return 0;
 }
 
@@ -1408,39 +1257,22 @@ static int pispbe_node_s_fmt_meta_out(st
 				      struct v4l2_format *f)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret = pispbe_node_try_fmt_meta_out(file, priv, f);
+	struct pispbe_dev *pispbe = node->pispbe;
+	int ret;
 
+	ret = pispbe_node_try_fmt_meta_out(file, priv, f);
 	if (ret < 0)
 		return ret;
 
+	if (vb2_is_busy(&node->queue))
+		return -EBUSY;
+
 	node->format = *f;
 	node->pisp_format = &meta_out_supported_formats[0];
 
-	dev_dbg(pispbe->dev,
-		"Set output format for meta node %s to " V4L2_FOURCC_CONV "\n",
-		NODE_NAME(node),
-		V4L2_FOURCC_CONV_ARGS(f->fmt.meta.dataformat));
-	return 0;
-}
-
-static int pispbe_node_s_fmt_meta_cap(struct file *file, void *priv,
-				      struct v4l2_format *f)
-{
-	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-	int ret = pispbe_node_try_fmt_meta_cap(file, priv, f);
-
-	if (ret < 0)
-		return ret;
-
-	node->format = *f;
-	node->pisp_format = find_format(f->fmt.meta.dataformat);
+	dev_dbg(pispbe->dev, "Set output format for meta node %s to %p4cc\n",
+		NODE_NAME(node), &f->fmt.meta.dataformat);
 
-	dev_dbg(pispbe->dev,
-		"Set capture format for meta node %s to " V4L2_FOURCC_CONV "\n",
-		NODE_NAME(node),
-		V4L2_FOURCC_CONV_ARGS(f->fmt.meta.dataformat));
 	return 0;
 }
 
@@ -1456,10 +1288,7 @@ static int pispbe_node_enum_fmt(struct f
 		if (f->index)
 			return -EINVAL;
 
-		if (NODE_IS_OUTPUT(node))
-			f->pixelformat = V4L2_META_FMT_RPI_BE_CFG;
-		else
-			f->pixelformat = V4L2_PIX_FMT_RPI_BE;
+		f->pixelformat = V4L2_META_FMT_RPI_BE_CFG;
 		f->flags = 0;
 		return 0;
 	}
@@ -1477,13 +1306,13 @@ static int pispbe_enum_framesizes(struct
 				  struct v4l2_frmsizeenum *fsize)
 {
 	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
+	struct pispbe_dev *pispbe = node->pispbe;
 
 	if (NODE_IS_META(node) || fsize->index)
 		return -EINVAL;
 
-	if (!find_format(fsize->pixel_format)) {
-		dev_err(pispbe->dev, "Invalid pixel code: %x\n",
+	if (!pispbe_find_fmt(fsize->pixel_format)) {
+		dev_dbg(pispbe->dev, "Invalid pixel code: %x\n",
 			fsize->pixel_format);
 		return -EINVAL;
 	}
@@ -1500,49 +1329,19 @@ static int pispbe_enum_framesizes(struct
 	return 0;
 }
 
-static int pispbe_node_streamon(struct file *file, void *priv,
-				enum v4l2_buf_type type)
-{
-	struct pispbe_node *node = video_drvdata(file);
-	struct pispbe_dev *pispbe = node->node_group->pispbe;
-
-	/* Do we need a node->stream_lock mutex? */
-
-	dev_dbg(pispbe->dev, "Stream on for node %s\n", NODE_NAME(node));
-
-	/* Do we care about the type? Each node has only one queue. */
-
-	INIT_LIST_HEAD(&node->ready_queue);
-
-	/* locking should be handled by the queue->lock? */
-	return vb2_streamon(&node->queue, type);
-}
-
-static int pispbe_node_streamoff(struct file *file, void *priv,
-				 enum v4l2_buf_type type)
-{
-	struct pispbe_node *node = video_drvdata(file);
-
-	return vb2_streamoff(&node->queue, type);
-}
-
 static const struct v4l2_ioctl_ops pispbe_node_ioctl_ops = {
 	.vidioc_querycap = pispbe_node_querycap,
 	.vidioc_g_fmt_vid_cap_mplane = pispbe_node_g_fmt_vid_cap,
 	.vidioc_g_fmt_vid_out_mplane = pispbe_node_g_fmt_vid_out,
 	.vidioc_g_fmt_meta_out = pispbe_node_g_fmt_meta_out,
-	.vidioc_g_fmt_meta_cap = pispbe_node_g_fmt_meta_cap,
 	.vidioc_try_fmt_vid_cap_mplane = pispbe_node_try_fmt_vid_cap,
 	.vidioc_try_fmt_vid_out_mplane = pispbe_node_try_fmt_vid_out,
 	.vidioc_try_fmt_meta_out = pispbe_node_try_fmt_meta_out,
-	.vidioc_try_fmt_meta_cap = pispbe_node_try_fmt_meta_cap,
 	.vidioc_s_fmt_vid_cap_mplane = pispbe_node_s_fmt_vid_cap,
 	.vidioc_s_fmt_vid_out_mplane = pispbe_node_s_fmt_vid_out,
 	.vidioc_s_fmt_meta_out = pispbe_node_s_fmt_meta_out,
-	.vidioc_s_fmt_meta_cap = pispbe_node_s_fmt_meta_cap,
 	.vidioc_enum_fmt_vid_cap = pispbe_node_enum_fmt,
 	.vidioc_enum_fmt_vid_out = pispbe_node_enum_fmt,
-	.vidioc_enum_fmt_meta_cap = pispbe_node_enum_fmt,
 	.vidioc_enum_fmt_meta_out = pispbe_node_enum_fmt,
 	.vidioc_enum_framesizes = pispbe_enum_framesizes,
 	.vidioc_create_bufs = vb2_ioctl_create_bufs,
@@ -1552,8 +1351,8 @@ static const struct v4l2_ioctl_ops pispb
 	.vidioc_dqbuf = vb2_ioctl_dqbuf,
 	.vidioc_expbuf = vb2_ioctl_expbuf,
 	.vidioc_reqbufs = vb2_ioctl_reqbufs,
-	.vidioc_streamon = pispbe_node_streamon,
-	.vidioc_streamoff = pispbe_node_streamoff,
+	.vidioc_streamon = vb2_ioctl_streamon,
+	.vidioc_streamoff = vb2_ioctl_streamoff,
 };
 
 static const struct video_device pispbe_videodev = {
@@ -1565,7 +1364,7 @@ static const struct video_device pispbe_
 	.release = video_device_release_empty,
 };
 
-static void node_set_default_format(struct pispbe_node *node)
+static void pispbe_node_def_fmt(struct pispbe_node *node)
 {
 	if (NODE_IS_META(node) && NODE_IS_OUTPUT(node)) {
 		/* Config node */
@@ -1574,44 +1373,35 @@ static void node_set_default_format(stru
 		f->fmt.meta.dataformat = V4L2_META_FMT_RPI_BE_CFG;
 		f->fmt.meta.buffersize = sizeof(struct pisp_be_tiles_config);
 		f->type = node->buf_type;
-	} else if (NODE_IS_META(node) && NODE_IS_CAPTURE(node)) {
-		/* HOG output node */
-		struct v4l2_format *f = &node->format;
-
-		f->fmt.meta.dataformat = V4L2_PIX_FMT_RPI_BE;
-		f->fmt.meta.buffersize = BIT(20);
-		f->type = node->buf_type;
 	} else {
-		struct v4l2_format f = {0};
-
-		f.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420;
-		f.fmt.pix_mp.width = 1920;
-		f.fmt.pix_mp.height = 1080;
-		f.type = node->buf_type;
-		try_format(&f, node);
+		struct v4l2_format f = {
+			.fmt.pix_mp.pixelformat = V4L2_PIX_FMT_YUV420,
+			.fmt.pix_mp.width = 1920,
+			.fmt.pix_mp.height = 1080,
+			.type = node->buf_type,
+		};
+		pispbe_try_format(&f, node);
 		node->format = f;
 	}
 
-	node->pisp_format = find_format(node->format.fmt.pix_mp.pixelformat);
+	node->pisp_format = pispbe_find_fmt(node->format.fmt.pix_mp.pixelformat);
 }
 
 /*
  * Initialise a struct pispbe_node and register it as /dev/video<N>
  * to represent one of the PiSP Back End's input or output streams.
  */
-static int
-pispbe_init_node(struct pispbe_node_group *node_group, unsigned int id)
+static int pispbe_init_node(struct pispbe_dev *pispbe, unsigned int id)
 {
 	bool output = NODE_DESC_IS_OUTPUT(&node_desc[id]);
-	struct pispbe_node *node = &node_group->node[id];
-	struct pispbe_dev *pispbe = node_group->pispbe;
+	struct pispbe_node *node = &pispbe->node[id];
 	struct media_entity *entity = &node->vfd.entity;
 	struct video_device *vdev = &node->vfd;
 	struct vb2_queue *q = &node->queue;
 	int ret;
 
 	node->id = id;
-	node->node_group = node_group;
+	node->pispbe = pispbe;
 	node->buf_type = node_desc[id].buf_type;
 
 	mutex_init(&node->node_lock);
@@ -1620,7 +1410,7 @@ pispbe_init_node(struct pispbe_node_grou
 	spin_lock_init(&node->ready_lock);
 
 	node->format.type = node->buf_type;
-	node_set_default_format(node);
+	pispbe_node_def_fmt(node);
 
 	q->type = node->buf_type;
 	q->io_modes = VB2_MMAP | VB2_DMABUF;
@@ -1629,19 +1419,19 @@ pispbe_init_node(struct pispbe_node_grou
 	q->ops = &pispbe_node_queue_ops;
 	q->buf_struct_size = sizeof(struct pispbe_buffer);
 	q->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;
-	q->dev = node->node_group->pispbe->dev;
+	q->dev = pispbe->dev;
 	/* get V4L2 to handle node->queue locking */
 	q->lock = &node->queue_lock;
 
 	ret = vb2_queue_init(q);
 	if (ret < 0) {
 		dev_err(pispbe->dev, "vb2_queue_init failed\n");
-		return ret;
+		goto err_mutex_destroy;
 	}
 
 	*vdev = pispbe_videodev; /* default initialization */
 	strscpy(vdev->name, node_desc[id].ent_name, sizeof(vdev->name));
-	vdev->v4l2_dev = &node_group->v4l2_dev;
+	vdev->v4l2_dev = &pispbe->v4l2_dev;
 	vdev->vfl_dir = output ? VFL_DIR_TX : VFL_DIR_RX;
 	/* get V4L2 to serialise our ioctls */
 	vdev->lock = &node->node_lock;
@@ -1657,8 +1447,7 @@ pispbe_init_node(struct pispbe_node_grou
 		goto err_unregister_queue;
 	}
 
-	ret = video_register_device(vdev, VFL_TYPE_VIDEO,
-				    PISPBE_VIDEO_NODE_OFFSET);
+	ret = video_register_device(vdev, VFL_TYPE_VIDEO, -1);
 	if (ret) {
 		dev_err(pispbe->dev,
 			"Failed to register video %s device node\n",
@@ -1668,25 +1457,28 @@ pispbe_init_node(struct pispbe_node_grou
 	video_set_drvdata(vdev, node);
 
 	if (output)
-		ret = media_create_pad_link(entity, 0, &node_group->sd.entity,
+		ret = media_create_pad_link(entity, 0, &pispbe->sd.entity,
 					    id, MEDIA_LNK_FL_IMMUTABLE |
 					    MEDIA_LNK_FL_ENABLED);
 	else
-		ret = media_create_pad_link(&node_group->sd.entity, id, entity,
+		ret = media_create_pad_link(&pispbe->sd.entity, id, entity,
 					    0, MEDIA_LNK_FL_IMMUTABLE |
 					    MEDIA_LNK_FL_ENABLED);
 	if (ret)
 		goto err_unregister_video_dev;
 
-	dev_info(pispbe->dev,
-		 "%s device node registered as /dev/video%d\n",
-		 NODE_NAME(node), node->vfd.num);
+	dev_dbg(pispbe->dev, "%s device node registered as /dev/video%d\n",
+		NODE_NAME(node), node->vfd.num);
+
 	return 0;
 
 err_unregister_video_dev:
 	video_unregister_device(&node->vfd);
 err_unregister_queue:
 	vb2_queue_release(&node->queue);
+err_mutex_destroy:
+	mutex_destroy(&node->node_lock);
+	mutex_destroy(&node->queue_lock);
 	return ret;
 }
 
@@ -1698,11 +1490,9 @@ static const struct v4l2_subdev_ops pisp
 	.pad = &pispbe_pad_ops,
 };
 
-static int pispbe_init_subdev(struct pispbe_node_group *node_group)
+static int pispbe_init_subdev(struct pispbe_dev *pispbe)
 {
-	struct pispbe_dev *pispbe = node_group->pispbe;
-	struct v4l2_subdev *sd = &node_group->sd;
-	unsigned int i;
+	struct v4l2_subdev *sd = &pispbe->sd;
 	int ret;
 
 	v4l2_subdev_init(sd, &pispbe_sd_ops);
@@ -1711,17 +1501,17 @@ static int pispbe_init_subdev(struct pis
 	sd->dev = pispbe->dev;
 	strscpy(sd->name, PISPBE_NAME, sizeof(sd->name));
 
-	for (i = 0; i < PISPBE_NUM_NODES; i++)
-		node_group->pad[i].flags =
+	for (unsigned int i = 0; i < PISPBE_NUM_NODES; i++)
+		pispbe->pad[i].flags =
 			NODE_DESC_IS_OUTPUT(&node_desc[i]) ?
 			MEDIA_PAD_FL_SINK : MEDIA_PAD_FL_SOURCE;
 
 	ret = media_entity_pads_init(&sd->entity, PISPBE_NUM_NODES,
-				     node_group->pad);
+				     pispbe->pad);
 	if (ret)
 		goto error;
 
-	ret = v4l2_device_register_subdev(&node_group->v4l2_dev, sd);
+	ret = v4l2_device_register_subdev(&pispbe->v4l2_dev, sd);
 	if (ret)
 		goto error;
 
@@ -1732,45 +1522,36 @@ error:
 	return ret;
 }
 
-static int pispbe_init_group(struct pispbe_dev *pispbe, unsigned int id)
+static int pispbe_init_devices(struct pispbe_dev *pispbe)
 {
-	struct pispbe_node_group *node_group = &pispbe->node_group[id];
 	struct v4l2_device *v4l2_dev;
 	struct media_device *mdev;
-	unsigned int num_registered = 0;
+	unsigned int num_regist;
 	int ret;
 
-	node_group->id = id;
-	node_group->pispbe = pispbe;
-	node_group->streaming_map = 0;
-
-	dev_info(pispbe->dev, "Register nodes for group %u\n", id);
-
 	/* Register v4l2_device and media_device */
-	mdev = &node_group->mdev;
-	mdev->hw_revision = node_group->pispbe->hw_version;
-	mdev->dev = node_group->pispbe->dev;
+	mdev = &pispbe->mdev;
+	mdev->hw_revision = pispbe->hw_version;
+	mdev->dev = pispbe->dev;
 	strscpy(mdev->model, PISPBE_NAME, sizeof(mdev->model));
-	snprintf(mdev->bus_info, sizeof(mdev->bus_info),
-		 "platform:%s", dev_name(node_group->pispbe->dev));
 	media_device_init(mdev);
 
-	v4l2_dev = &node_group->v4l2_dev;
-	v4l2_dev->mdev = &node_group->mdev;
+	v4l2_dev = &pispbe->v4l2_dev;
+	v4l2_dev->mdev = &pispbe->mdev;
 	strscpy(v4l2_dev->name, PISPBE_NAME, sizeof(v4l2_dev->name));
 
-	ret = v4l2_device_register(pispbe->dev, &node_group->v4l2_dev);
+	ret = v4l2_device_register(pispbe->dev, v4l2_dev);
 	if (ret)
 		goto err_media_dev_cleanup;
 
 	/* Register the PISPBE subdevice. */
-	ret = pispbe_init_subdev(node_group);
+	ret = pispbe_init_subdev(pispbe);
 	if (ret)
 		goto err_unregister_v4l2;
 
 	/* Create device video nodes */
-	for (; num_registered < PISPBE_NUM_NODES; num_registered++) {
-		ret = pispbe_init_node(node_group, num_registered);
+	for (num_regist = 0; num_regist < PISPBE_NUM_NODES; num_regist++) {
+		ret = pispbe_init_node(pispbe, num_regist);
 		if (ret)
 			goto err_unregister_nodes;
 	}
@@ -1779,12 +1560,12 @@ static int pispbe_init_group(struct pisp
 	if (ret)
 		goto err_unregister_nodes;
 
-	node_group->config =
+	pispbe->config =
 		dma_alloc_coherent(pispbe->dev,
 				   sizeof(struct pisp_be_tiles_config) *
 					PISP_BE_NUM_CONFIG_BUFFERS,
-				   &node_group->config_dma_addr, GFP_KERNEL);
-	if (!node_group->config) {
+				   &pispbe->config_dma_addr, GFP_KERNEL);
+	if (!pispbe->config) {
 		dev_err(pispbe->dev, "Unable to allocate cached config buffers.\n");
 		ret = -ENOMEM;
 		goto err_unregister_mdev;
@@ -1795,12 +1576,12 @@ static int pispbe_init_group(struct pisp
 err_unregister_mdev:
 	media_device_unregister(mdev);
 err_unregister_nodes:
-	while (num_registered-- > 0) {
-		video_unregister_device(&node_group->node[num_registered].vfd);
-		vb2_queue_release(&node_group->node[num_registered].queue);
+	while (num_regist-- > 0) {
+		video_unregister_device(&pispbe->node[num_regist].vfd);
+		vb2_queue_release(&pispbe->node[num_regist].queue);
 	}
-	v4l2_device_unregister_subdev(&node_group->sd);
-	media_entity_cleanup(&node_group->sd.entity);
+	v4l2_device_unregister_subdev(&pispbe->sd);
+	media_entity_cleanup(&pispbe->sd.entity);
 err_unregister_v4l2:
 	v4l2_device_unregister(v4l2_dev);
 err_media_dev_cleanup:
@@ -1808,32 +1589,31 @@ err_media_dev_cleanup:
 	return ret;
 }
 
-static void pispbe_destroy_node_group(struct pispbe_node_group *node_group)
+static void pispbe_destroy_devices(struct pispbe_dev *pispbe)
 {
-	struct pispbe_dev *pispbe = node_group->pispbe;
-	int i;
-
-	if (node_group->config) {
-		dma_free_coherent(node_group->pispbe->dev,
+	if (pispbe->config) {
+		dma_free_coherent(pispbe->dev,
 				  sizeof(struct pisp_be_tiles_config) *
 					PISP_BE_NUM_CONFIG_BUFFERS,
-				  node_group->config,
-				  node_group->config_dma_addr);
+				  pispbe->config,
+				  pispbe->config_dma_addr);
 	}
 
-	dev_info(pispbe->dev, "Unregister from media controller\n");
+	dev_dbg(pispbe->dev, "Unregister from media controller\n");
 
-	v4l2_device_unregister_subdev(&node_group->sd);
-	media_entity_cleanup(&node_group->sd.entity);
-	media_device_unregister(&node_group->mdev);
+	v4l2_device_unregister_subdev(&pispbe->sd);
+	media_entity_cleanup(&pispbe->sd.entity);
+	media_device_unregister(&pispbe->mdev);
 
-	for (i = PISPBE_NUM_NODES - 1; i >= 0; i--) {
-		video_unregister_device(&node_group->node[i].vfd);
-		vb2_queue_release(&node_group->node[i].queue);
+	for (int i = PISPBE_NUM_NODES - 1; i >= 0; i--) {
+		video_unregister_device(&pispbe->node[i].vfd);
+		vb2_queue_release(&pispbe->node[i].queue);
+		mutex_destroy(&pispbe->node[i].node_lock);
+		mutex_destroy(&pispbe->node[i].queue_lock);
 	}
 
-	media_device_cleanup(&node_group->mdev);
-	v4l2_device_unregister(&node_group->v4l2_dev);
+	media_device_cleanup(&pispbe->mdev);
+	v4l2_device_unregister(&pispbe->v4l2_dev);
 }
 
 static int pispbe_runtime_suspend(struct device *dev)
@@ -1862,13 +1642,48 @@ static int pispbe_runtime_resume(struct
 	return 0;
 }
 
-/*
- * Probe the ISP-BE hardware block, as a single platform device.
- * This will instantiate multiple "node groups" each with many device nodes.
- */
+static int pispbe_hw_init(struct pispbe_dev *pispbe)
+{
+	u32 u;
+
+	/* Check the HW is present and has a known version */
+	u = pispbe_rd(pispbe, PISP_BE_VERSION_REG);
+	dev_dbg(pispbe->dev, "pispbe_probe: HW version:  0x%08x", u);
+	pispbe->hw_version = u;
+	if ((u & ~PISP_BE_VERSION_MINOR_BITS) != PISP_BE_VERSION_2712)
+		return -ENODEV;
+
+	/* Clear leftover interrupts */
+	pispbe_wr(pispbe, PISP_BE_INTERRUPT_STATUS_REG, 0xFFFFFFFFu);
+	u = pispbe_rd(pispbe, PISP_BE_BATCH_STATUS_REG);
+	dev_dbg(pispbe->dev, "pispbe_probe: BatchStatus: 0x%08x", u);
+
+	pispbe->done = (uint8_t)u;
+	pispbe->started = (uint8_t)(u >> 8);
+	u = pispbe_rd(pispbe, PISP_BE_STATUS_REG);
+	dev_dbg(pispbe->dev, "pispbe_probe: Status:      0x%08x", u);
+
+	if (u != 0 || pispbe->done != pispbe->started) {
+		dev_err(pispbe->dev, "pispbe_probe: HW is stuck or busy\n");
+		return -EBUSY;
+	}
+
+	/*
+	 * AXI QOS=0, CACHE=4'b0010, PROT=3'b011
+	 * Also set "chicken bits" 22:20 which enable sub-64-byte bursts
+	 * and AXI AWID/BID variability (on versions which support this).
+	 */
+	pispbe_wr(pispbe, PISP_BE_AXI_REG, 0x32703200u);
+
+	/* Enable both interrupt flags */
+	pispbe_wr(pispbe, PISP_BE_INTERRUPT_EN_REG, 0x00000003u);
+
+	return 0;
+}
+
+/* Probe the ISP-BE hardware block, as a single platform device. */
 static int pispbe_probe(struct platform_device *pdev)
 {
-	unsigned int num_groups = 0;
 	struct pispbe_dev *pispbe;
 	int ret;
 
@@ -1913,55 +1728,43 @@ static int pispbe_probe(struct platform_
 	pm_runtime_use_autosuspend(pispbe->dev);
 	pm_runtime_enable(pispbe->dev);
 
-	ret = pm_runtime_resume_and_get(pispbe->dev);
+	ret = pispbe_runtime_resume(pispbe->dev);
 	if (ret)
 		goto pm_runtime_disable_err;
 
-	pispbe->hw_busy = 0;
+	pispbe->hw_busy = false;
 	spin_lock_init(&pispbe->hw_lock);
-	ret = hw_init(pispbe);
+	ret = pispbe_hw_init(pispbe);
 	if (ret)
-		goto pm_runtime_put_err;
+		goto pm_runtime_suspend_err;
 
-	/*
-	 * Initialise and register devices for each node_group, including media
-	 * device
-	 */
-	for (num_groups = 0;
-	     num_groups < PISPBE_NUM_NODE_GROUPS;
-	     num_groups++) {
-		ret = pispbe_init_group(pispbe, num_groups);
-		if (ret)
-			goto disable_nodes_err;
-	}
+	ret = pispbe_init_devices(pispbe);
+	if (ret)
+		goto disable_devs_err;
 
 	pm_runtime_mark_last_busy(pispbe->dev);
 	pm_runtime_put_autosuspend(pispbe->dev);
 
 	return 0;
 
-disable_nodes_err:
-	while (num_groups-- > 0)
-		pispbe_destroy_node_group(&pispbe->node_group[num_groups]);
-pm_runtime_put_err:
-	pm_runtime_put(pispbe->dev);
+disable_devs_err:
+	pispbe_destroy_devices(pispbe);
+pm_runtime_suspend_err:
+	pispbe_runtime_suspend(pispbe->dev);
 pm_runtime_disable_err:
 	pm_runtime_dont_use_autosuspend(pispbe->dev);
 	pm_runtime_disable(pispbe->dev);
 
-	dev_err(&pdev->dev, "%s: returning %d", __func__, ret);
-
 	return ret;
 }
 
 static int pispbe_remove(struct platform_device *pdev)
 {
 	struct pispbe_dev *pispbe = platform_get_drvdata(pdev);
-	int i;
 
-	for (i = PISPBE_NUM_NODE_GROUPS - 1; i >= 0; i--)
-		pispbe_destroy_node_group(&pispbe->node_group[i]);
+	pispbe_destroy_devices(pispbe);
 
+	pispbe_runtime_suspend(pispbe->dev);
 	pm_runtime_dont_use_autosuspend(pispbe->dev);
 	pm_runtime_disable(pispbe->dev);
 
@@ -1991,3 +1794,8 @@ static struct platform_driver pispbe_pdr
 };
 
 module_platform_driver(pispbe_pdrv);
+
+MODULE_DESCRIPTION("PiSP Back End driver");
+MODULE_AUTHOR("David Plowman <david.plowman@raspberrypi.com>");
+MODULE_AUTHOR("Nick Hollinghurst <nick.hollinghurst@raspberrypi.com>");
+MODULE_LICENSE("GPL");
--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be_config.h
+++ /dev/null
@@ -1,533 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only WITH Linux-syscall-note */
-/*
- * PiSP Back End configuration definitions.
- *
- * Copyright (C) 2021 - Raspberry Pi Ltd
- *
- */
-#ifndef _PISP_BE_CONFIG_H_
-#define _PISP_BE_CONFIG_H_
-
-#include <linux/types.h>
-
-#include <media/raspberrypi/pisp_common.h>
-
-/* byte alignment for inputs */
-#define PISP_BACK_END_INPUT_ALIGN 4u
-/* alignment for compressed inputs */
-#define PISP_BACK_END_COMPRESSED_ALIGN 8u
-/* minimum required byte alignment for outputs */
-#define PISP_BACK_END_OUTPUT_MIN_ALIGN 16u
-/* preferred byte alignment for outputs */
-#define PISP_BACK_END_OUTPUT_MAX_ALIGN 64u
-
-/* minimum allowed tile width anywhere in the pipeline */
-#define PISP_BACK_END_MIN_TILE_WIDTH 16u
-/* minimum allowed tile width anywhere in the pipeline */
-#define PISP_BACK_END_MIN_TILE_HEIGHT 16u
-
-#define PISP_BACK_END_NUM_OUTPUTS 2
-#define PISP_BACK_END_HOG_OUTPUT 1
-
-#define PISP_BACK_END_NUM_TILES 64
-
-enum pisp_be_bayer_enable {
-	PISP_BE_BAYER_ENABLE_INPUT = 0x000001,
-	PISP_BE_BAYER_ENABLE_DECOMPRESS = 0x000002,
-	PISP_BE_BAYER_ENABLE_DPC = 0x000004,
-	PISP_BE_BAYER_ENABLE_GEQ = 0x000008,
-	PISP_BE_BAYER_ENABLE_TDN_INPUT = 0x000010,
-	PISP_BE_BAYER_ENABLE_TDN_DECOMPRESS = 0x000020,
-	PISP_BE_BAYER_ENABLE_TDN = 0x000040,
-	PISP_BE_BAYER_ENABLE_TDN_COMPRESS = 0x000080,
-	PISP_BE_BAYER_ENABLE_TDN_OUTPUT = 0x000100,
-	PISP_BE_BAYER_ENABLE_SDN = 0x000200,
-	PISP_BE_BAYER_ENABLE_BLC = 0x000400,
-	PISP_BE_BAYER_ENABLE_STITCH_INPUT = 0x000800,
-	PISP_BE_BAYER_ENABLE_STITCH_DECOMPRESS = 0x001000,
-	PISP_BE_BAYER_ENABLE_STITCH = 0x002000,
-	PISP_BE_BAYER_ENABLE_STITCH_COMPRESS = 0x004000,
-	PISP_BE_BAYER_ENABLE_STITCH_OUTPUT = 0x008000,
-	PISP_BE_BAYER_ENABLE_WBG = 0x010000,
-	PISP_BE_BAYER_ENABLE_CDN = 0x020000,
-	PISP_BE_BAYER_ENABLE_LSC = 0x040000,
-	PISP_BE_BAYER_ENABLE_TONEMAP = 0x080000,
-	PISP_BE_BAYER_ENABLE_CAC = 0x100000,
-	PISP_BE_BAYER_ENABLE_DEBIN = 0x200000,
-	PISP_BE_BAYER_ENABLE_DEMOSAIC = 0x400000,
-};
-
-enum pisp_be_rgb_enable {
-	PISP_BE_RGB_ENABLE_INPUT = 0x000001,
-	PISP_BE_RGB_ENABLE_CCM = 0x000002,
-	PISP_BE_RGB_ENABLE_SAT_CONTROL = 0x000004,
-	PISP_BE_RGB_ENABLE_YCBCR = 0x000008,
-	PISP_BE_RGB_ENABLE_FALSE_COLOUR = 0x000010,
-	PISP_BE_RGB_ENABLE_SHARPEN = 0x000020,
-	/* Preferred colours would occupy 0x000040 */
-	PISP_BE_RGB_ENABLE_YCBCR_INVERSE = 0x000080,
-	PISP_BE_RGB_ENABLE_GAMMA = 0x000100,
-	PISP_BE_RGB_ENABLE_CSC0 = 0x000200,
-	PISP_BE_RGB_ENABLE_CSC1 = 0x000400,
-	PISP_BE_RGB_ENABLE_DOWNSCALE0 = 0x001000,
-	PISP_BE_RGB_ENABLE_DOWNSCALE1 = 0x002000,
-	PISP_BE_RGB_ENABLE_RESAMPLE0 = 0x008000,
-	PISP_BE_RGB_ENABLE_RESAMPLE1 = 0x010000,
-	PISP_BE_RGB_ENABLE_OUTPUT0 = 0x040000,
-	PISP_BE_RGB_ENABLE_OUTPUT1 = 0x080000,
-	PISP_BE_RGB_ENABLE_HOG = 0x200000
-};
-
-#define PISP_BE_RGB_ENABLE_CSC(i) (PISP_BE_RGB_ENABLE_CSC0 << (i))
-#define PISP_BE_RGB_ENABLE_DOWNSCALE(i) (PISP_BE_RGB_ENABLE_DOWNSCALE0 << (i))
-#define PISP_BE_RGB_ENABLE_RESAMPLE(i) (PISP_BE_RGB_ENABLE_RESAMPLE0 << (i))
-#define PISP_BE_RGB_ENABLE_OUTPUT(i) (PISP_BE_RGB_ENABLE_OUTPUT0 << (i))
-
-/*
- * We use the enable flags to show when blocks are "dirty", but we need some
- * extra ones too.
- */
-enum pisp_be_dirty {
-	PISP_BE_DIRTY_GLOBAL = 0x0001,
-	PISP_BE_DIRTY_SH_FC_COMBINE = 0x0002,
-	PISP_BE_DIRTY_CROP = 0x0004
-};
-
-struct pisp_be_global_config {
-	u32 bayer_enables;
-	u32 rgb_enables;
-	u8 bayer_order;
-	u8 pad[3];
-};
-
-struct pisp_be_input_buffer_config {
-	/* low 32 bits followed by high 32 bits (for each of up to 3 planes) */
-	u32 addr[3][2];
-};
-
-struct pisp_be_dpc_config {
-	u8 coeff_level;
-	u8 coeff_range;
-	u8 pad;
-#define PISP_BE_DPC_FLAG_FOLDBACK 1
-	u8 flags;
-};
-
-struct pisp_be_geq_config {
-	u16 offset;
-#define PISP_BE_GEQ_SHARPER BIT(15)
-#define PISP_BE_GEQ_SLOPE ((1 << 10) - 1)
-	/* top bit is the "sharper" flag, slope value is bottom 10 bits */
-	u16 slope_sharper;
-	u16 min;
-	u16 max;
-};
-
-struct pisp_be_tdn_input_buffer_config {
-	/* low 32 bits followed by high 32 bits */
-	u32 addr[2];
-};
-
-struct pisp_be_tdn_config {
-	u16 black_level;
-	u16 ratio;
-	u16 noise_constant;
-	u16 noise_slope;
-	u16 threshold;
-	u8 reset;
-	u8 pad;
-};
-
-struct pisp_be_tdn_output_buffer_config {
-	/* low 32 bits followed by high 32 bits */
-	u32 addr[2];
-};
-
-struct pisp_be_sdn_config {
-	u16 black_level;
-	u8 leakage;
-	u8 pad;
-	u16 noise_constant;
-	u16 noise_slope;
-	u16 noise_constant2;
-	u16 noise_slope2;
-};
-
-struct pisp_be_stitch_input_buffer_config {
-	/* low 32 bits followed by high 32 bits */
-	u32 addr[2];
-};
-
-#define PISP_BE_STITCH_STREAMING_LONG 0x8000
-#define PISP_BE_STITCH_EXPOSURE_RATIO_MASK 0x7fff
-
-struct pisp_be_stitch_config {
-	u16 threshold_lo;
-	u8 threshold_diff_power;
-	u8 pad;
-
-	/* top bit indicates whether streaming input is the long exposure */
-	u16 exposure_ratio;
-
-	u8 motion_threshold_256;
-	u8 motion_threshold_recip;
-};
-
-struct pisp_be_stitch_output_buffer_config {
-	/* low 32 bits followed by high 32 bits */
-	u32 addr[2];
-};
-
-struct pisp_be_cdn_config {
-	u16 thresh;
-	u8 iir_strength;
-	u8 g_adjust;
-};
-
-#define PISP_BE_LSC_LOG_GRID_SIZE 5
-#define PISP_BE_LSC_GRID_SIZE (1 << PISP_BE_LSC_LOG_GRID_SIZE)
-#define PISP_BE_LSC_STEP_PRECISION 18
-
-struct pisp_be_lsc_config {
-	/* (1<<18) / grid_cell_width */
-	u16 grid_step_x;
-	/* (1<<18) / grid_cell_height */
-	u16 grid_step_y;
-	/* RGB gains jointly encoded in 32 bits */
-	u32 lut_packed[PISP_BE_LSC_GRID_SIZE + 1]
-			   [PISP_BE_LSC_GRID_SIZE + 1];
-};
-
-struct pisp_be_lsc_extra {
-	u16 offset_x;
-	u16 offset_y;
-};
-
-#define PISP_BE_CAC_LOG_GRID_SIZE 3
-#define PISP_BE_CAC_GRID_SIZE (1 << PISP_BE_CAC_LOG_GRID_SIZE)
-#define PISP_BE_CAC_STEP_PRECISION 20
-
-struct pisp_be_cac_config {
-	/* (1<<20) / grid_cell_width */
-	u16 grid_step_x;
-	/* (1<<20) / grid_cell_height */
-	u16 grid_step_y;
-	/* [gridy][gridx][rb][xy] */
-	s8 lut[PISP_BE_CAC_GRID_SIZE + 1][PISP_BE_CAC_GRID_SIZE + 1][2][2];
-};
-
-struct pisp_be_cac_extra {
-	u16 offset_x;
-	u16 offset_y;
-};
-
-#define PISP_BE_DEBIN_NUM_COEFFS 4
-
-struct pisp_be_debin_config {
-	s8 coeffs[PISP_BE_DEBIN_NUM_COEFFS];
-	s8 h_enable;
-	s8 v_enable;
-	s8 pad[2];
-};
-
-#define PISP_BE_TONEMAP_LUT_SIZE 64
-
-struct pisp_be_tonemap_config {
-	u16 detail_constant;
-	u16 detail_slope;
-	u16 iir_strength;
-	u16 strength;
-	u32 lut[PISP_BE_TONEMAP_LUT_SIZE];
-};
-
-struct pisp_be_demosaic_config {
-	u8 sharper;
-	u8 fc_mode;
-	u8 pad[2];
-};
-
-struct pisp_be_ccm_config {
-	s16 coeffs[9];
-	u8 pad[2];
-	s32 offsets[3];
-};
-
-struct pisp_be_sat_control_config {
-	u8 shift_r;
-	u8 shift_g;
-	u8 shift_b;
-	u8 pad;
-};
-
-struct pisp_be_false_colour_config {
-	u8 distance;
-	u8 pad[3];
-};
-
-#define PISP_BE_SHARPEN_SIZE 5
-#define PISP_BE_SHARPEN_FUNC_NUM_POINTS 9
-
-struct pisp_be_sharpen_config {
-	s8 kernel0[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
-	s8 pad0[3];
-	s8 kernel1[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
-	s8 pad1[3];
-	s8 kernel2[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
-	s8 pad2[3];
-	s8 kernel3[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
-	s8 pad3[3];
-	s8 kernel4[PISP_BE_SHARPEN_SIZE * PISP_BE_SHARPEN_SIZE];
-	s8 pad4[3];
-	u16 threshold_offset0;
-	u16 threshold_slope0;
-	u16 scale0;
-	u16 pad5;
-	u16 threshold_offset1;
-	u16 threshold_slope1;
-	u16 scale1;
-	u16 pad6;
-	u16 threshold_offset2;
-	u16 threshold_slope2;
-	u16 scale2;
-	u16 pad7;
-	u16 threshold_offset3;
-	u16 threshold_slope3;
-	u16 scale3;
-	u16 pad8;
-	u16 threshold_offset4;
-	u16 threshold_slope4;
-	u16 scale4;
-	u16 pad9;
-	u16 positive_strength;
-	u16 positive_pre_limit;
-	u16 positive_func[PISP_BE_SHARPEN_FUNC_NUM_POINTS];
-	u16 positive_limit;
-	u16 negative_strength;
-	u16 negative_pre_limit;
-	u16 negative_func[PISP_BE_SHARPEN_FUNC_NUM_POINTS];
-	u16 negative_limit;
-	u8 enables;
-	u8 white;
-	u8 black;
-	u8 grey;
-};
-
-struct pisp_be_sh_fc_combine_config {
-	u8 y_factor;
-	u8 c1_factor;
-	u8 c2_factor;
-	u8 pad;
-};
-
-#define PISP_BE_GAMMA_LUT_SIZE 64
-
-struct pisp_be_gamma_config {
-	u32 lut[PISP_BE_GAMMA_LUT_SIZE];
-};
-
-struct pisp_be_crop_config {
-	u16 offset_x, offset_y;
-	u16 width, height;
-};
-
-#define PISP_BE_RESAMPLE_FILTER_SIZE 96
-
-struct pisp_be_resample_config {
-	u16 scale_factor_h, scale_factor_v;
-	s16 coef[PISP_BE_RESAMPLE_FILTER_SIZE];
-};
-
-struct pisp_be_resample_extra {
-	u16 scaled_width;
-	u16 scaled_height;
-	s16 initial_phase_h[3];
-	s16 initial_phase_v[3];
-};
-
-struct pisp_be_downscale_config {
-	u16 scale_factor_h;
-	u16 scale_factor_v;
-	u16 scale_recip_h;
-	u16 scale_recip_v;
-};
-
-struct pisp_be_downscale_extra {
-	u16 scaled_width;
-	u16 scaled_height;
-};
-
-struct pisp_be_hog_config {
-	u8 compute_signed;
-	u8 channel_mix[3];
-	u32 stride;
-};
-
-struct pisp_be_axi_config {
-	u8 r_qos; /* Read QoS */
-	u8 r_cache_prot; /* Read { prot[2:0], cache[3:0] } */
-	u8 w_qos; /* Write QoS */
-	u8 w_cache_prot; /* Write { prot[2:0], cache[3:0] } */
-};
-
-enum pisp_be_transform {
-	PISP_BE_TRANSFORM_NONE = 0x0,
-	PISP_BE_TRANSFORM_HFLIP = 0x1,
-	PISP_BE_TRANSFORM_VFLIP = 0x2,
-	PISP_BE_TRANSFORM_ROT180 =
-		(PISP_BE_TRANSFORM_HFLIP | PISP_BE_TRANSFORM_VFLIP)
-};
-
-struct pisp_be_output_format_config {
-	struct pisp_image_format_config image;
-	u8 transform;
-	u8 pad[3];
-	u16 lo;
-	u16 hi;
-	u16 lo2;
-	u16 hi2;
-};
-
-struct pisp_be_output_buffer_config {
-	/* low 32 bits followed by high 32 bits (for each of 3 planes) */
-	u32 addr[3][2];
-};
-
-struct pisp_be_hog_buffer_config {
-	/* low 32 bits followed by high 32 bits */
-	u32 addr[2];
-};
-
-struct pisp_be_config {
-	/* I/O configuration: */
-	struct pisp_be_input_buffer_config input_buffer;
-	struct pisp_be_tdn_input_buffer_config tdn_input_buffer;
-	struct pisp_be_stitch_input_buffer_config stitch_input_buffer;
-	struct pisp_be_tdn_output_buffer_config tdn_output_buffer;
-	struct pisp_be_stitch_output_buffer_config stitch_output_buffer;
-	struct pisp_be_output_buffer_config
-				output_buffer[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_hog_buffer_config hog_buffer;
-	/* Processing configuration: */
-	struct pisp_be_global_config global;
-	struct pisp_image_format_config input_format;
-	struct pisp_decompress_config decompress;
-	struct pisp_be_dpc_config dpc;
-	struct pisp_be_geq_config geq;
-	struct pisp_image_format_config tdn_input_format;
-	struct pisp_decompress_config tdn_decompress;
-	struct pisp_be_tdn_config tdn;
-	struct pisp_compress_config tdn_compress;
-	struct pisp_image_format_config tdn_output_format;
-	struct pisp_be_sdn_config sdn;
-	struct pisp_bla_config blc;
-	struct pisp_compress_config stitch_compress;
-	struct pisp_image_format_config stitch_output_format;
-	struct pisp_image_format_config stitch_input_format;
-	struct pisp_decompress_config stitch_decompress;
-	struct pisp_be_stitch_config stitch;
-	struct pisp_be_lsc_config lsc;
-	struct pisp_wbg_config wbg;
-	struct pisp_be_cdn_config cdn;
-	struct pisp_be_cac_config cac;
-	struct pisp_be_debin_config debin;
-	struct pisp_be_tonemap_config tonemap;
-	struct pisp_be_demosaic_config demosaic;
-	struct pisp_be_ccm_config ccm;
-	struct pisp_be_sat_control_config sat_control;
-	struct pisp_be_ccm_config ycbcr;
-	struct pisp_be_sharpen_config sharpen;
-	struct pisp_be_false_colour_config false_colour;
-	struct pisp_be_sh_fc_combine_config sh_fc_combine;
-	struct pisp_be_ccm_config ycbcr_inverse;
-	struct pisp_be_gamma_config gamma;
-	struct pisp_be_ccm_config csc[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_downscale_config downscale[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_resample_config resample[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_output_format_config
-				output_format[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_hog_config hog;
-	struct pisp_be_axi_config axi;
-	/* Non-register fields: */
-	struct pisp_be_lsc_extra lsc_extra;
-	struct pisp_be_cac_extra cac_extra;
-	struct pisp_be_downscale_extra
-				downscale_extra[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_resample_extra resample_extra[PISP_BACK_END_NUM_OUTPUTS];
-	struct pisp_be_crop_config crop;
-	struct pisp_image_format_config hog_format;
-	u32 dirty_flags_bayer; /* these use pisp_be_bayer_enable */
-	u32 dirty_flags_rgb; /* use pisp_be_rgb_enable */
-	u32 dirty_flags_extra; /* these use pisp_be_dirty_t */
-};
-
-/*
- * We also need a tile structure to describe the size of the tiles going
- * through the pipeline.
- */
-
-enum pisp_tile_edge {
-	PISP_LEFT_EDGE = (1 << 0),
-	PISP_RIGHT_EDGE = (1 << 1),
-	PISP_TOP_EDGE = (1 << 2),
-	PISP_BOTTOM_EDGE = (1 << 3)
-};
-
-struct pisp_tile {
-	u8 edge; // enum pisp_tile_edge
-	u8 pad0[3];
-	// 4 bytes
-	u32 input_addr_offset;
-	u32 input_addr_offset2;
-	u16 input_offset_x;
-	u16 input_offset_y;
-	u16 input_width;
-	u16 input_height;
-	// 20 bytes
-	u32 tdn_input_addr_offset;
-	u32 tdn_output_addr_offset;
-	u32 stitch_input_addr_offset;
-	u32 stitch_output_addr_offset;
-	// 36 bytes
-	u32 lsc_grid_offset_x;
-	u32 lsc_grid_offset_y;
-	// 44 bytes
-	u32 cac_grid_offset_x;
-	u32 cac_grid_offset_y;
-	// 52 bytes
-	u16 crop_x_start[PISP_BACK_END_NUM_OUTPUTS];
-	u16 crop_x_end[PISP_BACK_END_NUM_OUTPUTS];
-	u16 crop_y_start[PISP_BACK_END_NUM_OUTPUTS];
-	u16 crop_y_end[PISP_BACK_END_NUM_OUTPUTS];
-	// 68 bytes
-	/* Ordering is planes then branches */
-	u16 downscale_phase_x[3 * PISP_BACK_END_NUM_OUTPUTS];
-	u16 downscale_phase_y[3 * PISP_BACK_END_NUM_OUTPUTS];
-	// 92 bytes
-	u16 resample_in_width[PISP_BACK_END_NUM_OUTPUTS];
-	u16 resample_in_height[PISP_BACK_END_NUM_OUTPUTS];
-	// 100 bytes
-	/* Ordering is planes then branches */
-	u16 resample_phase_x[3 * PISP_BACK_END_NUM_OUTPUTS];
-	u16 resample_phase_y[3 * PISP_BACK_END_NUM_OUTPUTS];
-	// 124 bytes
-	u16 output_offset_x[PISP_BACK_END_NUM_OUTPUTS];
-	u16 output_offset_y[PISP_BACK_END_NUM_OUTPUTS];
-	u16 output_width[PISP_BACK_END_NUM_OUTPUTS];
-	u16 output_height[PISP_BACK_END_NUM_OUTPUTS];
-	// 140 bytes
-	u32 output_addr_offset[PISP_BACK_END_NUM_OUTPUTS];
-	u32 output_addr_offset2[PISP_BACK_END_NUM_OUTPUTS];
-	// 156 bytes
-	u32 output_hog_addr_offset;
-	// 160 bytes
-};
-
-static_assert(sizeof(struct pisp_tile) == 160);
-
-struct pisp_be_tiles_config {
-	struct pisp_be_config config;
-	struct pisp_tile tiles[PISP_BACK_END_NUM_TILES];
-	int num_tiles;
-};
-
-#endif /* _PISP_BE_CONFIG_H_ */
--- a/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
+++ b/drivers/media/platform/raspberrypi/pisp_be/pisp_be_formats.h
@@ -2,7 +2,7 @@
 /*
  * PiSP Back End driver image format definitions.
  *
- * Copyright (c) 2021 Raspberry Pi Ltd
+ * Copyright (c) 2021-2024 Raspberry Pi Ltd
  */
 
 #ifndef _PISP_BE_FORMATS_
@@ -11,15 +11,15 @@
 #include <linux/bits.h>
 #include <linux/videodev2.h>
 
-#define MAX_PLANES 3
-#define P3(x) ((x) * 8)
+#define PISPBE_MAX_PLANES	3
+#define P3(x)			((x) * 8)
 
 struct pisp_be_format {
 	unsigned int fourcc;
 	unsigned int align;
 	unsigned int bit_depth;
 	/* 0P3 factor for plane sizing */
-	unsigned int plane_factor[MAX_PLANES];
+	unsigned int plane_factor[PISPBE_MAX_PLANES];
 	unsigned int num_planes;
 	unsigned int colorspace_mask;
 	enum v4l2_colorspace colorspace_default;
@@ -27,14 +27,19 @@ struct pisp_be_format {
 
 #define V4L2_COLORSPACE_MASK(colorspace) BIT(colorspace)
 
-#define V4L2_COLORSPACE_MASK_JPEG V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_JPEG)
-#define V4L2_COLORSPACE_MASK_SMPTE170M V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SMPTE170M)
-#define V4L2_COLORSPACE_MASK_REC709 V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_REC709)
-#define V4L2_COLORSPACE_MASK_SRGB V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SRGB)
-#define V4L2_COLORSPACE_MASK_RAW V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_RAW)
+#define V4L2_COLORSPACE_MASK_JPEG	\
+	V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_JPEG)
+#define V4L2_COLORSPACE_MASK_SMPTE170M	\
+	V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SMPTE170M)
+#define V4L2_COLORSPACE_MASK_REC709	\
+	V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_REC709)
+#define V4L2_COLORSPACE_MASK_SRGB	\
+	V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_SRGB)
+#define V4L2_COLORSPACE_MASK_RAW	\
+	V4L2_COLORSPACE_MASK(V4L2_COLORSPACE_RAW)
 
 /*
- * All three colour spaces JPEG, SMPTE170M and REC709 are fundamentally sRGB
+ * All three colour spaces SRGB, SMPTE170M and REC709 are fundamentally sRGB
  * underneath (as near as makes no difference to us), just with different YCbCr
  * encodings. Therefore the ISP can generate sRGB on its main output and any of
  * the others on its low resolution output. Applications should, when using both
@@ -43,9 +48,9 @@ struct pisp_be_format {
  * producing an RGB format. In turn this requires us to allow all these colour
  * spaces for every YUV/RGB output format.
  */
-#define V4L2_COLORSPACE_MASK_ALL_SRGB (V4L2_COLORSPACE_MASK_JPEG |	\
-				       V4L2_COLORSPACE_MASK_SRGB |	\
-				       V4L2_COLORSPACE_MASK_SMPTE170M |	\
+#define V4L2_COLORSPACE_MASK_ALL_SRGB (V4L2_COLORSPACE_MASK_JPEG	| \
+				       V4L2_COLORSPACE_MASK_SRGB	| \
+				       V4L2_COLORSPACE_MASK_SMPTE170M	| \
 				       V4L2_COLORSPACE_MASK_REC709)
 
 static const struct pisp_be_format supported_formats[] = {
@@ -58,7 +63,7 @@ static const struct pisp_be_format suppo
 		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
 		.num_planes	    = 1,
 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
-		.colorspace_default = V4L2_COLORSPACE_JPEG,
+		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
 	},
 	{
 		.fourcc		    = V4L2_PIX_FMT_YVU420,
@@ -132,7 +137,7 @@ static const struct pisp_be_format suppo
 		.plane_factor	    = { P3(1), P3(0.25), P3(0.25) },
 		.num_planes	    = 3,
 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
-		.colorspace_default = V4L2_COLORSPACE_JPEG,
+		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
 	},
 	{
 		.fourcc		    = V4L2_PIX_FMT_NV12M,
@@ -168,7 +173,7 @@ static const struct pisp_be_format suppo
 		.plane_factor	    = { P3(1), P3(0.5), P3(0.5) },
 		.num_planes	    = 3,
 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
-		.colorspace_default = V4L2_COLORSPACE_JPEG,
+		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
 	},
 	{
 		.fourcc		    = V4L2_PIX_FMT_YVU422M,
@@ -186,7 +191,7 @@ static const struct pisp_be_format suppo
 		.plane_factor	    = { P3(1), P3(1), P3(1) },
 		.num_planes	    = 3,
 		.colorspace_mask    = V4L2_COLORSPACE_MASK_ALL_SRGB,
-		.colorspace_default = V4L2_COLORSPACE_JPEG,
+		.colorspace_default = V4L2_COLORSPACE_SMPTE170M,
 	},
 	{
 		.fourcc		    = V4L2_PIX_FMT_YVU444M,
@@ -502,11 +507,6 @@ static const struct pisp_be_format suppo
 		.colorspace_mask    = V4L2_COLORSPACE_MASK_RAW,
 		.colorspace_default = V4L2_COLORSPACE_RAW,
 	},
-	/* Opaque BE format for HW verification. */
-	{
-		.fourcc		    = V4L2_PIX_FMT_RPI_BE,
-		.align		    = 32,
-	},
 };
 
 static const struct pisp_be_format meta_out_supported_formats[] = {
